<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="viewDocbook.css"?>
<chapter id="MasterSlave">
    <title>Master/Worker API</title>

    <para>The outline of this short handbook:</para>

    <orderedlist>
        <listitem>
            <para>
                <link linkend="ms_overview">Introduction</link>
            </para>
        </listitem>

        <listitem>
            <para>
                <link linkend="ms_principle">Principle and Usage</link>
            </para>
        </listitem>

        <listitem>
            <para>
                <link linkend="ms_api">The API Description</link>
            </para>
        </listitem>

        <listitem>
            <para>
                <link linkend="ms_example">A Simple Example</link>
            </para>
        </listitem>
        <listitem>
            <para>
                <link linkend="ms_advanced">Advanced usage</link>
            </para>
        </listitem>
    </orderedlist>

    <sect1 id="ms_overview">
        <title>Overview</title>

        <para>
            <emphasis>Master/Worker computations</emphasis>
            are the most common case of distributed computations. They
            are often described as
            <emphasis>embarrassingly parallel problems</emphasis>
            , which means that no particular effort is needed to segment
            the problem into a very large number of parallel tasks, and
            there is no essential dependency (or communication) between
            those parallel tasks.
        </para>

        <para>
            The main goal of the Master/Worker API is to provide an
            <emphasis>easy to use framework</emphasis>
            to parallelize embarrassingly parallel applications.
        </para>

        <para>The main features are:</para>

        <itemizedlist>
            <listitem>
                <para>
                    Automatic
                    <emphasis>scheduling</emphasis>
                    of tasks to the Workers.
                </para>
            </listitem>

            <listitem>
                <para>
                    Automatic
                    <emphasis>load-balancing</emphasis>
                    between the Workers.
                </para>
            </listitem>

            <listitem>
                <para>
                    Automatic
                    <emphasis>fault-tolerance</emphasis>
                    mechanism (i.e. when a Worker is missing, the task is
                    rescheduled).
                </para>
            </listitem>

            <listitem>
                <para>
                    Very simple mechanism of
                    <emphasis>solution gathering</emphasis>
                    .
                </para>
            </listitem>

            <listitem>
                <para>
                    All internal concepts of ProActive are hidden from
                    the user.
                </para>
            </listitem>

            <listitem>
                <para>Open API for extensions.</para>
            </listitem>
        </itemizedlist>
    </sect1>

    <sect1 id="ms_principle">
        <title>The Master/Worker API Principles and Usage</title>

        <para>
            The usage of the Master/Worker API is simple and it consists
            basically of four steps:
        </para>

        <orderedlist>
            <listitem>
                <para>
                    <emphasis>Deployment</emphasis>
                    of the Master/Worker framework.
                </para>
            </listitem>

            <listitem>
                <para>
                    Task
                    <emphasis>definition</emphasis>
                    and
                    <emphasis>submission</emphasis>
                    .
                </para>
            </listitem>

            <listitem>
                <para>
                    <emphasis>Results gathering</emphasis>
                    .
                </para>
            </listitem>

            <listitem>
                <para>
                    Optionally,
                    <emphasis>release</emphasis>
                    of acquired resources.
                </para>
            </listitem>
        </orderedlist>

        <sect2 id="ms_principle_deployment">
            <title>Deployment of the Master/Worker framework</title>

            <para>
                The deployment of the Master/Worker framework relies on
                the
                <emphasis>ProActive deployment mechanism</emphasis>
                . In order to deploy a set of workers, the master needs
                either:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        A
                        <emphasis>
                            ProActive deployment descriptor
                        </emphasis>
                        : in this case the master will use the
                        descriptor to deploy its resources.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        A set of already deployed
                        <emphasis>ProActive resources</emphasis>
                        (i.e. a VirtualNode object or a Collection of
                        Node objects).
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                For a better explanation of the ProActive deployment
                mechanism and of ProActive deployment descriptors, see
                <xref linkend="XML_Descriptors" />
                .
            </para>

            <para>
                <figure>
                    <title>
                        Deployment of the Master/Worker framework
                    </title>

                    <mediaobject>
                        <imageobject>
                            <imagedata contentwidth="100"
                                fileref="images/MasterWorker1.png"
                                format="PNG" width="6in" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>
            <para />

        </sect2>

        <sect2 id="ms_principle_submission">

            <title>Tasks definition and submission</title>

            <para>
                In order to submit tasks to the Master, the
                <emphasis>Task</emphasis>
                interface from the Master/Worker API needs to be
                implemented. In this interface, the unique method
                <emphasis>run</emphasis>
                will correspond to the code being executed remotely.
                After tasks have been submitted to him, the master will
                dispatch tasks automatically to the workers.
            </para>
            <para>
                <emphasis>Warning !</emphasis>
                : when a Java object implementing the Task interface
                (i.e. a user task) is submitted to the master, the
                object will be deep-copied to the master. In
                consequence, every referenced objects will also be
                copied. When tasks are submitted to the remote workers,
                the user task objects will be
                <emphasis>serialized</emphasis>
                and sent though the network. As a consequence,
                information which means something only locally will be
                lost (database connections, reference to a thread,
                etc...)
            </para>

            <para>
                <figure>
                    <title>Tasks definition and submission</title>

                    <mediaobject>
                        <imageobject>
                            <imagedata contentwidth="100"
                                fileref="images/MasterWorker2.png"
                                format="PNG" width="6in" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>
            <para />
        </sect2>

        <sect2 id="ms_principle_gathering">
            <title>Results gathering</title>



            <para>
                <emphasis>Results</emphasis>
                will be collected by the master when the calculations
                are complete. Users can either wait that one or every
                results are available. Users have also the option to ask
                the master for result availability and continue their
                own work until results are finally available.
            </para>

            <para>
                <figure>
                    <title>Results gathering</title>

                    <mediaobject>
                        <imageobject>
                            <imagedata contentwidth="100"
                                fileref="images/MasterWorker3.png"
                                format="PNG" width="6in" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>

            <para>
                Two results can be received in two modes specified in
                the
                <emphasis>ResultReceptionMode</emphasis>
                :
                <itemizedlist>
                    <listitem>
                        <para>
                            <emphasis>CompletionOrder</emphasis>
                            mode (default) : in this mode, users will
                            receive the results in an
                            <emphasis>unspecified order</emphasis>
                            , depending on tasks completion order.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            <emphasis>SubmissionOrder</emphasis>
                            mode : in this mode, users will receive the
                            results in the same order as they were
                            submitted to the master.
                        </para>

                    </listitem>
                </itemizedlist>
            </para>
            <para>
                The figures below explain the two different modes :
            </para>
            <para>
                <figure>
                    <title>Completion order</title>

                    <mediaobject>
                        <imageobject>
                            <imagedata contentwidth="100"
                                fileref="images/MSResult1.png"
                                format="PNG" width="6in" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>
            <para>
                <figure>
                    <title>Submission order</title>

                    <mediaobject>
                        <imageobject>
                            <imagedata contentwidth="100"
                                fileref="images/MSResult2.png"
                                format="PNG" width="6in" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>
            <para />
        </sect2>
    </sect1>

    <sect1 id="ms_api">
        <title>The API Details</title>

        <sect2>
            <title>Master creation and deployment</title>

            <para>
                The Master/Worker API entry point and main class is the
                following:
            </para>
            <screen><![CDATA[org.objectweb.proactive.extensions.masterworker.ProActiveMaster]]></screen>
            <para>
                The methods of this class are described in the
                interface:
            </para>
            <screen><![CDATA[org.objectweb.proactive.extensions.masterworker.interfaces.Master]]></screen>
            <para>
                The user has the possibility to create either a local
                master or a remote master.
            </para>
            <sect3>
                <title>Local Master creation</title>
                <para>
                    In order to create a local master the following
                    constructors can be used:
                </para>
                <programlisting lang="java"><![CDATA[    /**
     * Creates a local master (you can add resources afterwards)
     */
    public ProActiveMaster();]]></programlisting>
                <para>
                    Using this constructor, a master will be created in
                    the current JVM, the master will share CPU usage and
                    memory with the user JVM.
                </para>
            </sect3>
            <sect3>
                <title>Remote Master creation</title>
                <para>
                    In order to create a remote master the following
                    constructors can be used:
                </para>
                <programlisting lang="java"><![CDATA[    /**
     * Creates an empty remote master that will be created on top of the given Node <br>
     * Resources can be added to the master afterwards
     * @param remoteNodeToUse this Node will be used to create the remote master
     */
    public ProActiveMaster(Node remoteNodeToUse);

    /**
     * Creates a remote master with the URL of a descriptor and the name of a virtual node
     * The master will be created on top of a single resource deployed by this virtual node
     * @param descriptorURL url of the ProActive descriptor
     * @param masterVNName name of the virtual node to deploy inside the ProActive descriptor
     */
     
    public ProActiveMaster(URL descriptorURL, String masterVNName);]]></programlisting>

                <para>
                    Using either of these constructors, a master will be
                    created in the specified remote resource(JVM), the
                    master will share CPU usage and memory with existing
                    running applications on the remote host. The
                    mechanism in use to deploy the master remotely is
                    the ProActive deployment mechanism (see
                    <xref linkend="XML_Descriptors" />
                    for further details).
                </para>
            </sect3>
            <sect3>
                <title>Adding Resources</title>
                <para>
                    Now that the master has been created, resources
                    (Workers) must be added to it. The following methods
                    can be used for creating workers:
                </para>
                <programlisting lang="java"><![CDATA[    /**
     * Adds the given Collection of nodes to the master <br/>
     * @param nodes a collection of nodes
     */
    void addResources(Collection<Node> nodes);
    
    /**
     * Adds every resource inside the given virtual node to the master <br/>
     * @param virtualnode a virtual node object
     */
    void addResources(VirtualNode virtualnode);

    /**
     * Adds the given descriptor to the master<br>
     * Every virtual nodes inside the given descriptor will be activated<br/>
     * @param descriptorURL URL of a deployment descriptor
     */
    void addResources(URL descriptorURL);

    /**
    * Adds the given descriptor to the master<br>
    * Only the specified virtual node inside the given descriptor will be activated <br/>
    * @param descriptorURL URL of a deployment descriptor
    * @param virtualNodeName name of the virtual node to activate
    */
    void addResources(URL descriptorURL, String virtualNodeName);]]></programlisting>
                <para>
                    The first two methods will tell the master to create
                    workers on already deployed ProActive resources. The
                    last two methods will ask the master to deploy
                    resources using a ProActive descriptor and to create
                    workers on top of these resources. For a complete
                    explanation of ProActive's deployment mechanism,
                    please refer to
                    <xref linkend="XML_Descriptors" />
                    .
                </para>

            </sect3>
        </sect2>

        <sect2>
            <title>Task Definition</title>

            <para>
                The task interface is defined at:
                <screen><![CDATA[org.objectweb.proactive.extensions.masterworker.interfaces.Task]]></screen>
            </para>

            <programlisting lang="java"><![CDATA[public interface Task<R extends Serializable> extends Serializable {
    /**
     * A task to be executed
     * @param memory access to the Worker memory
     * @return the result
     * @throws Exception
     */
    public R run(WorkerMemory memory) throws Exception;
};]]></programlisting>

            <para>
                Users need to implement the
                <emphasis>Task</emphasis>
                interface to define their tasks. The
                <emphasis>WorkerMemory</emphasis>
                parameter is explained in the
                <link linkend="ms_Workermemory">Advanced Usage</link>
                chapter.
            </para>
        </sect2>

        <sect2>
            <title>Task submission</title>

            <programlisting lang="java"><![CDATA[    /**
     * Adds a list of tasks to be solved by the master <br/>
     * @param tasks list of tasks
     * @throws TaskAlreadySubmittedException if a task is submitted twice
     */
    void solve(List<T> tasks) throws TaskAlreadySubmittedException;]]></programlisting>
            <para>
                <emphasis>Warning !</emphasis>
                : the master keeps a track of task objects that have
                been submitted to it and which are currently computing.
                Submitting two times the same task object without
                waiting for the result of the first computation is not
                allowed.
            </para>

        </sect2>

        <sect2>
        	<title>Specifying result reception order</title>
        	<para>
        		Result reception order can be switched from
        		<emphasis>Completion</emphasis>
        		order to
        		<emphasis>Submission</emphasis>
        		order using the following method :
        	</para>
        	<programlisting lang="java"><![CDATA[    /**
     * Sets the current ordering mode <br/>
     * If reception mode is switched while computations are in progress,<br/>
     * then subsequent calls to waitResults methods will be done according to the new mode.<br/>
     * @param mode the new mode for result gathering
     */
    void setResultReceptionOrder(OrderingMode mode);]]></programlisting>
        	<para>
        		The default mode of the M/S API is
        		<emphasis>Completion</emphasis>
        		order. The mode can be switched dynamically, which means
        		that subsequent calls to waitXXX methods (see below),
        		will be done according to the new mode.
        	</para>
        </sect2>


        <sect2>
            <title>Collecting results</title>

            <programlisting lang="java"><![CDATA[    /**
     * Wait for all results, will block until all results are computed <br>
     * The ordering of the results depends on the result reception mode in use <br>
     * @return a collection of objects containing the result
     * @throws TaskException if a task threw an Exception
     */
    List<R> waitAllResults() throws TaskException;

    /**
     * Wait for the first result available <br>
     * Will block until at least one Result is available. <br>
     * Note that in SubmittedOrder mode, the method will block until the next result in submission order is available<br>
     * @return an object containing the result
     * @throws TaskException if the task threw an Exception
     */
    R waitOneResult() throws TaskException;

    /**
     * Wait for a number of results<br>
     * Will block until at least k results are available. <br>
     * The ordering of the results depends on the result reception mode in use <br>
     * @param k the number of results to wait for
     * @return a collection of objects containing the results
     * @throws TaskException if the task threw an Exception
     */
    List<R> waitKResults(int k) throws TaskException;

    /**
     * Tells if the master is completely empty (i.e. has no result to provide and no tasks submitted)
     * @return the answer
     */
    boolean isEmpty();

    /**
     * Returns the number of available results <br/>
     * @return the answer
     */
    int countAvailableResults();]]></programlisting>

            <para>
                Five methods can be used in order to collect results:
                <itemizedlist>
                    <listitem>
                        <para>
                            The first three methods will block the
                            current thread until the corresponding
                            result(s) is(are) available. If an exception
                            occurs during the execution of one task,
                            this exception will be thrown back to the
                            user by the wait method.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            The fourth method will give indications on
                            results availability but will not block the
                            user thread.
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                            The last method will tell when the user has
                            received every results of tasks previously
                            submitted.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
        </sect2>

        <sect2>
            <title>Terminating the master</title>

            <programlisting lang="java"><![CDATA[    /**
     * Terminates the master (and eventually free every resources)
     * @param freeNodeResources tells if the master should as well free the node resources
     * @return success
     */
    public void terminate(boolean freeResources);]]></programlisting>

            <para>
                One single method is used to terminate the master. A
                boolean parameter tells the master to free resources or
                not (i.e. terminate remote JVMs).
            </para>
        </sect2>
    </sect1>

    <sect1 id="ms_example">
        <title>A Simple Example</title>

        <para>
            This very simple example computes PI using the Monte-Carlo
            method. The complete example is available, along with more complex ones under the
            following package in the
            <emphasis>Examples</emphasis>
            source directory:
        </para>

        <screen><![CDATA[org.objectweb.proactive.examples.masterworker]]></screen>

        <para>
            First, the task definition: creates randomly a set of points
            belonging to the [0, 1[x[0, 1[ interval and tests how many
            points are inside the uniter circle.
        </para>

        <programlisting lang="java"><![CDATA[    public static class ComputePIMonteCarlo implements Task<Long> {
        public ComputePIMonteCarlo() {
        }

        public Long run(WorkerMemory memory) throws Exception {
            long remaining = NUMBER_OF_EXPERIENCES;
            long successes = 0;
            while (remaining > 0) {
                remaining--;
                if (experience()) {
                    successes++;
                }
            }
            return successes;
        }

        public boolean experience() {
            double x = Math.random();
            double y = Math.random();
            return Math.hypot(x, y) < 1;
        }
    }]]></programlisting>

        <para>
            The example main method: the master is created and resources
            are added using a deployment descriptor .
        </para>

        <programlisting lang="java"><![CDATA[    	// creation of the master
        ProActiveMaster<ComputePIMonteCarlo, Long> master = new ProActiveMaster<ComputePIMonteCarlo, Long>();
        
        // adding resources
        master.addResources(PIExample.class.getResource(
                "/org/objectweb/proactive/examples/masterWorker/WorkersLocal.xml"));]]></programlisting>

        <para>
            Then, the tasks are created and submitted to the master.
        </para>

        <programlisting lang="java"><![CDATA[         // defining tasks
        Vector<ComputePIMonteCarlo> tasks = new Vector<ComputePIMonteCarlo>();
        for (int i = 0; i < NUMBER_OF_TASKS; i++) {
            tasks.add(new ComputePIMonteCarlo());
        }

        // adding tasks to the queue
        master.solve(tasks);]]></programlisting>

        <para>
            Then, the results are gathered and the result is displayed.
        </para>

        <programlisting lang="java"><![CDATA[        // waiting for results
        List<Long> successesList = master.waitAllResults();

        // computing PI using the results
        long sumSuccesses = 0;

        for (long successes : successesList) {
            sumSuccesses += successes;
        }

        double pi = (4 * sumSuccesses) / ((double) NUMBER_OF_EXPERIENCES * NUMBER_OF_TASKS);

        System.out.println("Computed PI by Monte-Carlo method : " + pi);]]></programlisting>


        <para>
            Finally, the master is terminated (all resources are freed)
            and the program exits.
        </para>

        <programlisting lang="java"><![CDATA[        master.terminate(true);
        System.exit(0);]]></programlisting>
    </sect1>
    <sect1 id="ms_advanced">
        <title>Advanced Usage</title>

        <sect2 id="ms_configuration">
            <title>Configuration of the Master/Worker</title>
            <sect3>
                <title>Ping Period</title>
                <para>
                    At regular intervals, the Master sends a "ping"
                    message to every Workers to check if they are alive
                    and reachable. The
                    <emphasis>Ping period</emphasis>
                    configuration parameter is the period in millisecond
                    between two "ping" messages. The default value of
                    this parameter is 10000 (which corresponds to 10
                    seconds).
                </para>
                <para>
                    In order to change this default value, the method
                    described underneath can be called :
                </para>
                <programlisting lang="java"><![CDATA[    /**
     * Sets the period at which ping messages are sent to the Workers <br/>
     * @param periodMillis the new ping period
     */
    void setPingPeriod(long periodMillis);]]></programlisting>
            </sect3>
        </sect2>
        <sect2 id="ms_Workermemory">
            <title>Using the Worker Memory</title>
            <sect3>
                <title>Principle</title>
                <para>
                    The Worker Memory principle is to allow users to
                    store and retrieve data from a
                    <emphasis>Worker's address space</emphasis>
                    . The typical use case is when one uses the Master/Worker API to compute an iterative process. An
                    iterative process consists generally of an
                    initialization step 0, followed by n computation
                    steps, where step n needs the results of step n-1.
                    The initialization steps often requires that a large
                    amount of information is "loaded" into the worker.
                    Without the worker memory access, this information
                    would be lost at each step of the iteration, which
                    means that the initialization step 0 needs to be
                    done at step 1,2, ... n, etc...

                </para>
            </sect3>
            <sect3>
                <title>Usage</title>
                <sect4>
                    <title>Structure and API</title>
                    <para>
                        The Worker memory structure is very simple: it
                        consists of
                        <emphasis>&lt;key, value&gt;</emphasis>
                        associations. A java object value is therefore
                        saved in the memory with the given name, and
                        this name will be needed to retrieve the value
                        later on.
                    </para>
                    <para>
                        The Worker Memory API consists of three methods
                        <emphasis>save</emphasis>
                        ,
                        <emphasis>load</emphasis>
                        , and
                        <emphasis>erase</emphasis>
                        . The interface to the worker memory is available
                        when running a Task as a parameter of the run
                        method. The user can therefore use this
                        interface to save, load or erase objects in the
                        local worker's memory. Below is the detailed
                        WorkerMemory interface:
                    </para>
                    <programlisting lang="java"><![CDATA[    /**
     * Save data under a specific name
     * @param name name of the data
     * @param data data to be saved
     */
    void save(String name, Object data);

    /**
     * Load some data previously saved
     * @param name the name under which the data was saved
     * @return the data
     */
    Object load(String name);

    /**
     * Erase some data previously saved
     * @param name the name of the data which need to be erased
     */
    void erase(String name);]]></programlisting>
                </sect4>
                <sect4>
                    <title>Storing data</title>
                    <para>
                        A user can store data in the Workers' memory
                        either when :
                    </para>
                    <orderedlist>
                        <listitem>
                            <para>Workers are created remotely</para>
                        </listitem>
                        <listitem>
                            <para>A task is run on the Worker.</para>
                        </listitem>
                    </orderedlist>
                    <para>
                        Usage of the first mechanism is done by
                        providing a list of &lt;key, value&gt; pairs
                        (Map) to the constructors of the ProActiveMaster
                        class. Every constructors detailed above have a
                        version including this extra parameter. The
                        given list will be the initial memory of every
                        Workers created by the master.
                    </para>
                    <para>
                        Usage of the second mechanism is done by using
                        the
                        <emphasis>WorkerMemory</emphasis>
                        parameter in the Task interface's
                        <emphasis>run</emphasis>
                        method. In contradiction with the first method,
                        only the Worker currently running the Task will
                        store the given data.

                    </para>
                </sect4>
                <sect4>
                    <title>Retrieving and using the data</title>
                    <para>
                        Loading and using any object stored in a Worker's
                        memory is simply done through the
                        <emphasis>WorkerMemory</emphasis>
                        parameter in the
                        <emphasis>run</emphasis>
                        method of the
                        <emphasis>Task</emphasis>
                        interface.
                    </para>

                </sect4>
            </sect3>
        </sect2>
    </sect1>
</chapter>
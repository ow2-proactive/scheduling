<!-- Converted by db4-upgrade version 1.0 -->

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="ProActive_Scheduler"><info><title>ProActive Scheduler and Resource Manager</title></info>
	
	<para>
		<emphasis role="bold">IMPORTANT NOTE</emphasis>
		- Some parts of the ProActive Scheduler and ProActive Resource
		Manager rely on Java Scripting capabilities (
		<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://jcp.org/en/jsr/detail?id=223">JSR 223</link>
		). As a consequence, it requires either:
		<itemizedlist>
			<listitem>
				<para>
					a 1.6 or greater Java Runtime Environment, without
					any modifications,
				</para>
			</listitem>
			<listitem>
				<para>
					or, with a 1.5 JRE, the
					<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://jcp.org/aboutJava/communityprocess/final/jsr223/index.html">
						JSR 223 jar files
					</link>
					:
				</para>
				<itemizedlist>
					<listitem>
						<para>
							First, the
							<literal>script-api.jar</literal>
							,
							<literal>script-js.jar</literal>
							and
							<literal>js.jar</literal>
							files must be added in the
							<literal>/ProActive/dist/lib/</literal>
							directory if you are using the bin release
							or ProActive, or in the
							<literal>/ProActive/lib/</literal>
							directory if you build ProActive from the
							source release.
						</para>
					</listitem>
					<listitem>
						<para>
							Then the
							<literal>java5_jsr223_patch.jar</literal>
							patch (released with the Scheduler RCP
							Client) should be executed in the Scheduler
							RCP Client directory : unzip the
							<literal>java5_jsr223_patch.zip</literal>
							file and execute
							<literal>
								java -jar java5_jsr223_patch.jar
							</literal>
							.
						</para>
					</listitem>
				</itemizedlist>
			</listitem>
		</itemizedlist>
	</para>

	<section xml:id="overview"><info><title>Overview</title></info>
		

		<para>
			The execution of parallel tasks on a pool of distributed
			resources, such as network of desktops or clusters, requires
			a main system for managing resources and handling task
			execution:
			<emphasis role="bold">a batch scheduler</emphasis>
			. A batch scheduler provides an abstraction of resources to
			users. Users submit jobs containing tasks to the
			<emphasis role="bold">scheduler</emphasis>
			, who is in charge of executing these tasks on the
			resources. A
			<emphasis role="bold">scheduler</emphasis>
			allows several users to share a same pool of resources and
			also to manage all issues related to distributed
			environment, such as faulted resources.
		</para>

		<para>
			In this chapter we present a ProActive based Scheduler
			accessible either from
			<emphasis role="bold">a JAVA programming API</emphasis>
			,
			<emphasis role="bold">
				a command-line based job submitter
			</emphasis>
			,
			<emphasis role="bold">
				or from a graphical user or admin interface
			</emphasis>
			(Eclipse RCP Plugin, see
			<xref linkend="Scheduler_Eclipse_Plugin"/>
			) which can be plugged on the scheduler core application.
		</para>

		<para>
			In the rest of this chapter, we will expose how the
			scheduler works, what policies govern the job management,
			how to create a job and how to get the jobs and the nodes
			state using either the shell communicator or the GUI.
		</para>

		<para>
			<emphasis role="bold">NOTE</emphasis>
			- Additionally, you can find
			<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://proactive.inria.fr/userfiles/file/tutorials/ProActiveSchedulerTutorial.pdf ">
				here
			</link>
			a fully documented example of the Scheduler and Resource
			Manager usage. This tutorial does not require Java nor
			ProActive knowledge since it's is only based on graphical
			interface and command line actions.
		</para>


	</section>

	<section xml:id="scheduler_concept"><info><title>Scheduler Concept</title></info>
		

		<section xml:id="what_is_job"><info><title>What is a Job ?</title></info>
			

			<para>
				A
				<emphasis role="bold">Job</emphasis>
				is the entity to be submitted to the scheduler. It is
				composed of one or more
				<emphasis role="bold">Tasks</emphasis>
				. A Job can have one of the following types :
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">TASKSFLOW</emphasis>
							, represents a Job that contains a bag of
							Tasks, which can be executed in parallel or
							according to a dependency tree. The Tasks
							inside this Job type can be either Java or
							Native.
						</para>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">PROACTIVE</emphasis>
							, represents a Job that contains a ProActive
							application (embedded in
							<emphasis>only one ProActive Task</emphasis>
							). Its execution starts with a given
							predefined number of nodes on which the user
							can start the ProActive computation. This
							kind of Job requires the usage of the
							ProActive API, in order to use the given
							nodes.
						</para>
					</listitem>

					<!--  <listitem>
						<para><emphasis role="bold">PARAMETER SWEEPING (not yet implemented)</emphasis>, is a
						Job that represents multiple executions of one type of Task with
						different given parameters. It is typically executed in parallel.
						The Tasks inside this job can also be Java or Native. </para>
						</listitem>-->
				</itemizedlist>
			</para>

			<para>
				A finished Job contains a result, which in term contains
				all of its tasks' results. However, it is possible to
				mark some task as
				<emphasis role="bold">precious</emphasis>
				in order to retrieve their result easily in the job
				result. In the event of a failure, the finished Job
				contains the cause exceptions. Further details on how to
				create a Job and the different options can be found in:
				<xref linkend="job_creation"/>
				.
			</para>
		</section>

		<section xml:id="what_is_task"><info><title>What is a Task ?</title></info>
			

			<para>
				The
				<emphasis role="bold">Task</emphasis>
				is the smallest schedulable entity. It is included in a
				<emphasis role="bold">Job</emphasis>
				(see
				<xref linkend="what_is_job"/>
				) and will be executed in accordance with the scheduling
				policy (see
				<xref linkend="scheduling_policy"/>
				) on the available resources.
			</para>

			<para>
				There are three types of Tasks :
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">JAVA</emphasis>
							; its execution is defined by a java class
							extending the
							<literal>
								org.objectweb.proactive.extensions.scheduler.common.task.executable.JavaExecutable
							</literal>
							class.
						</para>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">NATIVE</emphasis>
							; its execution can be any user program
							specified by a simple command line, or by a
							'generation script', that can dynamicaly
							generates the command line to be executed.
						</para>
					</listitem>

					<listitem>
						<para>
							<emphasis role="bold">PROACTIVE</emphasis>
							; its execution is defined by a java class
							extending the
							<literal>
								org.objectweb.proactive.extensions.scheduler.common.task.executable.ProActiveExecutable
							</literal>
							class, which defines the deployement and the
							execution of a ProActive application. Coding
							this last one requires a knowledge base on
							the use of ProActive.
						</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>
				During its execution, a Task may crash due to host or
				code failure. A Task can be re-started a parameterizable
				number of time (see re-runnable in section
				<xref linkend="task_creation"/>
				).
			</para>

			<para>
				A Task may optionally be accompanied by 3 kinds of
				scripts (pre-script, post-script and selection-script),
				that allow to select the suitable resource for a given
				task and possibly configure it before and after task
				execution (see
				<xref linkend="task_creation"/>
				).
			</para>

			<para>
				Dependencies between Tasks can also be defined; this
				apsect is detailed in
				<xref linkend="how_dependences"/>
				.
			</para>
		</section>

		<section xml:id="how_dependences"><info><title>Dependencies between Tasks</title></info>
			

			<para>
				Dependencies can be set between Tasks in a TaskFlow Job.
				It provides a way to execute your tasks in an ordered
				fashion, but also to forward the results of an ancestor
				task to its children as parameter. Dependency between
				task is then both a logical dependency and a data
				dependency.
			</para>

			<figure xml:id="scheduler_job_img"><info><title>Task flow job example</title></info>
				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%"  align="center" fileref="scheduler/pics/core/schedulerJob.jpg" format="JPG"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				In this example we made an 8 Tasks Job (where the Job's
				type is TaskFlow). As you can see, Task 4 depends on
				Task 1, Task 5 depends on Tasks 2 and 3, etc... In other
				words, Task 4 will wait for Task 1 to finish before
				starting, Task 5 will wait for Task 2
				<emphasis>AND</emphasis>
				3, etc... In addition, the order in which you specify
				that Task 5 depends of Task 2 and 3 is very important.
				Indeed, if you set the list of dependencies for Task 5
				as : 2 then 3, the result of these two task will be
				given to Task 5 in this order.
			</para>

			<para>
				As shown in the following lines, the given array of
				TaskResults (
				<emphasis>results</emphasis>
				) will be an array of two results (TaskResult 2 and 3)
				in this order. Therefore you can use them to perform
				Task 5 process.
				<programlisting xml:lang="java">
		@Override
		public Object execute(TaskResult... results) throws Throwable {
			//TaskResult
			tResult2 = results[0];
			//TaskResult
			tResult3 = results[1];
		}
				</programlisting>
			</para>

			<para>
				We will see how to define the dependencies and the order
				when we create our first job in
				<xref linkend="job_creation"/>
				. In this example, result of Task 7 and 8 could be
				<emphasis role="bold">precious</emphasis>
				, which means that you can retrieve easily this two
				results.
			</para>
		</section>

		<section xml:id="scheduling_policy"><info><title>Scheduling Policy</title></info>
			

			<para>
				<emphasis role="bold">By default</emphasis>
				, the scheduler schedules tasks according to the default
				<emphasis role="bold">
					FIFO (First In First Out) with job priority
				</emphasis>
				policy. We'll see later that the policy can be changed
				by implementing an interface. (
				<xref linkend="add_policy"/>
				)
			</para>
		</section>
	</section>

	<section xml:id="scheduler_architecture"><info><title>Scheduler Architecture</title></info>
		

		<section xml:id="Scheduler_Global_Architecture"><info><title>Scheduler Global Architecture</title></info>
			

			<para>
				The Scheduler Service is the result of a collaboration
				between 2 entities (the Scheduler and the Resource
				Manager) each one of them has its own functionality.
			</para>

			<para>
				The Scheduler is the main entity and is a non GUI daemon
				which is connected to the Resources Manager. It is in
				charge of scheduling submitted Jobs, in accordance with
				the scheduling policy.
			</para>

			<para>
				In order to launch Jobs, the Scheduler must obtain nodes
				(resources) from the Resources Manager. As describe
				below (
				<xref linkend="scheduler2entities"/>
				), the user interacts only with the Scheduler entity and
				the managed resources can be simple host or peer to peer
				resource.
			</para>

			<figure xml:id="scheduler2entities"><info><title>The Scheduler Entities</title></info>
				

				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%" fileref="scheduler/pics/core/scheduler2entities.jpg" format="JPG"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				<emphasis role="bold">In this section</emphasis>
				we will explain how the
				<emphasis role="bold">
					scheduler entity works and how it can be used.
				</emphasis>
			</para>
		</section>

		<section xml:id="Scheduler_entity_Architecture"><info><title>Scheduler Entity Architecture</title></info>
			

			<para>
				The architecture of the scheduler (
				<xref linkend="schedulerEntity"/>
				) is built around 3 Active Objects :
			</para>

			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold">
							The Authentication interface
						</emphasis>
						which is the first object that the user may have
						to contact. It is in charge of authenticatubg
						the user and allowing him access (or not) to the
						Scheduler. The authentication security system
						can interact with files or LDAP.
					</para>
				</listitem>

				<listitem>
					<para>
						<emphasis role="bold">The Front-end</emphasis>
						which is the interface returned by the
						Authentication Interface and allows interaction
						with the scheduler. This interface allows users
						to submit jobs, get scheduling state, retrieves
						job result etc...
					</para>
				</listitem>

				<listitem>
					<para>
						<emphasis role="bold">The Core</emphasis>
						which is the main entity of the Scheduler. It is
						in charge of scheduling Jobs according with the
						policy (which is FIFO by default), retrieve
						scheduling events to the user and make storages.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Users cannot interact directly with the Scheduler Core
				and must use the Front-end gateway.
			</para>

			<figure xml:id="schedulerEntity"><info><title>The Scheduler Entity</title></info>
				

				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%"  align="center" fileref="scheduler/pics/core/schedulerEntity.jpg" format="JPG"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>
	</section>

	<section xml:id="scheduler_use"><info><title>Using the ProActive Scheduler</title></info>
		
		<section xml:id="define_executable"><info><title>Define your own executable</title></info>
			
			<para>
				First of all, you must know that you can create your own
				task by implementing scheduler executable interfaces. It
				is possible to implement two types of executables :
			</para>
			<itemizedlist>
				<listitem>
					<para>
						<emphasis role="bold">JavaExecutable</emphasis>
						: to make your own java executable process.
						Here's an example of implementation for this
						type :
					</para>
					<programlisting xml:lang="java">
		public class WaitAndPrint extends JavaExecutable {

			@Override
			public Object execute(TaskResult... results) throws Throwable {
				String message;

				try {
					System.err.println("DÃ©marrage de la tache WaitAndPrint");
					System.out.println("Parameters are : ");

					for (TaskResult tRes : results) {
						if (tRes.hadException()) {
							System.out.println("\t " + tRes.getTaskId() + " : " + tRes.getException().getMessage());
						} else {
							System.out.println("\t " + tRes.getTaskId() + ": " + tRes.value());
						}
					}

					message = URIBuilder.getLocalAddress().toString();
					Thread.sleep(10000);

				} catch (Exception e) {
					message = "crashed";
					e.printStackTrace();
				}

				System.out.println("Terminaison de la tache");

				return (message + "\t slept for 10 sec");
			}
		}
					</programlisting>
					<para>
						This task will print an initial message, then
						check if there are results from previous tasks
						and if so, print the value of these
						"parameters". It will then return a message
						containing what the task did. The return value
						will be store in the job result.
					</para>
					<para>
						It is also possible to get a list of arguments
						that you can give to the task at its start by
						overriding the init method on a java task. How
						to give arguments will be explain further in
						task creation section (
						<xref linkend="task_creation"/>
						). We get back the foo, bar and test arguments
						to illustrate the task creation example below.
						<programlisting xml:lang="java">
							private boolean foo;
							private int bar;
							private String arg;

		@Override
		public void init(Map&lt;String, Object&gt; args) {
			foo = (Boolean)args.get("foo");
			bar = (Integer)args.get("bar");
			arg = (String)args.get("arg");
		}
						</programlisting>
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis role="bold">
							ProActiveExecutable
						</emphasis>
						: to make your own ProActive application
						process. Here's an example overview of
						implementation for this type :
					</para>

					<programlisting xml:lang="java">
		@Override
		public Object execute(ArrayList&lt;Node&gt; nodes) {
			System.out.println("ProActive job started !!");

			// create workers (on local node)
			Vector&lt;Worker&gt; workers = new Vector&lt;Worker&gt;();

			for (Node node : nodes) {
				try {
					Worker w = (Worker)PAActiveObject.newActive(Worker.class.getName(),
							new Object[] { }, node);
					workers.add(w);
				} catch (ActiveObjectCreationException e) {
					e.printStackTrace();
				} catch (NodeException e) {
					e.printStackTrace();
				}
			}

			// create controller Controller controller = new Controller(workers);
			int result = controller.findNthPrimeNumber(numberToFind);

			System.out.println("last prime : " + result);

			return result;
		}
					</programlisting>
					<para>
						As shown in a ProActive tutorial, this example
						uses the given nodes with the ProActive API in
						order to launch 'workers' on them. The
						<emphasis>execute(nodes)</emphasis>
						method shows what can be done inside this kind
						of task. For more details about how to use the
						ProActive API, see the appropriate
						documentation.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis role="bold">
							NativeExecutable
						</emphasis>
						: just use this class when you'd like to run a
						native process on the scheduler. You don't have
						to extend this class, just use it as shown in
						the next section.
					</para>
				</listitem>
			</itemizedlist>
		</section>

		<section xml:id="without_java_API"><info><title>Using XML descriptors</title></info>
			

			<section xml:id="start_scheduler_xml"><info><title>Starting the scheduler</title></info>
				
				<para>
					First of all, it's good to know that the scheduler have to be started with
					a database that will be used to save scheduling process in case of crash.
					It allows the scheduler to restart with a coherent state.
					To create a new database, you can use the "createDataBase.sh" script
					in the "script/unix/scheduler/" directory as shown in <xref linkend="start_scheduler_xml"/>:
					<itemizedlist>
						<listitem>
							<para>
								./createDataBase.sh scheduler_db.cfg : this will start the database using
								the configuration file provide in the same directory.
							</para>
						</listitem>
					</itemizedlist>
				</para>
				
				<para>
					Then, to start a local scheduler, run the
					<emphasis>scheduler.sh</emphasis>
					script in scripts/scheduler directory. Without
					arguments, the scheduler will start on the local
					host and will try to connect to a started local
					resources manager with the default database configuration file.
					If resources manager does not exist, it will create its own Resources Manager.
				</para>

				<para>
					<emphasis>scheduler.sh</emphasis>
					can be started with 3 optional arguments (use -h option to see 
					a description of the available options) :
					<itemizedlist>
						<listitem>
							<para>
								A path (directory) containing the 2
								authentication files (using the "-a
								PATH" option) :
								<itemizedlist>
									<listitem>
										<para>
											<emphasis>
												"login.cfg"
											</emphasis>
											: A file describing the
											users and their passwords
											authorized to connect to the
											scheduler.
										</para>
									</listitem>
									<listitem>
										<para>
											<emphasis>
												"group.cfg"
											</emphasis>
											: A file describing the
											group on which each user
											belongs. These groups will
											be used to identify admin or
											user rights.
										</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
						<listitem>
							<para>
								The URL of a resources manager already
								started (using the "-u URL" option).If
								you don't use this, it will try to
								connect to a started resource manager on
								local host.
							</para>
						</listitem>
						<listitem>
							<para>
								The configuration file for the database
								that have to be used (using "-c db_config_file.cfg" option).
								By default it will use a configuration file named
								"scheduler_db.cfg" at the current location. If this file does not 
								exist, you may have to set the "-c" option with your own file.
							</para>
						</listitem>
					</itemizedlist>
				</para>
				<para>
					For example, the following line will launch a
					scheduler with a local resource manager (if no one
					exists, it will create its own) and a personal path
					for the authentication files.
					It will not use the default "scheduler_db.cfg" configuration file
					but an other one as shown :
				</para>
				<itemizedlist>
					<listitem>
						<para>
							./scheduler.sh -a /user/home/scheduler/authFiles/ -c /user/home/scheduler/db.cfg
						</para>
					</listitem>
				</itemizedlist>
				<para>
					The path "/user/home/scheduler/authFiles/" have to
					contain the two authentication files.
				</para>
				<para>
					It is also possible to launch the scheduler with
					only one of the options or no option. For more
					informations, use -h (or --help) option (i.e.
					"scheduler.sh -h")
				</para>
			</section>

			<section xml:id="communicator"><info><title>The Scheduler Shell Communicator</title></info>
				
				<para>
					The shell communicator is a shell interface that
					allow a user to administer the scheduler without the
					java API. To start a communicator, run the
					<emphasis>communicator.sh</emphasis>
					script in scripts/scheduler directory. Without
					arguments, the communicator will try to connect a
					scheduler on the local host, exceptions from the scheduler won't
					be displayed and your login and password will be
					requested. Note that the communicator uses
					administrator rights to allow the connection to the
					scheduler.
				</para>
				<para>
					<emphasis>communicator.sh</emphasis>
					can be started with 3 optional arguments :
				</para>
				<itemizedlist>
					<listitem>
						<para>
							Your login (using the "-l LOGIN" option). If
							you use this option, your password only will
							be requested.
						</para>
					</listitem>
					<listitem>
						<para>
							If you use the "-e" option, all exceptions coming from the scheduler
							will be displayed, otherwise exceptions won't be displayed.
							Default use won't display exception.
						</para>
					</listitem>
					<listitem>
						<para>
							The URL of a started scheduler. (using the
							"-u URL" option)
							Default use try to connect a local scheduler.
						</para>
					</listitem>
				</itemizedlist>


				<para>
					Here's an overview of the shell communicator :
				</para>
				<figure xml:id="communicator_shell"><info><title>The shell communicator</title></info>
					

					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  align="center" fileref="scheduler/pics/core/communicator.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>

				<para>
					It is also possible to launch the communicator with
					only one of the options or no option. For more
					informations, use -h (or --help) option (i.e.
					"communicator.sh -h")
				</para>
			</section>

			<section xml:id="Create_a_job_xml"><info><title>Create a job</title></info>
				

				<para>
					A job can be created using an XML descriptor. You
					may have to create your own executable as describe
					in the section
					<xref linkend="define_executable"/>
					in order to run your own task. Next step if you
					don't want to use the scheduler java API is to write
					the descriptor of your job. This last could be
					launch using the
					<emphasis>jobLauncher.sh</emphasis>
					script. This script has 1 mandatory option and 3
					more optionnal :
					<itemizedlist>
						<listitem>
							<para>
								The path to the job file descriptor is
								mandatory (using the "-j PATH" option)
							</para>
						</listitem>
						<listitem>
							<para>
								The URL of a started scheduler. (using
								the "-u URL" option)
							</para>
						</listitem>
						<listitem>
							<para>
								Your login (using the "-l LOGIN"
								option). If you use this option, only
								your password will be requested.
								Otherwise, both will be.
							</para>
						</listitem>
						<listitem>
							<para>
								The number of job to submit, by default
								only 1 will be submitted (using the "-n
								A_NUMBER" option)
							</para>
						</listitem>
					</itemizedlist>
				</para>


				<para>
					For example :
					<emphasis>
						./jobLauncher.sh -j
						../../../descriptors/scheduler/jobs/Job_with_dep.xml
						-l login -n 12 -u //localhost/
					</emphasis>
					will submit 12 times the Job_with_dep job to a local
					scheduler and only your password will be required.
				</para>
				<para>
					For more informations, use -h (or --help) option
					(i.e. "jobLauncher.sh -h")
				</para>
				<para>
					Let's see how to create a job using the XML
					description.
				</para>


				<para>
					This conclude the job creation using XML descriptor.
					Let's see now how to create tasks and jobs using the
					java API.
				</para>
			</section>

		</section>

		<section xml:id="with_java_API"><info><title>Using the java API</title></info>
			

			<section xml:id="start_scheduler_API"><info><title>Starting the scheduler</title></info>
				
				<para>
					First thing to do is start the scheduler database.
					If you don't know how to do that, plz read first part of 
					this section : <xref linkend="start_scheduler_xml"/>.
				</para>
				
				<para>
					You can start the scheduler using the java API.
					Supposing that a Resource Manager is already started
					(see Resource Manager documentation
					<xref linkend="Resource_Manager"/>
					), this can be done in the following way:
				</para>

				<programlisting xml:lang="java">
					AdminScheduler.createScheduler(
					"path/to/db_configuration_file.cfg",
					"path/to/authentication_files/", rm,
					"org.objectweb.proactive.extensions.scheduler.policy.PriorityPolicy");
				</programlisting>

				<para>Arguments are respectively:</para>
				<orderedlist>
				
					<listitem>
						<para>
							<emphasis>Database configuration file</emphasis>
							: A file that describe the started database including
							the username and password, the path where it is located,
							the name of the database and the driver used.
						</para>
					</listitem>
					
					<listitem>
						<para>
							<emphasis>
								Authentication files path
							</emphasis>
							: A path containing the 2 needed files :
						</para>
						<itemizedlist>
							<listitem>
								<para>
									<emphasis>"login.cfg"</emphasis>
									: A file describing the users and
									their passwords authorized to
									connect to the scheduler.
								</para>
							</listitem>
							<listitem>
								<para>
									<emphasis>"group.cfg"</emphasis>
									: A file describing the group on
									which each user belongs. These
									groups will be used to identify
									admin or user rights.
								</para>
							</listitem>
						</itemizedlist>
						<para>
							These 2 files are used to manage the
							security and right access into the
							scheduler. A user can then only connect it
							if their username is in the login file and
							will check that the password is
							corresponding.
						</para>
					</listitem>

					<listitem>
						<para>
							<emphasis>rm</emphasis>
							: A reference on an already started
							Resources Manager instance.
						</para>
					</listitem>

					<listitem>
						<para>
							<emphasis>policyFullClassName</emphasis>
							: The scheduling policy to use, as a string
							representing the complete name of the class.
						</para>
					</listitem>
				</orderedlist>

				<para>
					<emphasis role="bold">NOTE</emphasis>
					- A LDAP authentication module for the Scheduler
					will be released in ProActive 4.0.
				</para>

				<para>
					Another way is to start the scheduler AND connect an
					administrator at the same time :
				</para>

				<programlisting xml:lang="java">
					AdminScheduler.createScheduler(
					"path/to/db_configuration_file.cfg",
					"path/to/authentication_files/", "login",
					"password", rm,
					"org.objectweb.proactive.extensions.scheduler.policy.PriorityPolicy");
				</programlisting>

				<para>
					Where arguments are the same plus a
					<emphasis>login</emphasis>
					and a
					<emphasis>password</emphasis>
					as a string. The user must be in the login file and
					his group must be admin in the group file.
				</para>
			</section>

			<section xml:id="how_to_make_job"><info><title>Job Creation</title></info>
				
				<section xml:id="task_creation"><info><title>Create task(s)</title></info>
					

					<para>
						As it has been said, it is possible to create 3
						types of tasks. These 3 types have some common
						features like name, description, scripts, etc...
						Here's the details of each of these common
						features :
					</para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>name</emphasis>
								is the name assigned to the task. It can
								be whatever you want as a String. This
								name must be unique for each task.
							</para>
							<programlisting xml:lang="java">
								aTask.setName("task 1");
							</programlisting>
						</listitem>
						<listitem>
							<para>
								<emphasis>description</emphasis>
								is a human readable description of the
								task. It is for human use only. This
								field is optional but it is better to
								set it.
							</para>
							<programlisting xml:lang="java">
								aTask.setDescription("This task will do
								something...");
							</programlisting>
						</listitem>
						<listitem>
								<para>
									<emphasis>generic informations</emphasis>
									is a way to define some informations inside your task.
									This informations could be read inside the policy. It can be useful
									to add new complex scheduling behavior.
								</para>
								<programlisting xml:lang="java">
									aTask.addGenericInformation("key","value");
								</programlisting>
							</listitem>
						<listitem>
							<para>
								<emphasis>precious result</emphasis>
								is the way to define that a result of a
								task is important or not. For example,
								in a job result, you could have to
								retrieve only some task results that are
								important for you. By setting the
								precious result to true you'll be able
								to retrieve easily these results.
								(default is false)
							</para>
							<programlisting xml:lang="java">
								aTask.setPreciousResult(true);
							</programlisting>
						</listitem>
						<listitem>
							<para>
								<emphasis>re-runnable</emphasis>
								is a way to define how many times a task
								will be reran if an user or network
								problems occur. Set this value to
								<emphasis>n</emphasis>
								if you want the task to be restarted
								<emphasis>n</emphasis>
								times and so, started a maximum of
								<emphasis>n+1</emphasis>
								times. (default is 1)
							</para>
							<programlisting xml:lang="java">
								aTask.setRerunnable(2);
							</programlisting>
						</listitem>
						<listitem>
							<para>
								<emphasis>restartOnError</emphasis>
								is an option that define if a task has to be restarted if
								an error occurred. Error can be both exception for java task
								or error code (1-255) for native task.
								If not defined, the task will never restart. This option can be set to
								<emphasis>anywhere</emphasis> that means the task will restart on the 
								first available node. It can also be set to <emphasis>anywhere</emphasis>
								meaning that the task will restart on a different node that the last one used.
								In these 2 last cases, The job will be failed if the maximum number of retries
								(<emphasis>re-runnable</emphasis> option) is reached.
								(This option is not available for proActive Task)
							</para>
							<programlisting xml:lang="java">
								aTask.setRestartOnError(RestartMode.ELSEWHERE);
							</programlisting>
						</listitem>
						<listitem>
							<para>
								<emphasis>result preview</emphasis>
								allows to specify how the result of a
								task should be displayed in the
								Scheduler graphical client. The user
								should implement a result preview class
								(that extends
								<literal>
									org.objectweb.proactive.extensions.scheduler.common.task.ResultPreview
								</literal>
								abstract class) which specifies result
								rendrering in two different manners :
							</para>
							<itemizedlist>
								<listitem>
									<para>
										a textual manner, by implementing
										<literal>
											public abstract String getTextualDescription(TaskResult result);
										</literal>
										. This method, similarily to
										<literal>
											String Object.toString()
										</literal>
										should return a <literal>String</literal>
										object that describes the result;
									</para>
								</listitem>
								<listitem>
									<para>
										a graphical manner, by implementing
										<literal>
											public abstract JPanel getGraphicalDescription(TaskResult result);
										</literal>
										. This method should return a Swing
										<literal>JPanel</literal>
										object that describes the result.
									</para>
								</listitem>
							</itemizedlist>
							<para>
								Some useful methods to create a specific
								preview class can be found in
								<literal>
									org.objectweb.proactive.extensions.scheduler.common.task.util.ResultPreviewTool
								</literal>
								, such as automatic display of an image
								file, or automatic translation between
								windows and unix path.
							</para>
							<programlisting xml:lang="java">
								aTask.setResultPreview(UserDefinedResultPreview.class);
							</programlisting>
						</listitem>
						<listitem>
							<para>
								<emphasis>scripts</emphasis>
								The ProActive scheduler supports
								portable scripts execution through the
								JSR 223 Java Scripting capabilities;
								scripts can be written in any language
								supported by the underlying Java Runtime
								Environment. Scripts are used in the
								ProActive scheduler to :
							</para>
							<itemizedlist>
								<listitem>
									<para>
										Execute some simple pre and post
										processings: optional pre-script
										and post-script
									</para>
								</listitem>
								<listitem>
									<para>
										Select among available resources
										the node that suitable for the
										execution: optional
										selection-script can be
										associated to a task.
									</para>
								</listitem>
								<listitem>
									<para>
										Dynamic building of a command
										line for a native task: optional
										generation-script (detailled in
										next section).
									</para>
								</listitem>
							</itemizedlist>
							<para>
								Here are some details and examples:
							</para>
							<itemizedlist>
								<listitem>
									<para>
										<emphasis>pre-script</emphasis>
										The pre-script is always
										executed on the node that has
										been selected by the resource
										manager
										<emphasis>before</emphasis>
										the execution of the task
										itself.
									</para>
									<programlisting xml:lang="java">
		//If the script to use is in a file or URL
		String[] args = new String("foo","bar");
		File scriptFile = new File("path/to/script_file");
		//URL scriptURL = new URL("url/to/script_file");
		Script script = new SimpleScript(scriptFile, args);
		// Script script = new SimpleScript(scriptURL, args);
		aTask.setPreScript(script);
		//If the script to use is in a java string for example
		Script script = new SimpleScript("Script_content", "type_of_language");
		//where type_of_language can be any language supported by the underlying JRE
		aTask.setPreScript(script);
									</programlisting>
								</listitem>
								<listitem>
									<para>
										<emphasis>post-script</emphasis>
										The pre-script is always
										executed on the node that has
										been selected by the resource
										manager
										<emphasis>after</emphasis>
										the execution of the task
										itself.
									</para>
									<programlisting xml:lang="java">
		//same construction for the script
		aTask.setPostScript(script);
									</programlisting>
								</listitem>
								<listitem>
									<para>
										<emphasis>
											selection script
										</emphasis>
										The selection script is always
										executed before the task itself
										on any candidate node: the
										execution of a selection script
										must set the boolean variable
										<literal>selected</literal>
										, that indicates if the
										candidate node is suitable for
										the execution of the associated
										task.
									</para>
									<programlisting xml:lang="java">
		//same construction for the script
		//the last parameter is still not used in the current implementation
		SelectionScript selScript = new SelectionScript(script, true);
		aTask.setSelectionScript(selScript);
									</programlisting>
								</listitem>
							</itemizedlist>
						</listitem>
					</itemizedlist>

					<para>
						The following explains how to create a specific
						kind of task :
					</para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>
									Create a native task
								</emphasis>
								is the simplest thing to do. Use the
								<emphasis>NativeTask</emphasis>
								class to create such a task. You just
								have then to specify a command line that
								have to be executed by the scheduler.
								Here's an example that describe how to
								create a native task with a
								<emphasis>static command</emphasis>
								:
							</para>
							<programlisting xml:lang="java">
		//create a new native task
		NativeTask task1 = new NativeTask();
		//set the command to execute as a string
		task1.setCommandLine("ls -al");
							</programlisting>
							<para>
								Here's an example that describe how to
								create a native task with a
								<emphasis>dynamic command</emphasis>
								, i.e. generated by a script called a
								generation script, The generation script
								can only be associated to a
								<emphasis>native</emphasis>
								task: the execution of a selection
								script must set the string variable
								<literal>command</literal>
								. The value of this variable is the
								command line that will be executed by
								the Scheduler as task execution.
							</para>
							<programlisting xml:lang="java">
		//create a new native task
		NativeTask task2 = new NativeTask();
		//create a generation script with a script as shown above
		GenerationScript gscript = new GenerationScript(script);
		//set the command to execute as a string
		task2.setGenerationScript(gscript);
							</programlisting>
						</listitem>
						<listitem>
							<para>
								<emphasis>Create a java task</emphasis>
								is not much more difficult. Use the
								<emphasis>JavaTask</emphasis>
								class to create this type of task. In
								this type, you must specify the class
								you want to start with, by mentioning a
								Class or an instance of your executable.
								(To make your own executable see the
								proper section
								<xref linkend="define_executable"/>
								). In addition, you can add arguments
								with which the task will be launched.
								These launching arguments will be given
								to the java executable as a Map.
							</para>
							<programlisting xml:lang="java">
		//create a new java task
		JavaTask task3 = new JavaTask();
		//add arguments (optional)
		task3.addArgument("foo",new Boolean(true));
		task3.addArgument("bar",new Integer(12));
		task3.addArgument("test","test1");
		//add executable class or instance
		task3.setTaskClass(WaitAndPrint.class);
		//or
		//task3.setTaskInstance(new WaitAndPrint());
							</programlisting>
						</listitem>
					</itemizedlist>
					<para>
						For both native and java task, you can specify
						dependences between each other
						<emphasis role="bold">
							(but not for ProActive task)
						</emphasis>
						. To perform such a thing, and following the
						example shown in the dependencies explanation (
						<xref linkend="how_dependences"/>
						), let's see an example illustrating how to make
						task 5 depends of 2 and 3 in this order :
					</para>
					<programlisting xml:lang="java">
		//task 2 has been create just before as a native
		task
		//task 3 has been create just before as a
		java task
		//we have to create task 5.
		//create a new native or java task
		JavaTask task5 = new JavaTask();
		//... (fill task5 as describe above)
		//then specify dependencies by using the addDependence(Task) method
		task5.addDependence(task2);
		task5.addDependence(task3);
		//or use the addDependences(list&lt;Task&gt;) method as shown
		//task5.addDependences(new ArrayList&lt;Task&gt;(task2,task3));
					</programlisting>

					<itemizedlist>
						<listitem>
							<para>
								<emphasis>
									Create a ProActive task
								</emphasis>
								is a bit different. Indeed, it is not
								possible to add dependences to this
								task. This task is design for the
								ProActive job. Like the java task,
								arguments can be set in order to be used
								at the start of the task. The
								corresponding executable is attach to
								the task using the same methods as java
								task. Finally, you must specify the
								number of needed nodes for the ProActive
								task. This is the list of nodes you will
								receive in the
								<emphasis>execute(nodeList)</emphasis>
								method in the ProActive executable. See
								<xref linkend="define_executable"/>
								to make your own ProActive executable.
							</para>
							<programlisting xml:lang="java">
		//create the ProActive task
		ProActiveTask aPATask = new ProActiveTask();
		//add dependencies... (see java task)
		//add task instance or class... (see java task)
		//set number of needed nodes
		aPATask.setNumberOfNodesNeeded(8);
							</programlisting>
							<para>
								In this example, 8 needed nodes means
								that you want to use 7 nodes in your
								executable. Indeed, one node will be
								used to start your executable, and the
								other are given to your application.
							</para>
						</listitem>
					</itemizedlist>
					<para>
						Now that you know how to define tasks, let's see
						how to make your job.
					</para>
				</section>

				<section xml:id="job_creation"><info><title>Create Job</title></info>
					

					<para>
						It is possible to create two types of job. As it
						was the case for the tasks, jobs have some
						common features :
						<itemizedlist>
							<listitem>
								<para>
									<emphasis>id</emphasis>
									is a way to identify your job, you
									cannot set it but the scheduler will
									send you back the id associated to
									your job as soon as it is submit. It
									will permit you to ask for services
									about your job.
								</para>
							</listitem>
							<listitem>
								<para>
									<emphasis>description</emphasis>
									is a human readable description of
									the job. It is for human use only.
									This field is optional but it is
									better to set it.
								</para>
								<programlisting xml:lang="java">
									aJob.setDescription("This job will
									do something...");
								</programlisting>
							</listitem>
							<listitem>
								<para>
									<emphasis>generic informations</emphasis>
									is a way to define some informations inside your job.
									This informations could be read inside the policy. It can be useful
									to add new complex scheduling behavior.
								</para>
								<programlisting xml:lang="java">
									aJob.addGenericInformation("key","value");
								</programlisting>
							</listitem>
							<listitem>
								<para>
									<emphasis>project name</emphasis>
									can be define in your job. This information also goes to the policy
									in order to group different job by project name for example.
								</para>
								<programlisting xml:lang="java">
									aJob.setProjectName("my_project");
								</programlisting>
							</listitem>
							<listitem>
								<para>
									<emphasis>name</emphasis>
									is the name of your job as a string.
								</para>
								<programlisting xml:lang="java">
									aJob.setName("a name");
								</programlisting>
							</listitem>
							<listitem>
								<para>
									<emphasis>Log file</emphasis>
									is the path of an optional log file.
									Set it if you want to save the job
									generated log in a file.
								</para>
								<programlisting xml:lang="java">
									aJob.setLogFile("path/to/log_file");
								</programlisting>
							</listitem>
							<listitem>
								<para>
									<emphasis>priority</emphasis>
									is the scheduling priority level for
									your job.
								</para>
								<programlisting xml:lang="java">
									aJob.setPriority(JobPriority.NORMAL);
								</programlisting>
							</listitem>
							<listitem>
								<para>
									<emphasis>Cancel on Error</emphasis>
									is a way to define if your job will
									continue if a user exception or
									error occurs during the whole job
									process. It means that if the value
									of this property is true, the job
									will stop immediately every running
									task if one error occurs in one of
									the task of this job. It will have
									the consequence to failed the job,
									but free resources for other jobs.
									It is useful when it has no interest
									to continue after a task failure.
								</para>
								<programlisting xml:lang="java">
									aJob.setCancelOnError(true);
								</programlisting>
									Combined with the task <emphasis>restartOnError</emphasis> option
									it can be useful to know the behavior of your job.
									Here's a table that explains can be done with tasks and job :
									<figure xml:id="cancel_restart"><info><title>CancelOnError and RestartOnError behavior</title></info>
										<mediaobject>
											<imageobject>
												<imagedata scalefit="1" width="100%" contentdepth="100%"  align="center" fileref="scheduler/pics/core/cancel-restart.png" format="PNG"/>
											</imageobject>
										</mediaobject>
									</figure>
							</listitem>
						</itemizedlist>
					</para>
					<para>
						Let's see in details how to build the different job :
					</para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>The TaskFlowJob</emphasis>
								or data flow job is a job that can
								contain one or more task(s) with the
								dependencies you want. To make this type
								of job, just use the default no arg
								constructor, and set the properties you
								want to set. Then add tasks with the
								given method addTask(Task) in order to
								fill the job with your own tasks. Here's
								the step to create your task flow job :
							</para>
							<programlisting xml:lang="java">
		//your tasks has already been created as seen in previous sections
		//create a task flow job
		TaskFlowJob job = new TaskFlowJob();
		//fill the job...
		job.setName("task flow job 1");
		job.setPriority(JobPriority.NORMAL);
		//...
		//add your tasks (java or native task created in the previous sections)
		job.addTask(task1);
		job.addTasks(new ArrayList&lt;Task&gt;(task2,task3,task5));
		//that's it.
							</programlisting>
							<para>
								You may now be able to create a task
								flow job that can contains native or
								java tasks. See
								<xref linkend="Job_submission"/>
								to learn how to submit a job to the
								scheduler.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>The ProActiveJob</emphasis>
								is a job that contains one task that has
								a list of nodes in its argument list. To
								make this type of job, just use the
								default no argument constructor, and set
								the properties you want to set. In this
								job, you must set the only ProActive
								task that will be inside this job.
							</para>
							<programlisting xml:lang="java">
		//your ProActive task has already been
		created in previous section
		//create a ProActive job
		ProActiveJob job = new ProActiveJob();
		//fill the job...
		job.setName("ProActive job 1");
		job.setPriority(JobPriority.LOW);
		//...
		//add the task (ProActive task created in the previous section)
		job.addTask(aPATask);
							</programlisting>
							<para>
								Here's your first ProActive job. See
								<xref linkend="Job_submission"/>
								to learn how to submit a job to the
								scheduler.
							</para>
						</listitem>
					</itemizedlist>
				</section>
			</section>

			<section xml:id="user_interface"><info><title>User Interface</title></info>
				

				<section xml:id="User_Connection"><info><title>User Connection</title></info>
					

					<para>
						A user can connect to the Scheduler only if
						he/she is known. That's the goal of the
						authentication interface which is able to
						authenticate users.
						<xref linkend="userConnection"/>
						shows how the Scheduler connects a user.
						<figure xml:id="userConnection"><info><title>A user connection</title></info>
							

							<mediaobject>
								<imageobject>
									<imagedata scalefit="1" width="100%" contentdepth="100%"  align="center" fileref="scheduler/pics/core/userConnection.jpg" format="JPG"/>
								</imageobject>
							</mediaobject>
						</figure>
						<orderedlist>
							<listitem>
								<para>
									First of all, a user tries to join
									the authentication interface using
									the
									<emphasis role="bold">
										SchedulerConnection.join(...)
									</emphasis>
									static method.
								</para>

								<programlisting xml:lang="java">
		SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/SCHEDULER_OBJECT_NAME");
								</programlisting>

								<para>
									Then, with the
									<emphasis role="bold">
										SchedulerAuthenticationInterface
									</emphasis>
									, users can be connected as user or
									administrator roles using the
									<emphasis role="bold">
										logAsUser
									</emphasis>
									or
									<emphasis role="bold">
										logAsAdmin
									</emphasis>
									methods.
								</para>

								<programlisting xml:lang="java">
		UserSchedulerInterface scheduler = auth.logAsUser("username", "password");
		// OR AdminSchedulerInterface scheduler = auth.logAsAdmin("adminname", "password");
								</programlisting>
							</listitem>

							<listitem>
								<para>
									Next, the authentication object
									checks the users rights and wether
									the user is authorized to connect
									the scheduler. If not, an exception
									will be thrown.
								</para>
							</listitem>

							<listitem>
								<para>
									Once connected, the authentication
									object sends the right and
									username/password to the scheduler
									front-end which will be able to
									authenticate user on its own.
								</para>
							</listitem>

							<listitem>
								<para>
									If nothing goes wrong, the
									authentication interface will return
									a
									<emphasis role="bold">
										AdminSchedulerInterface
									</emphasis>
									which is in fact a direct link to
									the
									<emphasis role="bold">
										Front-end
									</emphasis>
									.
								</para>
							</listitem>

							<listitem>
								<para>
									The user is now able to interact
									with the Scheduler using the
									returned interface.
								</para>
							</listitem>
						</orderedlist>
					</para>
				</section>

				<section xml:id="Job_submission"><info><title>Job Submission</title></info>
					

					<para>
						After the connection, a user is ready to submit
						Jobs. The
						<emphasis role="bold">
							Authentication interface is no longer used
						</emphasis>
						for this connected user.
						<xref linkend="jobSubmission"/>
						shows what happens when the Scheduler received a
						new Job to schedule.
						<figure xml:id="jobSubmission"><info><title>A job submission</title></info>
							

							<mediaobject>
								<imageobject>
									<imagedata scalefit="1" width="100%" contentdepth="100%"  align="center" fileref="scheduler/pics/core/jobSubmission.jpg" format="JPG"/>
								</imageobject>
							</mediaobject>
						</figure>
						<orderedlist>
							<listitem>
								<para>
									First, the user submits a Job using
									his
									<emphasis role="bold">
										UserSchedulerInterface
									</emphasis>
									retrieved by the
									<emphasis role="bold">
										logAsUser
									</emphasis>
									method.
									<programlisting xml:lang="java">
		// connecting to the scheduler
		SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/SCHEDULER_OBJECT_NAME");
		// checking username and password
		UserSchedulerInterface
		scheduler = auth.logAsUser("username", "password");
		// submitting a new job and get the associated id
		JobId myJobId = scheduler.submit(job);
									</programlisting>
								</para>
							</listitem>

							<listitem>
								<para>
									The Scheduler Front-end verifies the
									integrity of the Job, and builds it
									in order to be ready to be managed
									by the Scheduler Core. If there is a
									problem, an exception is thrown
									explaining what is the cause.
								</para>
							</listitem>

							<listitem>
								<para>
									Finally, the Job is transmitted to
									the Core for scheduling.
								</para>
							</listitem>
						</orderedlist>
					</para>

					<para>
						To submit a job using a command line, use the
						<emphasis role="bold">jobLauncher.sh</emphasis>
						script in the script/[os]/scheduler directory.
						This script has 1 mandatory option and 3 more
						optionnal :
						<itemizedlist>
							<listitem>
								<para>
									The path to the job file descriptor
									is mandatory (using the "-j PATH"
									option)
								</para>
							</listitem>
							<listitem>
								<para>
									The URL of a started scheduler
									(using the "-u URL" option). If you
									don't use this, it will trying to
									connect to a started scheduler on
									local host.
								</para>
							</listitem>
							<listitem>
								<para>
									Your login (using the "-l LOGIN"
									option). If you use this option,
									only your password will be
									requested. Otherwise, both will be
								</para>
							</listitem>
							<listitem>
								<para>
									The number of job to submit, by
									default only 1 will be submitted
									(using the "-n A_NUMBER" option)
								</para>
							</listitem>
						</itemizedlist>
					</para>

					<para>
						For example :
						<emphasis>
							./jobLauncher.sh -j
							../../../descriptors/scheduler/jobs/Job_with_dep.xml
							-l login -n 12 -u //localhost/
						</emphasis>
						will submit 12 times the Job_with_dep job to a
						local scheduler and only your password will be
						required.
					</para>
					<para>
						For more informations, use -h (or --help) option
						(i.e. "jobLauncher.sh -h")
					</para>

				</section>

				<section xml:id="get_job_result"><info><title>Getting the result of a job</title></info>
					

					<para>
						You may have to retrieve the result of a job. It
						is possible by using the
						<emphasis role="bold">
							getJobResult(JobId)
						</emphasis>
						method in the
						<emphasis role="bold">
							UserSchedulerInterface
						</emphasis>
						. A job result is in fact a list of task result
						ordered in three lists :
					</para>
					<itemizedlist>
						<listitem>
							<para>
								A failed list that contains every result
								or exception returned by a task that
								failed.
							</para>
						</listitem>
						<listitem>
							<para>
								A full list that contains every result
								or exception of every tasks.
							</para>
						</listitem>
						<listitem>
							<para>
								And A precious result list that contains
								every result or exception returned by
								the task marked precious.
							</para>
						</listitem>
					</itemizedlist>
					<para>
						This result will be given to you exactly like
						you returned it in your executable. You can only
						get the result of your job if you are a user and
						every job if your are an administrator. To know
						when a job that you have submitted has finished
						its execution, you can subscribe to the
						scheduler to be notified of some events. This
						will be explain in the next section.
					</para>
					<programlisting xml:lang="java">
	// get the user interface
	UserSchedulerInterface scheduler = auth.logAsUser("username", "password");
	JobResult myResult = scheduler.getJobResult(myJobId);
					</programlisting>
					<para>
						To get the result of a job using a command line,
						use the
						<emphasis role="bold">getResult.sh</emphasis>
						script in the script/[os]/scheduler directory.
						This script has 2 optional options :
						<itemizedlist>
							<listitem>
								<para>
									The URL of a started scheduler.
									(using the "-u URL" option). If you
									don't use this, it will trying to
									connect to a started scheduler on
									local host.
								</para>
							</listitem>
							<listitem>
								<para>
									Your login (using the "-l LOGIN"
									option). If you use this option,
									only your password will be
									requested. Otherwise, both will be
								</para>
							</listitem>
						</itemizedlist>
					</para>
					<para>
						It will print the result on the screen as the
						toString() java method could have done it.
					</para>

					<para>
						For more informations, use -h (or --help) option
						(i.e. "jobLauncher.sh -h")
					</para>
				</section>

				<section xml:id="add_listener"><info><title>
						Get a listener on the scheduler activity
					</title></info>
					

					<para>
						In order to be notified about the scheduler
						activities, you can add a scheduler listener
						that will inform you of some events, like job
						submitting, job or task finished, scheduling
						state changing, etc... To add a listener, just
						make your listener by implementing the
						<emphasis>SchedulerEventListener</emphasis>
						interface and add it to the scheduler. You will
						then receive the scheduler initial state
						containing some informations about the current
						scheduling. See the javadoc for more details.
					</para>
					<programlisting xml:lang="java">
	//make your listener
	SchedulerEventListener mySchedulerEventListener = new chedulerEventListener () {
		public void jobRunningToFinishedEvent(JobEvent event){
			//if my job is finished
			if (event.getJobId().equals(myJobId)){
				//get its result
				JobResult myResult = scheduler.getJobResult(myJobId);
			}
		}
		//Implement other methods...
	}
	//add the listener to the scheduler
						scheduler.addSchedulerEventListener(MySchedulerEventListener,SchedulerEvent.JOB_RUNNING_TO_FINISHED);
					</programlisting>
					<para>
						This example shows you how to listen to the
						scheduler events (here the finished job event
						only). But you can listen for every events you
						want containing in this interface.
					</para>
					<para>
						For more details and features on the user
						scheduler interface, please refer to the java
						Documentation.
					</para>

				</section>

			</section>

			<section xml:id="admin_interface"><info><title>Administrator Interface</title></info>
				

				<para>
					The administrator can do more with its interface,
					see the javadoc for more details and features. He
					can also change the policy during the scheduling,
					that will consequently change the remaining
					scheduling order. Refer to the
					<xref linkend="add_policy"/>
					section to make your own policy and change it as
					shown below :
				</para>
				<programlisting xml:lang="java">
					//scheduler is the AdminSchedulerInterface returned
					in the previous sections
					scheduler.changePolicy(full.name.of.MyPolicy);
				</programlisting>
			</section>
		</section>


	</section>

	<section xml:id="scheduler_extension"><info><title>Extend the Scheduler</title></info>
		

		<section xml:id="add_policy"><info><title>How to add a new policy</title></info>
			

			<para>
				Create and add a new scheduling policy remains a very
				simple work. You just have to implements the
				<emphasis>
					org.objectweb.proactive.extensions.scheduler.policy.PolicyInterface
				</emphasis>
				and start a new Scheduler with this new policy, or
				dynamically change it if the scheduler is already
				running.
			</para>

			<para>
				Here's the interface which must be implemented. The
				default implementation
				<emphasis>PriorityPolicy</emphasis>
				in the same package:
			</para>

			<programlisting xml:lang="java">
	public interface PolicyInterface extends Serializable {
		//Resource Manager state field.
		public RMState RMState = null;
		//method to implement
		Vector&lt;EligibleTaskDescriptor&gt; getOrderedTasks(List&lt;JobDescriptor&gt; jobs);
	}
			</programlisting>

			<para>
				This method returns all the Tasks that have to be
				scheduled. The Tasks must be in the desired scheduling
				order. The first task to be scheduled will be the first
				in the returned Vector.
			</para>

			<para>
				The parameters is a list of running and pendingJobs,
				which contain Tasks to be scheduled. Some properties in each jobs and tasks
				can be accessed in order to make your own scheduling order. It is also possible
				to access to the "RMState" field that allow you to have informations about resources like
				nodes used, total nodes number, etc. The only thing to do is
				<emphasis>extract the task</emphasis>
				,
				<emphasis>re-order them</emphasis>
				and
				<emphasis>put them in a vector</emphasis>
				. Let's see the default implementation of the ProActive
				Scheduler policy to illustrate it:
			</para>

			<programlisting xml:lang="java">
	public class PriorityPolicy implements PolicyInterface {
		/**
		 * This method return the tasks using FIFO policy according to the jobs priorities.
		 *
		 * @see org.objectweb.proactive.extensions.scheduler.policy.PolicyInterface#getReadyTasks(java.util.List)
		 */
		@Override
		public Vector&lt;EligibleTaskDescriptor&gt; getOrderedTasks( List&lt;JobDescriptor&gt; jobs) {
			Vector&lt;EligibleTaskDescriptor&gt; toReturn = new
			Vector&lt;EligibleTaskDescriptor&gt;();
			//sort jobs by
			priority Collections.sort(jobs);

			for (JobDescriptor lj : jobs) {
				toReturn.addAll(lj.getEligibleTasks());
			}
			return toReturn; 
		}
	}
			</programlisting>

			<para>
				By default, the Jobs knows how to be sorted regarding
				their priority. But it is simple to create a Comparator
				and sort the Jobs with it. It is also possible to have informations about 
				the resources using the protected<emphasis>RMState</emphasis> field inside the getOrderedTasks method.
			</para>
		</section>
	</section>



	<section xml:id="Scheduler_Eclipse_Plugin"><info><title>Scheduler Eclipse plugin</title></info>

		


		<para>
			<emphasis role="bold">
				The Scheduler Eclipse Plugin
			</emphasis>
			is a
			<emphasis role="bold">graphical client</emphasis>
			for remote monitoring and control of the ProActive Scheduler
			(see
			<xref linkend="ProActive_Scheduler"/>
			), including remote submission of XML-defined jobs (see
			<xref linkend="Create_a_job_xml"/>
			).
		</para>
		<para>
			The Scheduler Eclipse Plugin is available in two forms :
		</para>
		<itemizedlist>
			<listitem>
				<para>
					A
					<emphasis role="bold">
						Java stand alone application
					</emphasis>
					based on
					<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://wiki.eclipse.org/index.php/Rich_Client_Platform">
						Eclipse Rich Client Platform (RCP)
					</link>
					, available for any platform (Windows, Linux, Mac
					OSX, Solaris, ...)
				</para>
			</listitem>
			<listitem>
				<para>
					A set of
					<emphasis role="bold">
						<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.eclipse.org">
							Eclipse
						</link>
						plugins
					</emphasis>
					: with all the functionalities within the stand
					alone application, enhanced with a tool that makes
					easier the scheduling and monitoring of jobs and
					applications.
				</para>
			</listitem>
		</itemizedlist>

		<!-- ************************************************************************************ -->

		<section xml:id="Scheduler_Plugin"><info><title>The Scheduler perspective</title></info>
			

			<para>
				The Scheduler plugin provides the
				<emphasis role="bold">
					Scheduler
					<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://help.eclipse.org/help31/index.jsp?topic=/org.eclipse.platform.doc.user/gettingStarted/qs-43.htm">
						perspective
					</link>
				</emphasis>
				displayed in the
				<xref linkend="schedulerPerspective"/>
				.
			</para>

			<para>
				This perspective defines the following set of
				<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://wiki.eclipse.org/index.php/FAQ_What_is_a_view%3F">
					views
				</link>
				:
			</para>

			<itemizedlist>
				<listitem>
					<para>
						The
						<emphasis role="bold">Jobs</emphasis>
						view: shows pending, running and finished jobs
						in the scheduler.
					</para>
				</listitem>
				<listitem>
					<para>
						The
						<emphasis role="bold">Console</emphasis>
						view: shows jobs standard and error output (on
						demand).
					</para>
				</listitem>
				<listitem>
					<para>
						The
						<emphasis role="bold">Tasks</emphasis>
						view: displays detailled informations on tasks
						contained in the selected job.
					</para>
				</listitem>
				<listitem>
					<para>
						The
						<emphasis role="bold">Jobs Info</emphasis>
						view: displays all informations of the selected
						job.
					</para>
				</listitem>
				<listitem>
					<para>
						The
						<emphasis role="bold">Result Preview</emphasis>
						view: displays a textual or graphical preview of
						the result of the selected task.
					</para>
				</listitem>
			</itemizedlist>

			<figure xml:id="schedulerPerspective"><info><title>The Scheduler Perspective</title></info>
				
				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/schedulerPerspective.png" format="PNG"/>
					</imageobject>
				</mediaobject>
			</figure>

		</section><!-- The Scheduler perspective -->

		<section><info><title>Views composing the perspective</title></info>
			

			<figure xml:id="jobsView"><info><title>The Jobs view</title></info>
				
				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/jobsView.png" format="PNG"/>
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				All buttons (on upper right) are describe in the
				<xref linkend="schedulerPerspectiveButtons"/>
			</para>
			<para>
				This view is composed of 3 tables which represents
				pending, running and finished jobs. In each table you
				can watch many different informations about jobs, as
				their state, their name, their id...
			</para>

			<figure xml:id="consoleView"><info><title>The Console view</title></info>
				
				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/consoleView.png" format="PNG"/>
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				This view displays all jobs standard and error output
				(only on demand).
			</para>

			<figure xml:id="tasksView"><info><title>The Tasks view</title></info>
				
				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/tasksView.png" format="PNG"/>
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				This view provides many informations on tasks composing
				a job as :
				<itemizedlist>
					<listitem>
						<para>The task id</para>
					</listitem>
					<listitem>
						<para>The task state</para>
					</listitem>
					<listitem>
						<para>The task name</para>
					</listitem>
					<listitem>
						<para>
							The host name which execute the task
						</para>
					</listitem>
					<listitem>
						<para>The task started time</para>
					</listitem>
					<listitem>
						<para>The task finished time</para>
					</listitem>
					<listitem>
						<para>
							In the column "Re-runnable", the first
							number represents how many times the task
							was re-executed, and the second number how
							many times the task can be re-executed
						</para>
					</listitem>
					<listitem>
						<para>The description of the task</para>
					</listitem>
				</itemizedlist>
			</para>

			<figure xml:id="jobInfoView"><info><title>The Job Info view</title></info>
				
				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/jobInfoView.png" format="PNG"/>
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				This view provides many informations on the selected job
				as :
				<itemizedlist>
					<listitem>
						<para>The job id</para>
					</listitem>
					<listitem>
						<para>The job state</para>
					</listitem>
					<listitem>
						<para>The job name</para>
					</listitem>
					<listitem>
						<para>The job priority</para>
					</listitem>
					<listitem>
						<para>The number of pending task</para>
					</listitem>
					<listitem>
						<para>The number of running task</para>
					</listitem>
					<listitem>
						<para>The number of finished task</para>
					</listitem>
					<listitem>
						<para>
							The number of task composing the job
						</para>
					</listitem>
					<listitem>
						<para>The job submitted time</para>
					</listitem>
					<listitem>
						<para>The job started time</para>
					</listitem>
					<listitem>
						<para>The job finished time</para>
					</listitem>
					<listitem>
						<para>The description of the job</para>
					</listitem>
				</itemizedlist>
			</para>

			<figure xml:id="resultPreviewView"><info><title>The Result Preview view</title></info>
				
				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/resultPreviewView.png" format="PNG"/>
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				This view display the result of the selected task (in
				task view), according to the ResultPreview field (see
				<xref linkend="task_creation"/>
			</para>
		</section>

		<section><info><title>Connect to the started ProActive Scheduler</title></info>

			

			<para>
				In order to establish a connection to the ProActive
				Scheduler:
			</para>

			<orderedlist>
				<listitem>
					<para>
						open the Scheduler Perspective:
						<emphasis role="bold">
							Window-&gt;Open
							Perspective-&gt;Other...-&gt;Scheduler
						</emphasis>
						(it could be already opened as it is the default
						perspective).
					</para>
				</listitem>
				<listitem>
					<para>
						select
						<emphasis role="bold">
							"Connect to the ProActive scheduler" in the
							Scheduler menu or in the contextual menu
							(right click)
						</emphasis>
						, it opens the "Connect to the ProActive
						scheduler" dialog displayed in the
						<xref linkend="connectToSchedulerDialog"/>
						.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis role="bold">
							enter informations required
						</emphasis>
						about the remote scheduler, and click
						<emphasis role="bold">OK</emphasis>
						.
					</para>
				</listitem>


			</orderedlist>
			<para>
				note: If you check "log as admin" in the previous
				dialogue, if the ProActive scheduler accepts your
				connection, you'll be able to do more actions than an
				"simple" user (see
				<xref linkend="admin_mode"/>
				).
			</para>


			<figure xml:id="connectToSchedulerDialog"><info><title>Connect to scheduler</title></info>
				
				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/connectToSchedulerDialog.png" format="PNG"/>
					</imageobject>
				</mediaobject>
			</figure>

		</section><!-- Connect to a started scheduler -->

		<section><info><title xml:id="schedulerPerspectiveButtons">
				The Scheduler perspective buttons
			</title></info>
			
			<section><info><title>The Jobs view buttons in User Mode</title></info>
				

				<figure xml:id="connectToSchedulerButton"><info><title>Connect to scheduler</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/connectToSchedulerButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					Display the "Connect to scheduler" dialog in order
					to establish a connection to a remote ProActive
					scheduler.
				</para>

				<figure xml:id="disconnectToSchedulerButton"><info><title>Disconnect from the scheduler</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/disconnectToSchedulerButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>

				<figure xml:id="changeViewVTHModeButton"><info><title>
						Change view from Vertical to Horizontal mode
					</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/changeViewVTHModeButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					Allows to switch the job's display to Horizontal
					from Vertical mode.
				</para>

				<figure xml:id="changeViewHTVModeButton"><info><title>
						Change view from Horizontal to Vertical mode
					</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/changeViewHTVModeButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					Allows to switch the job's display from Horizontal
					to Vertical mode.
				</para>

				<figure xml:id="submitJobButton"><info><title>Submit a job</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/submitJobButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					Display the "Choose file" dialog in order to submit
					a XML-defined job to the scheduler.
				</para>

				<figure xml:id="pauseResumeJobButton"><info><title>Pause/Resume a job</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/pauseResumeJobButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					Pause or resume the selected job (only if you are
					the job owner).
				</para>

				<figure xml:id="changeJobPriorityButton"><info><title>Change job priority</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/changeJobPriorityButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					Change job priority (only if you are the job owner).
					Priority allowed are:
					<itemizedlist>
						<listitem>
							<para>Lowest.</para>
						</listitem>
						<listitem>
							<para>Low.</para>
						</listitem>
						<listitem>
							<para>Normal.</para>
						</listitem>
					</itemizedlist>
				</para>

				<figure xml:id="getJobOutputButton"><info><title>Display job output</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/getJobOutputButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					To display the selected job's standard and error
					output (only if you are the job owner).
				</para>

				<figure xml:id="killJobButton"><info><title>Kill Job</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/killJobButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					To kill the selected job (only if you are the job
					owner).
				</para>
			</section><!-- The Jobs view buttons in User Mode -->

			<section xml:id="admin_mode"><info><title>
					The Jobs view buttons in Administrator Mode
				</title></info>
				
				<para>
					All buttons allowed in user mode are also allowed in
					Administrator mode. Moreover you can execute any
					action even you aren't the job owner.
				</para>
				<para>
					In Administrator mode, 3 other choices for job
					priority are available :
					<itemizedlist>
						<listitem>
							<para>
								Idle, lower priority than the 3 User
								Mode priorities
							</para>
						</listitem>
						<listitem>
							<para>
								High, higher priority than the 3 User
								Mode priorities
							</para>
						</listitem>
						<listitem>
							<para>
								Highest, higher priority than the 3 User
								Mode priorities and than High
							</para>
						</listitem>
					</itemizedlist>
				</para>

				<figure xml:id="startSchedulerButton"><info><title>Start the scheduler</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/startSchedulerButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>

				<figure xml:id="stopSchedulerButton"><info><title>Stop the scheduler</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/stopSchedulerButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>

				<figure xml:id="freezeSchedulerButton"><info><title>Freeze the scheduler</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/freezeSchedulerButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					This freezes the scheduler. When the scheduler
					receives this event, it pauses all running jobs, and
					no other pending jobs will be scheduled.
				</para>

				<figure xml:id="pauseSchedulerButton"><info><title>Pause the scheduler</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/pauseSchedulerButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					This pauses the scheduler. When the scheduler
					receives this event, no pending jobs will be
					scheduled, but all running jobs complete.
				</para>

				<figure xml:id="resumeSchedulerButton"><info><title>Resume the scheduler</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/resumeSchedulerButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>

				<figure xml:id="shutdownSchedulerButton"><info><title>Shutdown the scheduler</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/shutdownSchedulerButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					This shutdowns the scheduler. When the scheduler
					receives this event, job submission is no more
					allowed, but all running jobs complete. When all
					jobs are finished, the scheduler is shutdown.
				</para>

				<figure xml:id="killSchedulerButton"><info><title>Kill scheduler</title></info>
					
					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%" contentdepth="100%"  fileref="scheduler/pics/eclipse_plugin/killSchedulerButton.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					This shutdown immediately the scheduler, without
					waiting for any job completion.
				</para>
			</section><!-- The Jobs view buttons in Administrator Mode -->
		</section><!-- The Scheduler perspective buttons -->
	</section>




	<section xml:id="ProActive_Scheduler_Matlab"><info><title>ProActive Scheduler's Matlab Extension</title></info>
		
		<section xml:id="Scheduler_Matlab_Overwiew"><info><title>Presentation</title></info>
			
			<para>
				MATLAB is a numerical computing environment and
				programming language. Created by The MathWorks, MATLAB
				allows easy matrix manipulation, plotting of functions
				and data, implementation of algorithms, creation of user
				interfaces, and interfacing with programs in other
				languages.
			</para>
			<para>
				The Goal of ProActive Scheduler's Matlab Extension is
				to:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						allow users to easily launch Matlab scripts over
						an heterogeneous grid
					</para>
				</listitem>
				<listitem>
					<para>
						describe complex task flows in Matlab using
						human-readable XML descriptors
					</para>
				</listitem>
				<listitem>
					<para>
						Ability to communicate the result of one task as
						input of another task.
					</para>
				</listitem>
				<listitem>
					<para>
						users won't have to write any other code than
						Matlab script code
					</para>
				</listitem>
				<listitem>
					<para>
						support the following Matlab types : Double,
						Complex, Int or String Arrays. Cells. Records.
					</para>
				</listitem>
			</itemizedlist>
			<para>
				A good way to start manipulating and scheduling Matlab
				scripts is to have a look at the standalone (and simple)
				Matlab/Scilab GUI described at
				<xref linkend="ScilabDoc"/>
				. If you want to directly through more complex Matlab
				job scheduling, go on with the following tutorial.
			</para>
		</section>
		<section xml:id="Scheduler_Matlab_Quick_Start"><info><title>Quick Start with the Matlab Extension</title></info>
			
			<para>
				To get quickly our hands in, we'll write a very simple
				Matlab job example. This simple example will compute the
				roots of several polynomials.
			</para>
			<section xml:id="Scheduler_Matlab_Installation_Prerequisite"><info><title>Installation</title></info>
				
				<para>
					Before starting to use the Matlab interface, you
					need to install the Matlab interface to Java. You'll
					find all the instructions on
					PROACTIVE/scripts/unix/matlab/README. This interface
					will build the native libraries of the Java
					Interface to Matlab. As this library is native, it
					is important that you build it for each couple
					&lt;Matlab version, Architecture&gt; inside your
					grid infrastructure. If you are using a ProActive
					installation on a centralized NFS folder, this will
					be sufficient. Otherwise, you will have to build and
					install the native library inside your ProActive
					installation on each machine used.
				</para>
				<para>
					The good news are, if you successfully run the
					configuration script, you won't have to bother where
					Matlab is installed at runtime, the Scheduler will
					determine it for you. A little drawback to this is
					that the scheduler will use the first Matlab
					installation found on the system, so it might not do
					what you want when several Matlab installations are
					on the same machine. Further releases of the
					extension will allow a finer control over that by
					specifying Matlab's minimum version requirement
					inside job descriptors.
				</para>
			</section>
			<section xml:id="Scheduler_Matlab_Simple_Script"><info><title>
					Writing a simple example : the Matlab Script
				</title></info>
				
				<para>
					We write a very simple script which computes the
					roots of a single given polynomial.
				</para>
				<programlisting xml:lang="matlab">out=roots(in);</programlisting>
				<para>
					The
					<emphasis>in</emphasis>
					and
					<emphasis>out</emphasis>
					variables are specific variables which describe the
					inputs and outputs of a Matlab script for the
					Scheduler. in and out can contain anything supported
					by the extension (Double, Complex, or String arrays,
					Cells, Records).
				</para>
			</section>
			<section xml:id="Scheduler_Matlab_Simple_Descriptor"><info><title>
					Writing a simple example : the Scheduler job
					descriptor
				</title></info>
				
				<para>
					This is a step by step guide to write this job
					descriptor.
				</para>
				<section xml:id="Scheduler_Matlab_Job_Definition"><info><title>The job definition</title></info>
					
					<para>
						The
						<emphasis>job</emphasis>
						tag is the root tag of our descriptor, it must
						have a
						<emphasis>name</emphasis>
						attribute which holds an id of the job. It is
						generally followed by a
						<emphasis>description</emphasis>
						tag which gives textual description of the job.
						Finally, the next tag will be the type of job to
						schedule. In our case it will be a
						<emphasis>taskFlow</emphasis>
						job (a job containing several tasks).
					</para>
					<programlisting xml:lang="xml">&lt;job xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="urn:proactive:jobdescriptor:0.91 http://proactive.inria.fr/schemas/jobdescriptor/0.91/schedulerjob.xsd"
    xmlns="urn:proactive:jobdescriptor:0.91" name="Matlab_job_simplest"&gt;
    &lt;description&gt;A simple Matlab job, which computes the roots of several polynomials&lt;/description&gt;
    &lt;taskFlow&gt;
      ...
    &lt;/taskFlow&gt;
&lt;/job&gt;</programlisting>
				</section>
				<section xml:id="Scheduler_Matlab_Task_Definition"><info><title>The task definition</title></info>
					
					<para>
						The
						<emphasis>task</emphasis>
						tag contains all the information for a single
						task executed on a single machine. In our
						example, this task will be the matlab script
						calculating the root of a polynomial.
					</para>
					<para>
						The task tag must contain a
						<emphasis>name</emphasis>
						attribute like the job tag. Here it contains as
						well the attribute
						<emphasis>preciousResult</emphasis>
						which tells the scheduler that we need the
						result of this task as final output for our job.
						The task tag is immediately followed by a
						<emphasis>description</emphasis>
						tag containing a textual description of this
						task.
					</para>
					<para>
						The description tag is followed by a
						<emphasis>selection</emphasis>
						tag. This tag describes a script which will
						select, among all the machine resources that the
						Scheduler controls, the specific resources
						(machine) that can effectively run this task.
						This script can for example test that Matlab is
						installed and has the right version, that
						specific Toolboxes are installed... We provide a
						generic script which simply tests if Matlab is
						installed. The script is retrieved from the URL
						<uri xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://proactive.inria.fr/userfiles/file/scripts/checkMatlab.js">http://proactive.inria.fr/userfiles/file/scripts/checkMatlab.js</uri>
					</para>
					<programlisting xml:lang="xml">&lt;task name="root1" preciousResult="true"&gt;
    &lt;description&gt;Calculates the root of a polynomial&lt;/description&gt;
    &lt;selection&gt;
        &lt;script&gt;
            &lt;file url="http://proactive.inria.fr/userfiles/file/scripts/checkMatlab.js"/&gt;
        &lt;/script&gt;
    &lt;/selection&gt;
    ...
&lt;/task&gt;</programlisting>
				</section>
				<section xml:id="Scheduler_Matlab_Script_Definition"><info><title>The Matlab script definition</title></info>
					
					<para>
						Now we finally write the script that will be
						executed on the remote machine. The
						<emphasis>javaExecutable</emphasis>
						tag is a container for our Matlab script, it's a
						java program that will connect to the Matlab
						engine and launch the given script inside it.
					</para>
					<programlisting xml:lang="xml">&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.ext.matlab.SimpleMatlab"&gt;
    &lt;parameters&gt;
        &lt;parameter name="input" value="in=[1 0 3 -2 5 1];"/&gt;
        &lt;parameter name="script" value="out=roots(in);"/&gt;
    &lt;/parameters&gt;
&lt;/javaExecutable&gt;</programlisting>
					<para>
						The javaExecutable tag contains an attribute
						<emphasis>class</emphasis>
						which tells which type of Matlab task will be
						used, here we'll describe only the task called
						<emphasis>SimpleMatlab</emphasis>
						. In
						<xref linkend="Scheduler_Matlab_AdvancedTasks"/>
						, we describe more advanced tasks. The
						javaExecutable tag contains a child tag called
						<emphasis>parameters</emphasis>
						. This tag contains a list of
						<emphasis>parameter</emphasis>
						tags which define the task parameters. Each
						parameter tag, has
						<emphasis>name/value</emphasis>
						couple attributes.
					</para>
					<para>
						The SimpleMatlab task accepts the following
						parameters:
					</para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>script</emphasis>
								: defines which matlab script will be
								launched. The value attributes will
								contain the matlab script code (useful
								for one line scripts only).
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>scriptFile</emphasis>
								: defines which matlab script will be
								launched. The file at the given path
								will be loaded.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>scriptUrl</emphasis>
								: defines which matlab script will be
								launched. The file at the given remote
								url will be loaded.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>input</emphasis>
								: defines an input script which will be
								launched before the actual matlab
								script. The value attribute needs to
								contain the script code (which must be
								single-line only).
							</para>
						</listitem>
					</itemizedlist>
				</section>
				<section xml:id="Scheduler_Matlab_Complete_Descriptor"><info><title>Complete Job Descriptor</title></info>
					
					<example xml:id="Scheduler_Matlab_Simple_Descriptor_Example"><info><title>
							Simple Matlab Job descriptor Example
						</title></info>
						
						<programlisting xml:lang="xml">
							<textobject>
								<textdata fileref="../descriptors/scheduler/jobs/Job_matlab_simplest.xml"/>
							</textobject>
						</programlisting>
					</example>
				</section>
			</section>
		</section>
		<section xml:id="Scheduler_Matlab_More_Complex"><info><title>A More Complex Example : a Matlab task flow</title></info>
			
			<para>
				Now we will get through a more complex example. This
				example will use an interesting feature of the Matlab
				extension : the ability to pass results of one task as
				inputs of another task. This exemple, on the contrary of
				the previous one, is not a simple parallel batch
				processing, it's a flow of tasks, which depends from
				each others.
			</para>
			<para>
				This example will compute the sum of a big,
				randomly-generated array, values taken from -50 to +50.
				The example contains 3 steps:
			</para>
			<para>
				<orderedlist>
					<listitem>
						<para>
							It splits the big array into several smaller
							arrays.
						</para>
					</listitem>
					<listitem>
						<para>
							It computes the sum of each array in
							parallel.
						</para>
					</listitem>
					<listitem>
						<para>
							It merges the results from each parallel
							sub-total to compute the final sum.
						</para>
					</listitem>
				</orderedlist>
			</para>
			<para>
				This is not, of course, a real-case example as computing
				the sum of a big array will be much faster on a single
				machine (due to the overhead of launching Java and a
				Matlab engine and the network latency), but it is meant
				to illustrate a simple task flow in Matlab.
			</para>
			<para>
				We'll go through the new concepts introduced in this
				example compared to the previous one. Have a look at the
				new job descriptor first:
			</para>
			<example xml:id="Scheduler_Matlab_Complex_Descriptor_Example"><info><title>Complex Matlab Job descriptor Example</title></info>
				
				<programlisting xml:lang="xml">
					<textobject>
						<textdata fileref="../descriptors/scheduler/jobs/Job_matlab.xml"/>
					</textobject>
				</programlisting>
			</example>
			<section xml:id="Scheduler_Matlab_Descriptor_Variables"><info><title>Descriptor variables</title></info>
				
				<para>
					The
					<emphasis>variables</emphasis>
					declaration allows a user to define a variable which
					can be used as a pattern in other parts of the
					descriptor. This helps writing more generic
					descriptors and replacing only the variables values
					to adapt the descriptor to many contexts. Here is
					the variables declaration in the preceding
					descriptor:
				</para>
				<programlisting xml:lang="xml">&lt;variables&gt;
    &lt;variable name="HOME" value="/user/fviale/home"/&gt;
    &lt;variable name="MATLAB_SCRIPTS" value="${HOME}/matlab"/&gt;
&lt;/variables&gt;</programlisting>
				<para>
					the
					<emphasis>variables</emphasis>
					tag contains a list of
					<emphasis>variable</emphasis>
					tags which each defines a variable through a
					<emphasis>name</emphasis>
					and a
					<emphasis>value</emphasis>
					attribute. The variable can then be used by writing
					the pattern
					<emphasis>${name_of_the_variable}</emphasis>
					. Variable can be reused inside the variable
					declaration itself, but the variables are processed
					sequentially from top to bottom. Therefore, in this
					example, In this example the MATLAB_SCRIPTS variable
					could not be used before the HOME variable.
				</para>
			</section>
			<section xml:id="Scheduler_Matlab_AdvancedTasks"><info><title>
					New Tasks : MatlabSplitter and MatlabCollector
				</title></info>
				
				<programlisting xml:lang="xml">&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.ext.matlab.MatlabSplitter"&gt;
    &lt;parameters&gt;
        &lt;parameter name="scriptFile" value="${MATLAB_SCRIPTS}/splitter.m"/&gt;
        &lt;parameter name="input" value="in=round(rand(1,1000000)*100-50)"/&gt;
        &lt;parameter name="number_of_children" value="6"/&gt;
    &lt;/parameters&gt;
&lt;/javaExecutable&gt;</programlisting>
				<programlisting xml:lang="xml">&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.ext.matlab.MatlabCollector"&gt;
    &lt;parameters&gt;
        &lt;parameter name="scriptFile" value="${MATLAB_SCRIPTS}/collector.m"/&gt;
    &lt;/parameters&gt;
&lt;/javaExecutable&gt;</programlisting>
				<para>
					Two new tasks appear in this descriptor : the
					<emphasis>MatlabSplitter</emphasis>
					and the
					<emphasis>MatlabCollector</emphasis>
					. The Splitter task is used to split an input into a
					list of several chunks. The Collector task is used
					to collect and merge the results from several
					parallel tasks. Each of these tasks come with the
					same parameter as the SimpleMatlab tasks with an
					addition: The Splitter expects an additional
					parameter called
					<emphasis>number_of_children</emphasis>
					. This parameter tells the Matlab script responsible
					for splitting in how many parts the input should be
					divided.
				</para>
			</section>
			<section xml:id="Scheduler_Matlab_Dependencies"><info><title>Task dependencies</title></info>
				
				<para>
					In order to do complex task flows, it is necessary
					to add the concept of dependencies between tasks.
				</para>
				<programlisting xml:lang="xml">&lt;task name="sum1"&gt;
    &lt;description&gt;Calculates the sum of the elements in the array&lt;/description&gt;
    &lt;depends&gt;
        &lt;task ref="splitter"/&gt;
    &lt;/depends&gt;
    ...&lt;/task&gt;</programlisting>
				<para>
					The
					<emphasis>depends</emphasis>
					tag in this task definition defines a dependency of
					the task named "sum1" to the task named "splitter".
					This means that the task sum1 will be launched afer
					the task splitter is complete, and that the outputs
					of splitter will be fed as inputs to sum1.
				</para>
				<para>
					You'll notice that in this example, all the sumX
					SimpleMatlab tasks depend from the Splitter. This
					means that the output from the Splitter will be fed
					to each sum task. On the other hand, the Collector
					depends on every sumX task. It will be launched only
					after all these tasks have completed, and the
					results of all these tasks will be the inputs of the
					Collector, you'll see on
				</para>
			</section>
			<section xml:id="Scheduler_Matlab_SimpleTaskIndex"><info><title>
					New parameter in SimpleMatlab tasks: index
				</title></info>
				
				<programlisting xml:lang="xml">&lt;task name="sum1"&gt;
    &lt;description&gt;Calculates the sum of the elements in the array&lt;/description&gt;
    &lt;depends&gt;
        &lt;task ref="splitter"/&gt;
    &lt;/depends&gt;
    &lt;selection&gt;
        &lt;script&gt;
            &lt;file url="http://proactive.inria.fr/userfiles/file/scripts/checkMatlab.js"/&gt;
        &lt;/script&gt;
    &lt;/selection&gt;
    &lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.ext.matlab.SimpleMatlab"&gt;
        &lt;parameters&gt;
            &lt;parameter name="index" value="0"/&gt;
            &lt;parameter name="scriptFile" value="${MATLAB_SCRIPTS}/summer.m"/&gt;
        &lt;/parameters&gt;
    &lt;/javaExecutable&gt;
&lt;/task&gt;</programlisting>
				<para>
					A new parameter appears in this descriptor for the
					SimpleMatlab task : the
					<emphasis>index</emphasis>
					. The parameter is related to the splitting
					mechanism. It can be defined only inside a
					SimpleMatlab task and has sense only if the Simple
					task has a Splitter task as parent. The Splitter
					sends an output in the form of a list of results to
					each child task. The same list will be sent to every
					children. Therefore, each one needs to specify at
					which index of the list it will look at. For
					example, a splitter task splits the array [1,2,3,4]
					into two arrays [1,2] and [3,4], the first child
					needs to specify index 0 and second index 1 (note
					that the indexes range from 0 to
					number_of_children-1). By specifying these indexes,
					the first child will get as input the array [1,2]
					and the second child will get [3,4].
				</para>
			</section>
			<section xml:id="Scheduler_Matlab_ComplexExamples_Scripts"><info><title>Matlab Scripts for this example</title></info>
				
				<section xml:id="ComplexExamples_Splitter_Script"><info><title>Script of the Splitter Task</title></info>
					
					<programlisting xml:lang="matlab">
						<textobject>
							<textdata fileref="../scripts/unix/matlab/examples/splitter.m"/>
						</textobject>
					</programlisting>
					<para>
						The Splitter script contains two important
						aspects:
					</para>
					<itemizedlist>
						<listitem>
							<para>
								It contains two inputs, the variable
								<emphasis>in</emphasis>
								which is fed by the "input" script of
								the splitter task, and the variable
								<emphasis>nout</emphasis>
								which contains the value of the
								<emphasis>number_of_children</emphasis>
								parameter.
							</para>
						</listitem>
						<listitem>
							<para>
								The
								<emphasis>out</emphasis>
								variable, which is the output of the
								script must be a cell array of size
								nout.
							</para>
						</listitem>
					</itemizedlist>
				</section>
				<section xml:id="ComplexExamples_Summing_Script"><info><title>Script of the Summing Task</title></info>
					
					<programlisting xml:lang="matlab">
						<textobject>
							<textdata fileref="../scripts/unix/matlab/examples/summer.m"/>
						</textobject>
					</programlisting>
				</section>
				<section xml:id="ComplexExamples_Collector_Script"><info><title>Script of the Collector Task</title></info>
					
					<programlisting xml:lang="matlab">
						<textobject>
							<textdata fileref="../scripts/unix/matlab/examples/collector.m"/>
						</textobject>
					</programlisting>
					<para>
						The important aspect of the The Collector script
						is that the input parameter
						<emphasis>in</emphasis>
						is a cell array.
					</para>
				</section>
			</section>
		</section>
	</section>

	<section xml:id="ProActive_Scheduler_Scilab"><info><title>ProActive Scheduler's Scilab Extension</title></info>
		
		<section xml:id="Scheduler_Scilab_Overwiew"><info><title>Presentation</title></info>
			
			<para>
				<emphasis>Scilab</emphasis>
				is a scientific software for numerical computations.
				Developed since 1990 by researchers from INRIA and ENPC,
				it is now maintained and developed by Scilab Consortium
				since its creation in May 2003. Scilab includes hundreds
				of mathematical functions with the possibility to add
				interactively programs from various languages (C,
				Fortran...). It has sophisticated data structures
				(including lists, polynomials, rational functions,
				linear systems...), an interpreter and a high level
				programming language. Scilab works on most Unix systems
				(including GNU/Linux) and Windows (9X/2000/XP).
			</para>
			<para>
				Similarly to ProActive Scheduler's Matlab extension, the
				goal of the Scilab Extension is to:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						allow users to easily launch Scilab scripts over
						an heterogeneous grid
					</para>
				</listitem>
				<listitem>
					<para>
						describe complex task flows in Scilab using
						human-readable XML descriptors
					</para>
				</listitem>
				<listitem>
					<para>
						Ability to communicate the result of one task as
						input of another task.
					</para>
				</listitem>
				<listitem>
					<para>
						users won't have to write any other code than
						Scilab script code
					</para>
				</listitem>
				<listitem>
					<para>
						support the following Scilab types : Double,
						Complex and String Arrays (the extension
						currently supports fewer types than the Matlab's
						one).
					</para>
				</listitem>
			</itemizedlist>
			<para>
				A good way to start manipulating and scheduling Scilab
				scripts is to have a look at the standalone (and simple)
				Matlab/Scilab GUI described at
				<xref linkend="ScilabDoc"/>
				. If you want to directly through more complex Scilab
				job scheduling, go on with the following tutorial.
			</para>
		</section>
		<section xml:id="Scheduler_Scilab_Quick_Start"><info><title>Quick Start with the Scilab Extension</title></info>
			
			<para>
				We'll write a simple Scilab job example. This example
				will assume that you are familiar with the example in
				<xref linkend="Scheduler_Matlab_More_Complex"/>
				. This example will compute the numerical integration of
				sin(x) between 0 and PI.
			</para>
			<section xml:id="Scheduler_Scilab_Installation_Prerequisite"><info><title>Installation</title></info>
				
				<para>
					Before starting to use the Scilab interface, you
					need to install Scilab in your environment. You'll
					find all the instructions on
					PROACTIVE/scripts/unix/scilab/README_Scheduler
					(Scilab section).
				</para>
				<para>
					Once Scilab is installed, you won't need at runtime
					to bother where Scilab is installed, the Scheduler
					will determine it for you.
				</para>
			</section>
			<section xml:id="Scheduler_Scilab_Job_Descriptor"><info><title>The Scilab Job descriptor</title></info>
				
				<para>
					This is the descriptor of the scilab job which will
					be executed inside the scheduler
				</para>
				<example xml:id="Scheduler_Scilab_Descriptor_Example"><info><title>Scilab Job descriptor Example</title></info>
					
					<programlisting xml:lang="xml">
						<textobject>
							<textdata fileref="../descriptors/scheduler/jobs/Job_scilab.xml"/>
						</textobject>
					</programlisting>
				</example>
				<para>
					Here is the Scilab script that calculates individual
					integrals
				</para>
				<example xml:id="Scheduler_Scilab_Int_Script"><info><title>Integral script</title></info>
					
					<programlisting xml:lang="scilab">
						<textobject>
							<textdata fileref="../scripts/unix/scilab/examples/intsin.sci"/>
						</textobject>
					</programlisting>
				</example>
				<para>
					Here is the Scilab script that merges the individual
					results and computes the final answer
				</para>
				<example xml:id="Scheduler_Scilab_Merge_Script"><info><title>Merging script</title></info>
					
					<programlisting xml:lang="scilab">
						<textobject>
							<textdata fileref="../scripts/unix/scilab/examples/merge.sci"/>
						</textobject>
					</programlisting>
				</example>
				<para>
					This descriptor is very similar to the descriptor
					<xref linkend="Scheduler_Matlab_Complex_Descriptor_Example"/>
					. We'll go through the similarities and differences
					of these two descriptors.
				</para>
				<section xml:id="Scheduler_Scilab_Job_Descriptor_Similarities"><info><title>
						Similarities with Matlab job descriptor
					</title></info>
					
					<itemizedlist>
						<listitem>
							<para>
								Concepts of job, tasks and dependences
								are common to all ProActive Scheduler
								jobs, so we find here the same concepts
								than in Matlab's.
							</para>
						</listitem>
						<listitem>
							<para>
								Definitions of task's main and input
								scripts are done through the same task
								parameters
								<emphasis>script</emphasis>
								,
								<emphasis>scriptFile</emphasis>
								,
								<emphasis>scriptUrl</emphasis>
								and
								<emphasis>input</emphasis>
							</para>
						</listitem>
					</itemizedlist>

				</section>
				<section xml:id="Scheduler_Scilab_Job_Descriptor_Differences"><info><title>
						Differences with Matlab job descriptor
					</title></info>
					
					<para>For example in the following task :</para>
					<programlisting xml:lang="xml">&lt;javaExecutable
 class="org.objectweb.proactive.extensions.scheduler.ext.scilab.SimpleScilab"&gt;
    &lt;parameters&gt;
        &lt;parameter name="scriptFile"
          value="${SCILAB_SCRIPTS}/intsin.sci" /&gt;
        &lt;parameter name="input" value="i=3;n=5;" /&gt;
        &lt;parameter name="outputs" value="out" /&gt;
    &lt;/parameters&gt;
&lt;/javaExecutable&gt;</programlisting>
					<itemizedlist>
						<listitem>
							<para>
								The main Scilab task is now called
								<emphasis>SimpleScilab</emphasis>
								. There exists no splitting mechanism
								yet, but there is a merging mechanism
								explained below.
							</para>
						</listitem>
						<listitem>
							<para>
								A new important task parameter appears :
								<emphasis>outputs</emphasis>
								. This parameter is used to specify
								which variables will be extracted from
								the Scilab environment at task's end.
								You can specify multiple output
								variables by separating them with
								commas. If you don't specify an output
								parameter, the variable called
								<emphasis>out</emphasis>
								will be extracted (leading to an error
								if it doesn't exist).
							</para>

						</listitem>
						<listitem>
							<para>
								The merging mechanism is different than
								for Matlab's. If a task depends from a
								bunch of other tasks. An automatic
								environment merging will be done. For
								example if we have 3 tasks A,B,C and C
								depends of A and B. if task A outputs a
								variable "a" and task B outputs a
								variable "b", task C will get as input
								both variable "a" and "b". Now a problem
								arise when several tasks output the same
								variable name. In order to avoid
								overlapping, and to allow merging of
								results, this variable will be renamed
								by appending index at the end of the
								conflicting variable name. In the
								current example, each tasks t1 - t5
								output the same variable "out". task t6
								will accordingly get as input variable
								out1 - out5. The index starts from 1 and
								the order matches the depends list
								order.
							</para>
						</listitem>
					</itemizedlist>
				</section>
			</section>
		</section>
	</section>





	<section xml:id="Resource_Manager"><info><title>Resource Manager</title></info>
		
		<para>
			<emphasis role="bold">NOTE</emphasis>
			- A RCP/Eclipse graphical client is available,
			<emphasis>but not yet documented</emphasis>
			for monitoring and controlling a Resource Manager. You can
			find it in the ProActive Download page.
		</para>
		<section xml:id="Role"><info><title>Role</title></info>
			
			<para>
				As Scheduler manages pool of jobs to execute, Resource
				manager is in charge of supplying Scheduler in resources
				: ProActive nodes. Resource Manager (RM) takes benefits
				of the ProActive library, so it can handle resources
				from LAN, on cluster, on P2P desktop Grids, or on
				Internet Grids. ResourceManager provides scheduler in
				nodes, according to criteria of the task to execute on
				it (operating system, dynamic libraries, memory...). Its
				main functions are :
			</para>
			<itemizedlist>
				<listitem>

					<para>
						Creation, acquisition and removal of ProActive
						nodes.
					</para>
				</listitem>
				<listitem>
					<para>
						Supplying nodes to scheduler for tasks
						executions, Scheduler can ask nodes that verify
						criteria, these criteria are defined in a
						selection script.
					</para>
				</listitem>
				<listitem>
					<para>
						Maintaining and monitoring its list of node
						resources, and manage states of its handled
						nodes (free, busy, down...).
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section xml:id="architecture"><info><title>Resource Manager architecture</title></info>
			
			<para>Resource Manager is made of five components :</para>
			<itemizedlist>
				<listitem>
					<para>
						<emphasis>User</emphasis>
						Resource Manager's frontend for the Scheduler,
						this component provides for scheduler an entry
						to get and give back nodes.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Admin</emphasis>
						Frontend for RM's administrator, provides
						administrator actions; add and remove nodes, add
						and remove different node sources, shutting down
						the Resource manager.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Core</emphasis>
						Main component, selects and gives nodes to
						scheduler, maintains different nodes states for
						each node, and receive new available nodes
						acquired by Node Sources.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Monitoring component</emphasis>
						Resource manager can have monitors connected to
						it. Monitors are external programs (such as
						monitor GUI) that want to be informed about RM
						current activity; numbers of nodes and their
						availability for example. The Monitoring
						component is in charge of throwing RM
						information to its monitors.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Node Sources</emphasis>
						Resource manager can handle nodes coming from
						heterogeneous environments, a Node source
						component is in charge of nodes acquisition,
						deployment and monitoring for a dedicated
						infrastructure. It means we can have a Node
						source which manages nodes deployed by a
						ProActive descriptor, one for nodes acquired
						from a Peer to peer infrastructure, and another
						for nodes acquired from a cluster.
					</para>
				</listitem>
			</itemizedlist>
			<figure xml:id="RM_architecture"><info><title>resource Manager architecture</title></info>
				
				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%"  align="center" fileref="scheduler/pics/core/rm_overview.jpg" format="JPG"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>
		<section xml:id="nodes_sources"><info><title>Static Node Source and Dynamic Node Source</title></info>
			
			<para>
				Node Sources objects are aimed to acquire nodes for the
				RM, there are two kinds of Node Sources :
			</para>
			<itemizedlist>
				<listitem>
					<para>
						<emphasis>Static Node Source</emphasis>
						defined for deploying and acquiring nodes by a
						ProActive descriptor. All nodes handled by the
						source are kept permanently by the Resource
						Manager, i.e until the termination of the RM or
						if Administrator ask to remove some of them.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Dynamic Node Source</emphasis>
						designed to acquire nodes from an infrastructure
						which can provide nodes just for a limited time.
						So this Node Source get a node from a specific
						infrastructure, keep it during a defined time.
						When this keeping time is elapsed, dynamic node
						source remove the node from the RM and give back
						node to its infrastructure. A dynamic node
						source have three main parameters :
					</para>
					<para>
						Max number of nodes : number of nodes that
						dynamic Node Source has to get from its
						corresponding infrastructure. The dynamic node
						source tries to acquire this number of node
						source, but its infrastructure may not be able
						to provide as many nodes. So this is the number
						of acquired nodes that Dynamic Node Source tries
						to reach.
					</para>
					<para>
						Time to release(TTR) : keeping duration of an
						acquired node. when this keeping duration is
						reached by a node, dynamic node source releases
						it.
					</para>
					<para>
						Nice time : After a node release, time to wait
						for the dynamic node source before trying to get
						a new node from its infrastructure. After each
						node release, dynamic node source waits "nice
						time", and after tries to acquire a new node.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section xml:id="nodes_states"><info><title>Nodes states</title></info>
			
			<para>
				Resource Manager has to maintain states of its handled
				nodes, here the different nodes states :
			</para>
			<itemizedlist>
				<listitem>
					<para>
						<emphasis>Free</emphasis>
						Node is available, and there is no task launched
						on it. Node can be supplied to a scheduler.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Busy</emphasis>
						Node has been given to scheduler and a task is
						executed on it.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>To be released</emphasis>
						Node is busy, and administrator or its (dynamic)
						Node Source has asked to remove the node. So the
						node will be removed from RM after task's end.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Down</emphasis>
						Node has a problem (unreachable, fallen...) and
						can't execute tasks anymore.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section xml:id="RM_start"><info><title>Starting the Resource Manager</title></info>
			
			<para>
				To start the Resource Manager, run the RMlauncher.sh
				script in scripts/scheduler directory. Without
				arguments, Resource Manager will start and create four
				ProActive nodes on the local host. RMlauncher.sh can be
				started with 1 optional argument:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						Path of a ProActive descriptor file (for example
						: ProActive/descriptors/Workers.xml). Descriptor
						is deployed and nodes added to the RM by a
						static Node Source at the RM's startup.
					</para>
				</listitem>
			</itemizedlist>
			<para>
				You can also start Resource Manager using the java API.
				Resource Manager can be started with static functions of
				RMFactory class. Here a short sample of RM instantiation
				with deployment of a ProActive descriptor. Nodes
				deployment is asked to RMAdmin object :
			</para>
			<programlisting xml:lang="java">
				RMFactory.startLocal(); //creates Resource Manager
				components RMAdmin admin = RMFactory.getAdmin(); //get
				RMAdmin object

				//creates ProActive Descriptor object from an xml file
				ProActiveDescriptor pad =
				PADeployment.getProactiveDescriptor("myDescriptor.xml");

				//Ask to RMAdmin component to deploy the ProActive
				Descriptor //and add deployed nodes to the RM
				admin.addNodes(pad);
			</programlisting>
		</section>
	</section>
</chapter>

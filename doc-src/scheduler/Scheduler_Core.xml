<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="../viewDocbook.css"?>
<chapter id="ProActive_Scheduler">
  <title>ProActive Scheduler and Resource Manager</title>

    <para><emphasis role="bold">IMPORTANT NOTE</emphasis> - Some parts of the ProActive Scheduler and ProActive Resource Manager rely on Java Scripting capabilities (<ulink url="http://jcp.org/en/jsr/detail?id=223">JSR 223</ulink>). As a consequence, it requires either:
    <itemizedlist>
          <listitem> a 1.6 or greater Java Runtime Environment, without any modifications, </listitem>
          <listitem> or, with a 1.5 JRE, the <ulink url="http://jcp.org/aboutJava/communityprocess/final/jsr223/index.html">JSR 223 jar files</ulink>. Those files must be added in the <literal>/ProActive/dist/lib/</literal> directory if
          you are using the bin release or ProActive, or in the <literal>/ProActive/lib/</literal> directory if you build ProActive from the source release.</listitem>
    </itemizedlist>
    </para>

  <sect1 id="overview">
    <title>Overview</title>

    <para>The execution of parallel tasks on a pool of distributed resources,
    such as network of desktops or clusters, requires a main system for
    managing resources and handling task execution: <emphasis role="bold">a
    batch scheduler</emphasis>. A batch scheduler provides an abstraction of
    resources to users. Users submit jobs containing tasks to the <emphasis
    role="bold">scheduler</emphasis>, who is in charge of executing these
    tasks on the resources. A <emphasis role="bold">scheduler</emphasis>
    allows several users to share a same pool of resources and also to manage
    all issues related to distributed environment, such as faulted
    resources.</para>

    <para>In this chapter we present a ProActive based Scheduler accessible either from
    <emphasis role="bold">a JAVA programming API</emphasis>, <emphasis
    role="bold">a command-line based job submitter</emphasis>, <emphasis
    role="bold">or from a graphical user or admin interface</emphasis> (Eclipse
    RCP Plugin, see <xref linkend="Scheduler_Eclipse_Plugin" />) which can be
    plugged on the scheduler core application.</para>

    <para>In the rest of this chapter, we will expose how the scheduler works,
    what policies govern the job management, how to create a job and how to
    get the jobs and the nodes state using either the shell communicator or
    the GUI.</para>  
    
    <para><emphasis role="bold">NOTE</emphasis> - Additionally, you can find <ulink url="http://proactive.inria.fr/userfiles/file/tutorials/ProActiveSchedulerTutorial.pdf ">here</ulink>
     a fully documented example of the Scheduler and Resource Manager usage. This tutorial does not require Java nor ProActive knowledge since
     it's is only based on graphical interface and command line actions.
     </para>
    
    
  </sect1>

  <sect1 id="scheduler_concept">
    <title>Scheduler Concept</title>

    <sect2 id="what_is_job">
      <title>What is a Job ?</title>

      <para>A <emphasis role="bold">Job</emphasis> is the entity to be submitted
      to the scheduler. It is composed of one or more <emphasis
      role="bold">Tasks</emphasis>. A Job can have one of the following types
      : <itemizedlist>
          <listitem>
            <para><emphasis role="bold">TASKSFLOW</emphasis>, represents a Job
            that contains a bag of Tasks, which can be executed in parallel or
            according to a dependency tree. The Tasks inside this Job type can
            be either Java or Native. </para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">PROACTIVE</emphasis>, represents a Job
            that contains a ProActive application (embedded in <emphasis>only one ProActive Task</emphasis>).
            Its execution starts with a given predefined number of nodes
            on which the user can start the ProActive computation. This kind of Job requires
            the usage of the ProActive API, in order to use the given
            nodes.</para>
          </listitem>

          <!--  <listitem>
            <para><emphasis role="bold">PARAMETER SWEEPING (not yet implemented)</emphasis>, is a
            Job that represents multiple executions of one type of Task with
            different given parameters. It is typically executed in parallel.
            The Tasks inside this job can also be Java or Native. </para>
          </listitem>-->
        </itemizedlist></para>

      <para>A finished Job contains a result, which in term contains all of
      its tasks' results. However, it is possible to mark some task as  <emphasis
      role="bold">precious</emphasis> in order to retrieve their result easily in the job result.
      In the event of a failure, the finished
      Job contains the cause exceptions. Further details on how to
      create a Job and the different options can be found in: <xref
      linkend="job_creation" />.</para>
    </sect2>

    <sect2 id="what_is_task">
      <title>What is a Task ?</title>

      <para>The <emphasis role="bold">Task</emphasis> is the smallest
      schedulable entity. It is included in a <emphasis
      role="bold">Job</emphasis> (see <xref linkend="what_is_job" />) and will
      be executed in accordance with the scheduling policy (see <xref
      linkend="scheduling_policy" />) on the available
      resources.</para>

      <para>There are three types of Tasks : <itemizedlist>
          <listitem>
            <para><emphasis role="bold">JAVA</emphasis>; its execution is defined by 
            a java class extending the <literal>org.objectweb.proactive.extensions.scheduler.common.task.executable.JavaExecutable</literal> 
            class. </para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">NATIVE</emphasis>; its execution can be any user program specified by a simple command line, or by a 'generation script', that can dynamicaly generates 
            the command line to be executed.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">PROACTIVE</emphasis>; its execution is defined by 
            a java class extending the <literal>org.objectweb.proactive.extensions.scheduler.common.task.executable.ProActiveExecutable</literal> class, which defines the
            deployement and the execution of a ProActive application. Coding this last one requires a knowledge base on the use of
            ProActive.</para>
          </listitem>
        </itemizedlist></para>

      <para>During its execution, a Task may crash due to host or code failure. 
      A Task can be re-started a parameterizable number of time (see re-runnable in section <xref
      linkend="task_creation" />).</para>

      <para>A Task may optionally be accompanied by 3 kinds of scripts
      (pre-script, post-script and selection-script), that allow to select the suitable resource for a given task and possibly 
      configure it before and after task execution (see <xref linkend="task_creation"/>).</para>

      <para>Dependencies between Tasks can also be defined; this apsect is detailed in
      <xref linkend="how_dependences" />.</para>
    </sect2>

    <sect2 id="how_dependences">
      <title>Dependencies between Tasks</title>

      <para>Dependencies can be set between Tasks in a TaskFlow Job. It
      provides a way to execute your tasks in an ordered fashion, but also to
      forward the results of an ancestor task to its children as parameter. 
      Dependency between task is then both a logical dependency and 
      a data dependency.</para>

      <figure id="scheduler_job_img">
        <title>Task flow job example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="scheduler/pics/core/schedulerJob.jpg"
                       format="JPG" />
          </imageobject>
        </mediaobject>
      </figure>

   <para>In this example we made an 8 Task Job (where the Job's type is
      TaskFlow). As you can see, Task 4 depends on Task 1, Task 5 depends on
      Tasks 2 and 3, etc... In other words, Task 4 will wait for Task 1 to
      finish before starting, Task 5 will wait for Task 2
      <emphasis>AND</emphasis> 3, etc... In addition, the order in which you
      specify that Task 5 depends of Task 2 and 3 is very important. Indeed,
      if you set the list of dependencies for Task 5 as : 2 then 3, the result
      of these two task will be given to Task 5 in this order.</para>

      <para>As shown in the following lines, the given array of TaskResults
      (<emphasis>results</emphasis>) will be an array of two results
      (TaskResult 2 and 3) in this order. Therefore you can use them to
      perform Task 5 process. <programlisting lang="java">@Override
public Object execute(TaskResult... results) throws Throwable {
    //TaskResult tResult2 = results[0];
    //TaskResult tResult3 = results[1];
}</programlisting></para>

      <para>We will see how to define the dependencies and the order when we
      create our first job in <xref linkend="job_creation" />. In this
      example, result of Task 7 and 8 could be <emphasis
      role="bold">precious</emphasis>, which means that you can retrieve
      easily this two results.</para>
    </sect2>

    <sect2 id="scheduling_policy">
      <title>Scheduling Policy</title>

      <para><emphasis role="bold">By default</emphasis>, the scheduler
      schedules tasks according to the default <emphasis role="bold">FIFO
      (First In First Out) with job priority</emphasis> policy. We'll see
      later that the policy can be changed by implementing an interface.
      (<xref linkend="add_policy" />)</para>
    </sect2>
  </sect1>

  <sect1 id="scheduler_architecture">
    <title>Scheduler Architecture</title>

    <sect2 id="Scheduler_Global_Architecture">
      <title>Scheduler Global Architecture</title>

      <para>The Scheduler Service is the result of a collaboration between 2
      entities (the Scheduler and the Resource Manager) each one of them has
      its own functionality.</para>

      <para>The Scheduler is the main entity and is a non GUI daemon which is
      connected to the Resources Manager. It is in charge of scheduling
      submitted Jobs, in accordance with the scheduling policy.</para>

      <para>In order to launch Jobs, the Scheduler must obtain nodes
      (resources) from the Resources Manager. As describe below (<xref
      linkend="scheduler2entities" />), the user interacts only with the
      Scheduler entity and the managed resources can be simple host or peer to peer resource.</para>

      <figure id="scheduler2entities">
        <title>The Scheduler Entities</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="scheduler/pics/core/scheduler2entities.jpg"
                       format="JPG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para><emphasis role="bold">In this section</emphasis> we will explain
      how the <emphasis role="bold">scheduler entity works and how it can be
      used.</emphasis></para>
    </sect2>

    <sect2 id="Scheduler_entity_Architecture">
      <title>Scheduler Entity Architecture</title>

      <para><xref linkend="schedulerEntity">
          The architecture of the scheduler
        </xref> is built around 3 Active Objects : <itemizedlist>
          <listitem>
            <para><emphasis role="bold">The Authentication
            interface</emphasis> which is the first object that the user may
            have to contact. It is in charge of authenticatubg the user and
            allowing him access (or not) to the Scheduler. The authentication
            security system can interact with files or LDAP.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">The Front-end</emphasis> which is the
            interface returned by the Authentication Interface and allows
            interaction with the scheduler. This interface allows users to
            submit jobs, get scheduling state, retrieves job result
            etc...</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">The Core</emphasis> which is the main
            entity of the Scheduler. It is in charge of scheduling Jobs
            according with the policy (which is FIFO by default), retrieve
            scheduling events to the user and make storages.</para>
          </listitem>
        </itemizedlist></para>

      <para>Users cannot interact directly with the Scheduler Core and must
      use the Front-end gateway.</para>

      <figure id="schedulerEntity">
        <title>The Scheduler Entity</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="scheduler/pics/core/schedulerEntity.jpg"
                       format="JPG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>
  </sect1>

  <sect1 id="scheduler_use">
    <title>Using the ProActive Scheduler</title>

	<sect2 id="define_executable">
		<title>Define your own executable</title>
		<para>
	      	First of all, you must know that you can create your own task by implementing scheduler executable interfaces.
	      	It is possible to implement two types of executables :
	      	<itemizedlist>
	      		<listitem>
	      			<emphasis role="bold">JavaExecutable</emphasis> : to make your own java executable process.
	      			Here's an example of implementation for this type :
	      			<programlisting lang="java">
		public class WaitAndPrint extends JavaExecutable {
		
		    @Override
		    public Object execute(TaskResult... results) throws Throwable {
		        String message;
		
		        try {
		            System.err.println("DÃ©marrage de la tache WaitAndPrint");
		            System.out.println("Parameters are : ");
		
		            for (TaskResult tRes : results) {
		                if (tRes.hadException()) {
		                    System.out.println("\t " + tRes.getTaskId() + " : " +
		                        tRes.getException().getMessage());
		                } else {
		                    System.out.println("\t " + tRes.getTaskId() + " : " +
		                        tRes.value());
		                }
		            }
		
		            message = URIBuilder.getLocalAddress().toString();
		            Thread.sleep(10000);
		
		        } catch (Exception e) {
		            message = "crashed";
		            e.printStackTrace();
		        }
		
		        System.out.println("Terminaison de la tache");
		
		        return (message + "\t slept for 10 sec");
		    }
	    }
	      			</programlisting>
	      			<para>
	      				This task will print an initial message, then check if there are results from previous tasks and if so,
	      				print the value of these "parameters".
	      				It will then return a message containing what the task did. The return value will be store in the job result.
	      			</para>
	      			<para>
	      				It is also possible to get a list of arguments that you can give to the task at its start
	      				by overriding the init method on a java task.
	      				How to give arguments will be explain further in task creation section
	      				(<xref linkend="task_creation" />). We get back the foo, bar and test arguments to
	      				illustrate the task creation example below.
	      				<programlisting lang="java">
	private boolean foo;
	private int bar;
	private String arg;
	
	@Override
    public void init(Map&lt;String, Object&gt; args) {
        foo = (Boolean)args.get("foo");
        bar = (Integer)args.get("bar");
        arg = (String)args.get("arg");
    }
	      				</programlisting>
	      			</para>
	      		</listitem>
	      		<listitem>
	      			<emphasis role="bold">ProActiveExecutable</emphasis> : to make your own ProActive application process.
	      			Here's an example overview of implementation for this type :
	      			<programlisting lang="java">
	@Override
    public Object execute(ArrayList&lt;Node&gt; nodes) {
        System.out.println("ProActive job started !!");

        // create workers (on local node)
        Vector&lt;Worker&gt; workers = new Vector&lt;Worker&gt;();

        for (Node node : nodes) {
            try {
                Worker w = (Worker) PAActiveObject.newActive(Worker.class.getName(),
                        new Object[] {  }, node);
                workers.add(w);
            } catch (ActiveObjectCreationException e) {
                e.printStackTrace();
            } catch (NodeException e) {
                e.printStackTrace();
            }
        }

        // create controller
        Controller controller = new Controller(workers);
        int result = controller.findNthPrimeNumber(numberToFind);

        System.out.println("last prime : " + result);

        return result;
    }
	      			</programlisting>
	      			<para>
	      				As shown in a ProActive tutorial, this example uses the given nodes with 
	      				the ProActive API in order to launch 'workers' on them. The <emphasis>execute(nodes)</emphasis> method
	      				shows what can be done inside this kind of task.
	      				For more details about how to use the ProActive API, see the appropriate documentation.
	      			</para>
	      		</listitem>
	      		<listitem>
	      			<emphasis role="bold">NativeExecutable</emphasis> : just use this class when you'd like
	      			to run a native process on the scheduler. You don't have to extend this class,
	      			just use it as shown in the next section.
	      		</listitem>
	      	</itemizedlist>
	      </para>
	</sect2>

	<sect2 id="without_java_API">
		<title>Using XML descriptors</title>
		
		<sect2 id="start_scheduler_xml">
	      <title>Starting the scheduler</title>
			<para>To start a local scheduler, run the
		      <emphasis>scheduler.sh</emphasis> script in scripts/scheduler directory.
		      Without arguments, the scheduler will start on the local host and create
		      its own Resources Manager.
		    </para>
		
		    <para>
		    	<emphasis>scheduler.sh</emphasis> can be started with 2 optional
		      	arguments : <itemizedlist>
		          <listitem>
		            <para>
		            	A path (folder) containing the 2 authentication files (using the "-a PATH" option) :
		            	<itemizedlist>
			            	<listitem>
					            <para><emphasis>"login.cfg"</emphasis>: A file describing the users
			            		and their passwords authorized to connect to the scheduler. </para>
			          		</listitem>
			            	<listitem>
			            		<para><emphasis>"group.cfg"</emphasis>: A file describing the group
			           		 	on which each user belongs. These groups will be used to identify
			            		admin or user rights. </para>
			          		</listitem>
			            </itemizedlist>
		            </para>
		          </listitem>
		          <listitem>
		            <para>
		            	The URL of a resources manager already started. (ie:
		            	<emphasis role="bold">//hostname/</emphasis>)
		            </para>
		          </listitem>
		        </itemizedlist>
		   	</para>
		   	<para>
		   		For example, the following line will launch a scheduler with a local resource manager and
		   		a personal path for the authentication files :
		   		<itemizedlist>
		   			<listitem>
		   				./scheduler.sh -a /user/home/scheduler/authFiles/ //localhost/
		   			</listitem>
		   		</itemizedlist>
		   		The path "/user/home/scheduler/authFiles/" have to contain the two authentication files.
		   	</para>
		   	<para>
		   		It is also possible to launch the scheduler with only one of the options or no option.
		   		No option will start a local scheduler by creating a new local resource manager with default node description.
		   	</para>
		</sect2>
		
		<sect2 id="communicator">
	        <title>The Scheduler Shell Communicator</title>
			<para>
				The shell communicator is a shell interface that allow a user to administer the scheduler
				without the java API.
			To start a communicator, run the
		      <emphasis>communicator.sh</emphasis> script in scripts/scheduler directory.
		      Without arguments, the communicator will try to connect a scheduler on the local host.
		      Note that the communicator uses an administrator to allow the connection to the scheduler.
		    </para>
		
		    <para>
		    	<emphasis>communicator.sh</emphasis> can be started with 2 mandatory arguments and 1
		    	optional : <itemizedlist>
		          <listitem>
		            <para>
		            	The username of the one who wants to connect. (must be in login.cfg file)
		            	For the communicator, the user must be admin group. (in group.cfg file)
		            </para>
		          </listitem>
		          <listitem>
		            <para>
		            	The password corresponding to the username. (must be in login.cfg file as well) 
		            </para>
		          </listitem>
		          <listitem>
		            <para>
		            	The URL of a started scheduler. (ie:
		            	<emphasis role="bold">//hostname/</emphasis>)
		            </para>
		          </listitem>
		        </itemizedlist>
		   	</para>
		   	
	        <para>
	        	Here's an overview of the shell communicator :
	        	<figure id="communicator_shell">
			        <title>The shell communicator</title>
			
			        <mediaobject>
			          <imageobject>
			            <imagedata align="center"
			                       fileref="scheduler/pics/core/communicator.png"
			                       format="PNG" />
			          </imageobject>
			        </mediaobject>
		      </figure>
	        </para>
	    </sect2>
	    
	    <sect2 id="Create_a_job_xml">
	    	<title>Create a job</title>
	    	
	    	<para>
	    		A job can be created using an XML descriptor. You may have to create your own executable as 
	    		describe in the section <xref linkend="define_executable" /> in order to run your own task.
	    		Next step if you don't want to use the scheduler java API is to write the descriptor of your
	    		job. This last could be launch using the <emphasis>jobLauncher.sh</emphasis> script.
	    		This script must be launched with the first parameter and optionally the others. The parameters
	    		are :
	    		<orderedlist>
	    			<listitem>
	    				<emphasis>The job descriptor</emphasis> : it is the XML file describing your job.
	    			</listitem>
	    			<listitem>
	    				<emphasis>The number of this job to submit</emphasis> : it is the number of time you want to submit this job.
	    			</listitem>
	    			<listitem>
	    				<emphasis>The URL of the scheduler</emphasis> : it is the URL of a started ProActive scheduler.
	    			</listitem>
	    		</orderedlist>
	    		<para>
	    			For example : <emphasis>./jobLauncher.sh ../../../descriptors/scheduler/jobs/Job_with_dep.xml 1 //localhost/</emphasis> will
	    			submit one time the Job_with_dep job to a local scheduler.
	    		</para>
	    		<para>
	    			Let's see how to create a job using the XML description.
	    		</para>
	    	</para>
	    	
	    	<sect3 id="create_proactive_job">
	    		<title>Create a ProActive Job</title>
	    		
	    		Here's the details to create a ProActive job using an XML descriptor :
	    		
	    		<para>
	    			<screen>
	&lt;?xml version="1.0" encoding="UTF-8"?&gt;
	&lt;job xmlns="urn:proactive:jobdescriptor:0.9" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="urn:proactive:jobdescriptor:0.9 http://proactive.inria.fr/schemas/jobdescriptor/0.9/schedulerjob.xsd"
		name="job_proActive" priority="low"&gt;
					</screen>
					<para>
					The job tag can define :
					<itemizedlist>
						<listitem>
							<emphasis>name</emphasis> : any string that define the job. (see <xref linkend="task_creation" /> for details)
						</listitem>
						<listitem>
							<emphasis>priority</emphasis> : the scheduling priority of the job. Values can be : 'highest', 'high', 'normal', 'low', 'lowest'.
							(see <xref linkend="task_creation" /> for details)
						</listitem>
						<listitem>
							<emphasis>cancelOnException</emphasis> : is a way to define if your job will continue
		      				if a user exception or error occurs during the whole job process. (see <xref linkend="task_creation" /> for details)
		      				 Values can be 'true' or 'false'.
						</listitem>
						<listitem>
							<emphasis>logFile</emphasis> : is the path of an optional log file. Set it if you want
		      				to save the job generated log in a file. (see <xref linkend="task_creation" /> for details)
						</listitem>
					</itemizedlist>
					</para>
					<para>
						It is possible to add a description of the job as shown below :
					</para>
					<screen>
		&lt;description&gt;
			A ProActive job that will find out the Nth first prime number where N is given as argument.
		&lt;/description&gt;
					</screen>
					<para>
					In addition it is possible to define variables that can be use in the descriptor.
					</para>
					<screen>
		&lt;variables&gt;
			&lt;variable name="FOO" value="foo"/&gt;
			...
		&lt;/variables&gt;
					</screen>
					<para>
						To use the define variable(s), just insert it(them) in the descriptor like that : <emphasis>${FOO}</emphasis>
					</para>
					<para>
						Let's start with the declaration of the job. The proActive tags define the type of the job.
					</para>
					<screen>
		&lt;proActive neededNodes="5"&gt;
					</screen>
					<para>
						The number of needed nodes define how many nodes you need for your ProActive executable.
						In this example, 5 needed nodes means that you want to use 4 nodes in your executable.
		      			Indeed, one node will be used to start your executable, and the other are given to your
		      			application.
					</para>
					<para>
						Next step is to add one ProActive task on which it is possible to attach a description.
					</para>						
					<screen>
			&lt;task name="Controller"&gt;
				&lt;description&gt;Will control the workers in order to find the prime number&lt;/description&gt;
					</screen>
					<para>
						As in the job, it is mandatory to add a textual name to the task. It will be a way to 
						identify it. A second optional parameter can be added in order to define the number of times
						the task is allowed to restart.
						<itemizedlist>
							<listitem>
								<emphasis>retries</emphasis> is a way to define how many times a task will be
				      			reran if a user or network problems occur. Set this value to <emphasis>n</emphasis> if you want the task
				      			to be restarted <emphasis>n</emphasis> times and, so, started a maximum of <emphasis>n+1</emphasis> times.
				      			(default is 1)
							</listitem>
						</itemizedlist>
					</para>
					<para>
						Then the user has to set the ProActive executable that will be launched when the job will be scheduled.
						Some initialization parameters can be set and will be automatically send to the task in the <emphasis>init</emphasis> method
						in the executable. This optional method allow the user to initialize its task with this parameters.
						Proceed as describe below to do such a thing :
					</para>
					<screen>
				&lt;proActiveExecutable
					class="org.objectweb.proactive.extensions.scheduler.examples.ProActiveExample"&gt;
					&lt;parameters&gt;
						&lt;parameter name="numberToFind" value="200"/&gt;
					&lt;/parameters&gt;
				&lt;/proActiveExecutable&gt;
					</screen>
					<para>
						And terminate the job.
					</para>
					<screen>
			&lt;/task&gt;
		&lt;/proActive&gt;
	&lt;/job&gt;
	    			</screen>
	    		</para>
	    		<para>
	    			A ProActive job has just been created using the XML description. User may use the jobLauncher script
	    			to submit this new job.
	    		</para>
	    	</sect3>
	    	
	    	
	    	<sect3 id="create_taskflow_job">
	    		<title>Create a Task Flow Job</title>
	    		
	    		Here are the details to create a Task Flow job using an XML descriptor.
	    		This example will show how to make dependences, how to add native or java executable to the job
	    		and how the different scripts can be used. You may refers to the previous explanations if something
	    		remains unexplain in this section.
	    		<para>
	    			<screen>
	&lt;?xml version="1.0" encoding="UTF-8"?&gt;
	&lt;job xmlns="urn:proactive:jobdescriptor:0.9" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="urn:proactive:jobdescriptor:0.9 http://proactive.inria.fr/schemas/jobdescriptor/0.9/schedulerjob.xsd"
		name="job_with_dep" priority="normal"&gt;
		&lt;description&gt;Test of 8 tasks with variable durations and dependencies&lt;/description&gt;
					</screen>
					<para>
						Until this point, every features are describe above in the ProActive job creation section.
						Let's see now how to add tasks to the job and the differences between this kind of job and the ProActive one :
					</para>
					<screen>
		&lt;taskFlow&gt;
			&lt;task name="task1" retries="2"&gt;
					</screen>
					<para>
						The task tag can contains several properties :
						<itemizedlist>
							<listitem>
								<emphasis>name</emphasis> is described in <xref linkend="task_creation" />.
							</listitem>
							<listitem>
								<emphasis>retries</emphasis> is described in <xref linkend="task_creation" />.
							</listitem>
							<listitem>
								<emphasis>preciousResult</emphasis> is described in <xref linkend="task_creation" />.
								Values can be 'true' or 'false'.
							</listitem>
							<listitem>
								<emphasis>resultPreviewClass</emphasis> is described in <xref linkend="task_creation" />.
								Value is a string representing the full java class name (the doted notation).
							</listitem>
						</itemizedlist>
					</para>
					<screen>
				&lt;!-- Task human description --&gt;
				&lt;description&gt;This task will sleep 6s&lt;/description&gt;
					</screen>
						<para>
							At this point it is possible to use the 3 scripts 'selection', 'pre', and 'post'.
							There usage is explained in <xref linkend="task_creation" /> in the scripts part.
							The only thing that change in the XML notation is the first tag. Indeed, it can be
							either 'selection', 'pre' or 'post' tags.
							Let's see how to place it in the XML description :
							<screen>
				&lt;selection&gt;
					&lt;script&gt;
						&lt;file path="/path/to/a/script.js"/&gt;
					&lt;/script&gt;
				&lt;/selection&gt;
				&lt;!-- or/and --&gt;
				&lt;pre&gt;
					&lt;script&gt;
						&lt;code language="type_of_language"&gt;
						&lt;!-- Insert here the code like it would be in a file --&gt;
						&lt;code&gt;
					&lt;/script&gt;
				&lt;/pre&gt;
				&lt;!-- or/and --&gt;
				&lt;post&gt;
					&lt;script&gt;
						&lt;file path="/path/to/a/script.js"/&gt;
					&lt;/script&gt;
				&lt;/post&gt;
							</screen>
							<para>
								The <emphasis>file</emphasis> or <emphasis>code</emphasis> tag can be exclusively added
								in the <emphasis>script</emphasis> tag.
								For the <emphasis>file</emphasis> tag, the attributes can be one of the following :
								<itemizedlist>
									<listitem>
										<emphasis>path</emphasis> : the local path to a file.
									</listitem>
									<listitem>
										<emphasis>url</emphasis> : an URL to the remote script.
									</listitem>
								</itemizedlist>
								For the <emphasis>code</emphasis> tag, the type_of_language can be any language supported by the underlying JRE.
							</para>
						</para>
						<para>
							Now let's see how to add a java executable to this task :
						</para>
					<screen>
				&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.examples.WaitAndPrint"&gt;
					&lt;parameters&gt;
						&lt;parameter name="sleepTime" value="6"/&gt;
						&lt;parameter name="number" value="1"/&gt;
					&lt;/parameters&gt;
				&lt;/javaExecutable&gt;
					</screen>
						<para>
							As the ProActive job, a java executable is added to the task by using a similar tag,
							here the <emphasis>javaExecutable</emphasis> tag with a <emphasis>class</emphasis> attribute.
							This attribute must contain the java executable task class full name. The way to use parameters
							is explained in the previous ProActive job XML creation section. As a ProActive task, the parameters
							are sent to the task in the <emphasis>init</emphasis> method as an hashMap.
						</para>
						<para>
							It is also possible to add a native task under the same model but instead of having a java class
							as attribute, it is necessary to define one to the two available types of command :
							<itemizedlist>
								<listitem>
									<emphasis>staticCommand</emphasis> is a command that will be started with the given arguments.
									It can be a command or a path to a native executable. The command will be started with
									the given argument(s).
								</listitem>
								<listitem>
									<emphasis>dynamicCommand</emphasis> is a command generated by a 'generation script' (see <xref linkend="task_creation"/>).
								</listitem>
							</itemizedlist>
							Here are two examples showing how to create a native task according to this two types of command.
							<screen>
					&lt;nativeExecutable&gt;
						&lt;staticCommand
							value="command"&gt;
							&lt;arguments&gt;
								&lt;argument value="1"/&gt;
							&lt;/arguments&gt;
						&lt;/staticCommand&gt;
					&lt;/nativeExecutable&gt;
							</screen>
							<screen>
					&lt;nativeExecutable&gt;
						&lt;dynamicCommand&gt;
							&lt;generation&gt;
								&lt;script&gt;
									&lt;file url="url/to/a/script" /&gt;
								&lt;/script&gt;
							&lt;/generation&gt;
						&lt;/dynamicCommand&gt;
					&lt;/nativeExecutable&gt;
							</screen>
						</para>
						<para>
							In the second example, the script will generate a command that will be used to start
							the native task.
						</para>
						<para>
							Let's continue with the job description.
						</para>
					<screen>
			&lt;/task&gt;
			&lt;task name="task2"&gt;
				&lt;!-- Task human description --&gt;
				&lt;description&gt;This task will sleep 10s&lt;/description&gt;
				&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.examples.WaitAndPrint"&gt;
					&lt;parameters&gt;
						&lt;parameter name="sleepTime" value="10"/&gt;
						&lt;parameter name="number" value="2"/&gt;
					&lt;/parameters&gt;
				&lt;/javaExecutable&gt;
			&lt;/task&gt;
			&lt;task name="task3"&gt;
	
				&lt;!-- Task human description --&gt;
				&lt;description&gt;This task will sleep 4s&lt;/description&gt;
				&lt;depends&gt;
					&lt;task ref="task1"/&gt;
				&lt;/depends&gt;
				&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.examples.WaitAndPrint"&gt;
					&lt;parameters&gt;
						&lt;parameter name="sleepTime" value="4"/&gt;
						&lt;parameter name="number" value="3"/&gt;
					&lt;/parameters&gt;
				&lt;/javaExecutable&gt;
			&lt;/task&gt;
			&lt;task name="task4" retries="2"&gt;
				&lt;!-- Task human description --&gt;
				&lt;description&gt;This task will sleep 5s&lt;/description&gt;
					</screen>
					Last step is to define dependencies. Here's an example :
					<screen>
				&lt;depends&gt;
					&lt;task ref="task1"/&gt;
					&lt;task ref="task2"/&gt;
				&lt;/depends&gt;
					</screen>
						<para>
						The <emphasis>depends</emphasis> tag can contain one or more references to other tasks.
						This XML tags (in the example above) just means that this task ('task4') will depend of 
						'task1' and 'task2' in this order. As explain above, the task4 will wait until the end 
						of task1 and task2 to start and will receive as parameters the results of task1 and task2
						in this order (it implies that the task names are unique).
						The <emphasis>depends</emphasis> tag is optional.
						</para>
						<para>
							Each of the features described above can be repeated in as many tasks as the defined number of tasks.
						</para>
						<para>
							 Let's now finish this task flow job.
						</para>
					<screen>
				&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.examples.WaitAndPrint"&gt;
					&lt;parameters&gt;
						&lt;parameter name="sleepTime" value="5"/&gt;
						&lt;parameter name="number" value="4"/&gt;
					&lt;/parameters&gt;
				&lt;/javaExecutable&gt;
			&lt;/task&gt;
			&lt;task name="task5"&gt;
				&lt;!-- Task human description --&gt;
				&lt;description&gt;This task will sleep 2s&lt;/description&gt;
				&lt;depends&gt;
					&lt;task ref="task2"/&gt;
				&lt;/depends&gt;
				&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.examples.WaitAndPrint"&gt;
					&lt;parameters&gt;
						&lt;parameter name="sleepTime" value="2"/&gt;
						&lt;parameter name="number" value="5"/&gt;
					&lt;/parameters&gt;
				&lt;/javaExecutable&gt;
			&lt;/task&gt;
			&lt;task name="task6"&gt;
				&lt;!-- Task human description --&gt;
				&lt;description&gt;This task will sleep 8s&lt;/description&gt;
				&lt;depends&gt;
					&lt;task ref="task3"/&gt;
					&lt;task ref="task4"/&gt;
				&lt;/depends&gt;
				&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.examples.WaitAndPrint"&gt;
					&lt;parameters&gt;
						&lt;parameter name="sleepTime" value="8"/&gt;
						&lt;parameter name="number" value="6"/&gt;
					&lt;/parameters&gt;
				&lt;/javaExecutable&gt;
			&lt;/task&gt;
			&lt;task name="task7" retries="2" preciousResult="true"&gt;
				&lt;!-- Task human description --&gt;
				&lt;description&gt;This task will sleep 6s&lt;/description&gt;
				&lt;depends&gt;
					&lt;task ref="task6"/&gt;
					&lt;task ref="task4"/&gt;
					&lt;task ref="task5"/&gt;
				&lt;/depends&gt;
				&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.examples.WaitAndPrint"&gt;
					&lt;parameters&gt;
						&lt;parameter name="sleepTime" value="6"/&gt;
						&lt;parameter name="number" value="7"/&gt;
					&lt;/parameters&gt;
				&lt;/javaExecutable&gt;
			&lt;/task&gt;
			&lt;task name="task8" preciousResult="true"&gt;
				&lt;!-- Task human description --&gt;
				&lt;description&gt;This task will sleep 6s&lt;/description&gt;
				&lt;depends&gt;
					&lt;task ref="task6"/&gt;
				&lt;/depends&gt;
				&lt;javaExecutable class="org.objectweb.proactive.extensions.scheduler.examples.WaitAndPrint"&gt;
					&lt;parameters&gt;
						&lt;parameter name="sleepTime" value="6"/&gt;
						&lt;parameter name="number" value="8"/&gt;
					&lt;/parameters&gt;
				&lt;/javaExecutable&gt;
			&lt;/task&gt;
		&lt;/taskFlow&gt;
	&lt;/job&gt;
	    			</screen>
	    		</para>
	    	</sect3>
	    	<para>
	    		This conclude the job creation using XML descriptor. Let's see now how to create tasks and jobs
	    		using the java API.
	    	</para>
	    </sect2>
	    
	</sect2>
	
	<sect2 id="with_java_API">
		<title>Using the java API</title>
		
		<sect2 id="start_scheduler_API">
	      <title>Starting the scheduler</title>
	
	      <para>You can start the scheduler using the java API. Supposing
	      that a Resource Manager is already started (see Resource Manager
	      documentation <xref linkend="Resource_Manager"/>), this can be done in
	      the following way:</para>
	
	      <programlisting lang="java">AdminScheduler.createScheduler(
	    			"path/to/authentication_files/",
	                rm,
	                "org.objectweb.proactive.extra.scheduler.policy.PriorityPolicy");</programlisting>
	
	      <para>Arguments are respectively: <orderedlist>
	          <listitem>
	            <para><emphasis>Authentication files path</emphasis>: A path containing the 2
	            needed files :
	            <itemizedlist>
	            	<listitem>
			            <para><emphasis>"login.cfg"</emphasis>: A file describing the users
	            		and their passwords authorized to connect to the scheduler. </para>
	          		</listitem>
	            	<listitem>
	            		<para><emphasis>"group.cfg"</emphasis>: A file describing the group
	           		 	on which each user belongs. These groups will be used to identify
	            		admin or user rights. </para>
	          		</listitem>
	            </itemizedlist>
	            </para>
	            <para>
	            These 2 files are used to manage the security and right access into the scheduler.
	            A user can then only connect it if their username is in the login file and will check that
	            the password is corresponding.
	            </para>
	          </listitem>
	
	          <listitem>
	            <para><emphasis>rm</emphasis>: A reference on an already started
	            Resources Manager instance. </para>
	          </listitem>
	
	          <listitem>
	            <para><emphasis>policyFullClassName</emphasis> : The scheduling
	            policy to use, as a string representing the complete name of the
	            class. </para>
	          </listitem>
	        </orderedlist></para>
		
		<para>
		<emphasis role="bold">NOTE</emphasis> - A LDAP authentication module for the Scheduler will be released in ProActive 4.0. 
		</para>
	
	      <para>Another way is to start the scheduler AND connect an administrator
	      at the same time :</para>
	
	      <programlisting lang="java">AdminScheduler.createScheduler(
	   				"path/to/authentication_files/",
	                "login",
	                "password",
	                rm,
	                "org.objectweb.proactive.extra.scheduler.policy.PriorityPolicy");</programlisting>
	
	      <para>Where arguments are the same plus a <emphasis>login</emphasis> and
	      a <emphasis>password</emphasis> as a string. The user must be in the
	      login file and his group must be admin in the group file.</para>
	    </sect2>
	    
		<sect2 id="how_to_make_job">
			<title>Job Creation</title>
			<sect3 id="task_creation">
		      <title>Create task(s)</title>
		      
		      <para>
		      	As it has been said, it is possible to create 3 types of tasks. These 3 types have some
		      	common features like name, description, scripts, etc... Here's the details of each of these common features :
		      	<itemizedlist>
		      		<listitem>
		      			<emphasis>name</emphasis> is the name assigned to the task. It can be whatever you
		      			want as a String. This name must be unique for each task.
		      			<programlisting lang="java">
	aTask.setName("task 1");
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>description</emphasis> is a human readable description of the task.
		      			It is for human use only. This field is optional but it is better to set it.
		      			<programlisting lang="java">
	aTask.setDescription("This task will do something...");
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>precious result</emphasis> is the way to define that a result of a task
		      			is important or not. For example, in a job result, you could have to retrieve only
		      			some task results that are important for you. By setting the precious result to true
		      			you'll be able to retrieve easily these results. (default is false)
		      			<programlisting lang="java">
	aTask.setPreciousResult(true);
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>re-runnable</emphasis> is a way to define how many times a task will be
		      			reran if a user or network problems occur. Set this value to <emphasis>n</emphasis> if you want the task
		      			to be restarted <emphasis>n</emphasis> times and so, started a maximum of <emphasis>n+1</emphasis> times.
		      			(default is 1)
		      			<programlisting lang="java">
	aTask.setRerunnable(2);
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>result preview</emphasis> allows to specify how the result of a task should be displayed in 
		      			the Scheduler graphical client. The user should implement a result preview class (that extends <literal>org.objectweb.proactive.extensions.scheduler.common.task.ResultPreview</literal> 
		      			abstract class) which specifies result rendrering in two different manners :
		      			<itemizedlist>
		      				<listitem> a textual manner, by implementing <literal>public abstract String getTextualDescription(TaskResult result);</literal>. 
		      				This method, similarily to <literal>String Object.toString()</literal> should return a <literal>String</literal> object that describes the result;
		      				</listitem>
		      				<listitem> a graphical manner, by implementing <literal>public abstract JPanel getGraphicalDescription(TaskResult result);</literal>.
		      				This method should return a Swing <literal>JPanel</literal> object that describes the result.
		      				</listitem>
		      			</itemizedlist>
		      			Some useful methods to create a specific preview class can be found in <literal>org.objectweb.proactive.extensions.scheduler.common.task.util.ResultPreviewTool</literal>, 
		      			such as automatic display of an image file, or automatic translation between windows and unix path.
		      			<programlisting lang="java">
	aTask.setResultPreview(UserDefinedResultPreview.class);
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>scripts</emphasis>
		      			<para> The ProActive scheduler supports portable scripts execution through the JSR 223 Java Scripting 
		      			capabilities; scripts can be written in any language supported by the underlying Java Runtime Environment. 
		      			Scripts are used in the ProActive scheduler to :
		      			<itemizedlist>
		      				<listitem>Execute some simple pre and post processings: optional pre-script and post-script 
		      			</listitem>
		      			<listitem>Select among available resources the node that suitable for the execution: optional selection-script can 
		      			be associated to a task.</listitem>
		      			<listitem>Dynamic building of a command line for a native task: optional generation-script (detailled in next section).</listitem>
		      			</itemizedlist>
		      			Here are some details and examples:
		      			</para>
		      			<itemizedlist>
		      				<listitem>
		      					<emphasis>pre-script</emphasis> The pre-script is always executed on the node that has been selected by
		      					the resource manager <emphasis>before</emphasis> the execution of the task itself.
		      					<programlisting lang="java">
	//If the script to use is in a file or URL
	String[] args = new String("foo","bar");
	File scriptFile = new File("path/to/script_file");
	// File scriptURL = new URL("url/to/script_file");
	Script script = new SimpleScript(scriptFile, args);
	// Script script = new SimpleScript(scriptURL, args);
	aTask.setPreScript(script);
	//If the script to use is in a java string for example
	Script script = new SimpleScript("Script_content", "type_of_language");
	//where type_of_language can be any language supported by the underlying JRE
	aTask.setPreScript(script);
		      					</programlisting>
		      				</listitem>
		      				<listitem>
		      					<emphasis>post-script</emphasis> The pre-script is always executed on the node that has been selected by
		      					the resource manager <emphasis>after</emphasis> the execution of the task itself.
		      					<programlisting lang="java">
	//same construction for the script
	aTask.setPostScript(script);
		      					</programlisting>
		      				</listitem>
		      				<listitem>
		      					<emphasis>selection script</emphasis> The selection script is always executed before the task itself on any candidate node:
		      					the execution of a selection script must set the boolean variable <literal>selected</literal>, that indicates if the candidate node
		      					is suitable for the execution of the associated task.
		      					<programlisting lang="java">
	//same construction for the script
	//the last parameter is still not used in the current implementation
	SelectionScript selScript = new SelectionScript(script, true);
	aTask.setSelectionScript(selScript);
		      					</programlisting>
		      				</listitem>
		      			</itemizedlist>
		      		</listitem>
		      	</itemizedlist>
		      	
		      	<para>The following explains how to create a specific kind of task :</para>
		      	<itemizedlist>
		      		<listitem>
		      			<para>
		      			<emphasis>Create a native task</emphasis> is the simplest thing to do.
		      			Use the <emphasis>NativeTask</emphasis> class to create such a task.
		      			You just have then to specify a command line that have to be executed by the scheduler.
		      			Here's an example that describe how to create a native task with a <emphasis>static command</emphasis> :
		      			<programlisting lang="java">
	//create a new native task
	NativeTask task1 = new NativeTask();
	//set the command to execute as a string
	task1.setCommandLine("ls -al");
		      			</programlisting>
		      			</para>
		      			<para>
		      				Here's an example that describe how to create a native task with a <emphasis>dynamic command</emphasis>
		      				, i.e. generated by a script called a generation script, The generation script can only be associated to a <emphasis>native</emphasis> task: 
		      				the execution of a selection script must set the string variable <literal>command</literal>. The value of this variable is the command
		      					line that will be executed by the Scheduler as task execution.
		      				<programlisting lang="java">
	//create a new native task
	NativeTask task2 = new NativeTask();
	//create a generation script with a script as shown above
    GenerationScript gscript = new GenerationScript(script);
	//set the command to execute as a string
	task2.setGenerationScript(gscript);
		      				</programlisting>
		      			</para>
		      		</listitem>
		      		<listitem>
		      			<para>
		      			<emphasis>Create a java task</emphasis> is not much more difficult.
		      			Use the <emphasis>JavaTask</emphasis> class to create this type of task.
		      			In this type, you must specify the class you want to start with, by mentioning
		      			a Class or an instance of your executable. (To make your own executable see
		      			the proper section <xref linkend="define_executable" />). In addition, you can add
		      			arguments with which the task will be launched. These launching arguments will
		      			be given to the java executable as a Map.
		      			<programlisting lang="java">
	//create a new java task
	JavaTask task3 = new JavaTask();
	//add arguments (optional)
	task3.addArgument("foo",new Boolean(true));
	task3.addArgument("bar",new Integer(12));
	task3.addArgument("test","test1");
	//add executable class or instance
	task3.setTaskClass(WaitAndPrint.class);
	// or
	//task3.setTaskInstance(new WaitAndPrint());
		      			</programlisting>
		      			</para>
		      		</listitem>
		      	</itemizedlist>
		      </para>
		      <para>
		      	For both native and java task, you can specify dependences between each other 
		      	<emphasis role="bold">(but not for ProActive task)</emphasis>.
		      	To perform such a thing, and following the example shown in the dependencies explanation
		      	(<xref linkend="how_dependences" />), let's see an example illustrating how to make task 5
		      	depends of 2 and 3 in this order :
		      	<programlisting lang="java">
	//task 2 has been create just before as a native task
	//task 3 has been create just before as a java task
	//we have to create task 5.
	//create a new native or java task
	JavaTask task5 = new JavaTask();
	//... (fill task5 as describe above)
	//then specify dependencies by using the addDependence(Task) method
	task5.addDependence(task2);
	task5.addDependence(task3);
	//or use the addDependences(list&lt;Task&gt;) method as shown
	//task5.addDependences(new ArrayList&lt;Task&gt;(task2,task3));
		      	</programlisting>
		      </para>
		      
		      <para>
		      	<itemizedlist>
		      		<listitem>
		      			<para>
		      				<emphasis>Create a ProActive task</emphasis> is a bit different. Indeed, it is
		      				not possible to add dependences to this task. This task is design for the
		      				ProActive job. Like the java task, arguments can be set in order to be used
		      				at the start of the task. The corresponding executable is attach to the task
		      				using the same methods as java task. Finally, you must specify the number of needed
		      				nodes for the ProActive task. This is the list of nodes you will receive in the
		      				<emphasis>execute(nodeList)</emphasis> method in the ProActive executable.
		      				See <xref linkend="define_executable" /> to make your own ProActive executable.
		      				<programlisting lang="java">
	//create the ProActive task
	ProActiveTask aPATask = new ProActiveTask();
	//add dependencies... (see java task)
	//add task instance or class... (see java task)
	//set number of needed nodes
	aPATask.setNumberOfNodesNeeded(8);
		      				</programlisting>
		      			</para>
		      			In this example, 8 needed nodes means that you want to use 7 nodes in your executable.
		      			Indeed, one node will be used to start your executable, and the other are given to your
		      			application.
		      		</listitem>
		      	</itemizedlist>
		      </para>
		      <para>
		      	Now that you know how to define tasks, let's see how to make your job.
		      </para>
		    </sect3>
		
		    <sect3 id="job_creation">
		      <title>Create Job</title>
		      
		      <para>
		      	It is possible to create two types of job. As it was the case for the tasks, jobs have some
		      	common features :
		      	<itemizedlist>
		      		<listitem>
		      			<emphasis>id</emphasis> is a way to identify your job, you cannot set it but the 
		      			scheduler will send you back the id associated to your job as soon as it is submit.
		      			It will permit you to ask for services about your job.
		      		</listitem>
		      		<listitem>
		      			<emphasis>description</emphasis> is a human readable description of the job.
		      			It is for human use only. This field is optional but it is better to set it.
		      			<programlisting lang="java">
	aJob.setDescription("This job will do something...");
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>name</emphasis> is the name of your job as a string.
		      			<programlisting lang="java">
	aJob.setName("a name");
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>Log file</emphasis> is the path of an optional log file. Set it if you want
		      			to save the job generated log in a file.
		      			<programlisting lang="java">
	aJob.setLogFile("path/to/log_file");
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>priority</emphasis> is the scheduling priority level for your job.
		      			<programlisting lang="java">
	aJob.setPriority(JobPriority.NORMAL);
		      			</programlisting>
		      		</listitem>
		      		<listitem>
		      			<emphasis>Cancel on Error</emphasis> is a way to define if your job will continue
		      			if a user exception or error occurs during the whole job process.
		      			It means that if the value of this property is true, the job will stop immediately
		      			every running task if one error occurs in one of the task of this job. It will have
		      			the consequence to failed the job, but free resources for other jobs. It is useful
		      			when it has no interest to continue after a task failure.
		      			<programlisting lang="java">
	aJob.setCancelOnError(true);
		      			</programlisting>
		      		</listitem>
		      	</itemizedlist>
		      </para>
		      <para>
		      	Let's see in details how to build the different job :
		      	<itemizedlist>
		      		<listitem>
		      			<emphasis>The TaskFlowJob</emphasis> or data flow job is a job that can contain
		      			one or more task(s) with the dependencies you want. To make this type of job,
		      			just use the default no arg constructor, and set the properties you want to set.
						Then add tasks with the given method addTask(Task) in order to fill the job with
						your own tasks. Here's the step to create your task flow job :
						<programlisting lang="java">
	//your tasks has already been created as seen in previous sections
	//create a task flow job
	TaskFlowJob job = new TaskFlowJob();
	//fill the job...
	job.setName("task flow job 1");
	job.setPriority(JobPriority.NORMAL);
	//...
	//add your tasks (java or native task created in the previous sections)
	job.addTask(task1);
	job.addTasks(new ArrayList&lt;Task&gt;(task2,task3,task5));
	//that's it.
						</programlisting>
						<para>
							You may now be able to create a task flow job that can contains native or java tasks.
							See <xref linkend="Job_submission" /> to learn how to submit a job to the scheduler.
						</para>
		      		</listitem>
		      		<listitem>
		      			<emphasis>The ProActiveJob</emphasis> is a job that contains one task that has a list
		      			of nodes in its argument list. To make this type of job, just use the default no argument
		      			constructor, and set the properties you want to set.
		      			In this job, you must set the only ProActive task that will be inside this job.
						<programlisting lang="java">
	//your ProActive task has already been created in previous section
	//create a ProActive job
	ProActiveJob job = new ProActiveJob();
	//fill the job...
	job.setName("ProActive job 1");
	job.setPriority(JobPriority.LOW);
	//...
	//add the task (ProActive task created in the previous section)
	job.addTask(aPATask);
						</programlisting>
						<para>
							Here's your first ProActive job.
							See <xref linkend="Job_submission" /> to learn how to submit a job to the scheduler.
						</para>
		      		</listitem>
		      	</itemizedlist>
		      </para>
		    </sect3>
		</sect2>
	
	    <sect2 id="user_interface">
	      <title>User Interface</title>
			
	      <sect3 id="User_Connection">
	        <title>User Connection</title>
	
	        <para>A user can connect to the Scheduler only if he/she is known.
	        That's the goal of the authentication interface which is able to
	        authenticate users. <xref linkend="userConnection">
	            The user connection
	          </xref> shows how the Scheduler connects a user. <figure
	            id="userConnection">
	            <title>A user connection</title>
	
	            <mediaobject>
	              <imageobject>
	                <imagedata align="center"
	                           fileref="scheduler/pics/core/userConnection.jpg"
	                           format="JPG" />
	              </imageobject>
	            </mediaobject>
	          </figure> <orderedlist>
	            <listitem>
	              <para>First of all, a user tries to join the authentication
	              interface using the <emphasis
	              role="bold">SchedulerConnection.join(...)</emphasis> static
	              method. </para>
	
	              <programlisting lang="java">SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/SCHEDULER_OBJECT_NAME");</programlisting>
	
	              <para> Then, with the <emphasis
	              role="bold">SchedulerAuthenticationInterface</emphasis>, users
	              can be connected as user or administrator roles using the
	              <emphasis role="bold">logAsUser</emphasis> or <emphasis
	              role="bold">logAsAdmin</emphasis> methods. </para>
	
	              <programlisting lang="java">UserSchedulerInterface scheduler = auth.logAsUser("username", "password");
	// OR
	AdminSchedulerInterface scheduler = auth.logAsAdmin("adminname", "password");</programlisting>
	            </listitem>
	
	            <listitem>
	              <para>Next, the authentication object checks the users rights
	              and wether the user is authorized to connect the scheduler. If
	              not, an exception will be thrown.</para>
	            </listitem>
	
	            <listitem>
	              <para>Once connected, the authentication object sends the right
	              and username/password to the scheduler front-end which will be
	              able to authenticate user on its own.</para>
	            </listitem>
	
	            <listitem>
	              <para>If nothing goes wrong, the authentication interface will
	              return a <emphasis
	              role="bold">AdminSchedulerInterface</emphasis> which is in fact
	              a direct link to the <emphasis
	              role="bold">Front-end</emphasis>.</para>
	            </listitem>
	
	            <listitem>
	              <para>The user is now able to interact with the Scheduler using
	              the returned interface.</para>
	            </listitem>
	          </orderedlist></para>
	      </sect3>
	
	      <sect3 id="Job_submission">
	        <title>Job Submission</title>
	
	        <para>After the connection, a user is ready to submit Jobs. The
	        <emphasis role="bold">Authentication interface is no longer
	        used</emphasis> for this connected user. <xref linkend="jobSubmission">
	            The job submission
	          </xref> shows what happens when the Scheduler received a new Job to
	        schedule. <figure id="jobSubmission">
	            <title>A job submission</title>
	
	            <mediaobject>
	              <imageobject>
	                <imagedata align="center"
	                           fileref="scheduler/pics/core/jobSubmission.jpg"
	                           format="JPG" />
	              </imageobject>
	            </mediaobject>
	          </figure> <orderedlist>
	            <listitem>
	              <para>First, the user submits a Job using his <emphasis
	              role="bold">UserSchedulerInterface</emphasis> retrieved by the
	              <emphasis role="bold">logAsUser</emphasis> method.
	              <programlisting lang="java">// connecting to the scheduler
	SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/SCHEDULER_OBJECT_NAME");
	// checking username and password
	UserSchedulerInterface scheduler = auth.logAsUser("username", "password");
	// submitting a new job and get the associated id
	JobId myJobId = scheduler.submit(job);</programlisting></para>
	            </listitem>
	
	            <listitem>
	              <para>The Scheduler Front-end verifies the integrity of the Job,
	              and builds it in order to be ready to be managed by the
	              Scheduler Core. If there is a problem, an exception is thrown
	              explaining what is the cause.</para>
	            </listitem>
	
	            <listitem>
	              <para>Finally, the Job is transmitted to the Core for
	              scheduling.</para>
	            </listitem>
	          </orderedlist></para>
	          <para>
	          To submit a job using a command line, use the <emphasis role="bold">jobLauncher.sh</emphasis> script
	          in the script/[os]/scheduler directory. This can be used as follow :
	          <itemizedlist>
	          	<listitem>
	          		./jobLauncher username password schedulerURL path/to/a/job.xml nb_of_jobs_to_submit
	          		(ie : <emphasis>./jobLauncher usr pwd //localhost/ job_2_task.xml 1</emphasis>)
	          	</listitem>
	          </itemizedlist>
	          </para>
	      </sect3>
	      
	      <sect3 id="get_job_result">
	        <title>Getting the result of a job</title>
	
	        <para>
	        	You may have to retrieve the result of a job. It is possible by using the
	        	<emphasis role="bold">getJobResult(JobId)</emphasis> method in the
	        	<emphasis role="bold">UserSchedulerInterface</emphasis>.
	        	A job result is in fact a list of task result ordered in three lists :
	        	<itemizedlist>
	        		<listitem>
	        			A failed list that contains every result or exception returned by a task that failed.
	        		</listitem>
	        		<listitem>
	        			A full list that contains every result or exception of every tasks.
	        		</listitem>
	        		<listitem>
	        			And A precious result list that contains every result or exception returned by the task marked precious.
	        		</listitem>
	        	</itemizedlist>
	        	<para>
	        		This result will be given to you exactly like you returned it in your executable.
	        		You can only get the result of your job if you are a user and every job if your are
	        		an administrator. To know when a job that you have submitted has finished its execution,
	        		you can subscribe to the scheduler to be notified of some events. This will be explain
	        		in the next section.
	        	</para>
	        	<programlisting lang="java">
	// get the user interface
	// UserSchedulerInterface scheduler = auth.logAsUser("username", "password");
	JobResult myResult = scheduler.getJobResult(myJobId);
	        	</programlisting>
	        </para>
	        <para>
	          To get the result of a job using a command line, use the <emphasis role="bold">getResult.sh</emphasis> script
	          in the script/[os]/scheduler directory. This can be used as follow :
	          <itemizedlist>
	          	<listitem>
	          		./getResult username password schedulerURL
	          		(ie : <emphasis>./getResult usr pwd //localhost/</emphasis>)
	          	</listitem>
	          </itemizedlist>
	          It will print the result on the screen as the toString() java method could have done it.
	          </para>
	      </sect3>
	      
	      <sect3 id="add_listener">
	        <title>Get a listener on the scheduler activity</title>
	
	        <para>
	        	In order to be notified about the scheduler activities, you can add a scheduler listener that
	        	will inform you of some events, like job submitting, job or task finished, scheduling state changing, etc...
	        	To add a listener, just make your listener by implementing the <emphasis>SchedulerEventListener</emphasis> interface
	        	and add it to the scheduler.
	        	You will then receive the scheduler initial state containing some informations about the current
	        	scheduling. See the javadoc for more details.
	        	<programlisting lang="java">
	//make your listener
	SchedulerEventListener MySchedulerEventListener = new SchedulerEventListener () {
		public void jobRunningToFinishedEvent(JobEvent event){
			//if my job is finished
			if (event.getJobId().equals(myJobId)){
				//get its result
				JobResult myResult = scheduler.getJobResult(myJobId);
			}
		}
		//Implement other methods...
	}
	//add the listener to the scheduler
	scheduler.addSchedulerEventListener(MySchedulerEventListener, SchedulerEvent.JOB_RUNNING_TO_FINISHED);
	        	</programlisting>
	        	<para>
	        		This example shows you how to listen to the scheduler events (here the finished job event only).
	        		But you can listen for every events you want containing in this interface.
	        	</para>
	        	<para>
	        		For more details and features on the user scheduler interface, please refer to the java Documentation.
	        	</para>
	        </para>
	      </sect3>
	      
	    </sect2>
	
	    <sect2 id="admin_interface">
	      <title>Administrator Interface</title>
	
	      <para>
	      	The administrator can do more with its interface, see the javadoc for more details and features.
	      	He can also change the policy during the scheduling, that will consequently change the remaining
	      	scheduling order. Refer to the <xref linkend="add_policy" /> section to make your own policy and change
	      	it as shown below :
	      	<programlisting lang="java">
	//scheduler is the AdminSchedulerInterface returned in the previous sections
	scheduler.changePolicy(full.name.of.MyPolicy);
	      	</programlisting>
	      </para>
	    </sect2>
	</sect2>
	
    
  </sect1>

  <sect1 id="scheduler_extension">
    <title>Extend the Scheduler</title>

    <sect2 id="add_policy">
      <title>How to add a new policy</title>

      <para>Create and add a new scheduling policy remains a very simple work.
      You just have to implements the
      <emphasis>org.objectweb.proactive.extra.scheduler.policy.PolicyInterface</emphasis>
      and start a new Scheduler with this new policy, or dynamically change it
      if the scheduler is already running.</para>

      <para>Here's the interface which must be implemented. The default
      implementation <emphasis>PriorityPolicy</emphasis> in the same
      package:</para>

      <programlisting lang="java">public interface PolicyInterface extends Serializable {
    //method to implement
    Vector&lt;EligibleTaskDescriptor&gt; getOrderedTasks(List&lt;JobDescriptor&gt; jobs);  
}</programlisting>

      <para>This method returns all the Tasks that have to be scheduled. The
      Tasks must be in the desired scheduling order. The first task to be
      scheduled will be the first in the returned Vector.</para>

      <para>The parameters is a list of running and pendingJobs, which contain
      Tasks to be scheduled. The only thing to do is <emphasis>extract the
      task</emphasis>, <emphasis>re-order them</emphasis> and <emphasis>put
      them in a vector</emphasis>. Let's see the default implementation of the
      ProActive Scheduler policy to illustrate it:</para>

      <programlisting lang="java">public class PriorityPolicy implements PolicyInterface {

    /**
     * This method return the tasks using FIFO policy according to the jobs priorities.
     *
     * @see org.objectweb.proactive.extra.scheduler.policy.PolicyInterface#getReadyTasks(java.util.List)
     */
    @Override
    public Vector&lt;EligibleTaskDescriptor&gt; getOrderedTasks(
        List&lt;JobDescriptor&gt; jobs) {
        Vector&lt;EligibleTaskDescriptor&gt; toReturn = new Vector&lt;EligibleTaskDescriptor&gt;();
        //sort jobs by priority
        Collections.sort(jobs);

        for (JobDescriptor lj : jobs) {
            toReturn.addAll(lj.getEligibleTasks());
        }

        return toReturn;
    }
}</programlisting>

      <para>By default, the Jobs knows how to be sorted regarding their
      priority. But it is simple to create a Comparator and sort the Jobs with
      it.</para>
    </sect2>
  </sect1>
  
  
  
  <sect1 id="Scheduler_Eclipse_Plugin">

    <title>Scheduler Eclipse plugin</title>


    <para>
        <emphasis role="bold">The Scheduler Eclipse Plugin</emphasis>
        is a
        <emphasis role="bold">graphical client</emphasis>
        for remote monitoring and control of the ProActive
        Scheduler (see <xref linkend="ProActive_Scheduler"/>), including remote
        submission of XML-defined jobs (see <xref linkend="Create_a_job_xml"/>).
    </para>
    <para>
        The Scheduler Eclipse Plugin is available in two forms :
    </para>
    <itemizedlist>
        <listitem>
            <para>
                A
                <emphasis role="bold">
                    Java stand alone application
                </emphasis>
                based on
                <ulink
                    url="http://wiki.eclipse.org/index.php/Rich_Client_Platform">
                    Eclipse Rich Client Platform (RCP)
                </ulink>
                , available for any platform (Windows, Linux, Mac OSX,
                Solaris, ...)
            </para>
        </listitem>
        <listitem>
            <para>
                A set of
                <emphasis role="bold">
                    <ulink url="http://www.eclipse.org">Eclipse</ulink>
                    plugins
                </emphasis>
                : with all the functionalities within the stand alone
                application, enhanced with a tool that makes easier the
                scheduling and monitoring of jobs and applications.
            </para>
        </listitem>
    </itemizedlist>

    <!-- ************************************************************************************ -->

    <sect2 id="Scheduler_Plugin">
        <title>The Scheduler perspective</title>

        <para>
            The Scheduler plugin provides the
            <emphasis role="bold">
                Scheduler
                <ulink
                    url="http://help.eclipse.org/help31/index.jsp?topic=/org.eclipse.platform.doc.user/gettingStarted/qs-43.htm">
                    perspective
                </ulink>
            </emphasis>
            displayed in the
            <xref linkend="schedulerPerspective" />
            .
        </para>

        <para>
            This perspective defines the following set of
            <ulink
                url="http://wiki.eclipse.org/index.php/FAQ_What_is_a_view%3F">
                views
            </ulink>
            :
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    The
                    <emphasis role="bold">Jobs</emphasis>
                    view: shows pending, running and finished jobs in
                    the scheduler.
                </para>
            </listitem>
            <listitem>
                <para>
                    The
                    <emphasis role="bold">Console</emphasis>
                    view: shows jobs standard and error output (on
                    demand).
                </para>
            </listitem>
            <listitem>
                <para>
                    The
                    <emphasis role="bold">Tasks</emphasis>
                    view: displays detailled informations on tasks
                    contained in the selected job.
                </para>
            </listitem>
            <listitem>
                <para>
                    The
                    <emphasis role="bold">Jobs Info</emphasis>
                    view: displays all informations of the selected job.
                </para>
            </listitem>
            <listitem>
                <para>
                    The
                    <emphasis role="bold">Result Preview</emphasis>
                    view: displays a textual or graphical preview of the
                    result of the selected task.
                </para>
            </listitem>
        </itemizedlist>

        <figure id="schedulerPerspective">
            <title>The Scheduler Perspective</title>
            <mediaobject>
                <imageobject>
                    <imagedata
                        fileref="scheduler/pics/eclipse_plugin/schedulerPerspective.png"
                        format="PNG" />
                </imageobject>
            </mediaobject>
        </figure>

    </sect2><!-- The Scheduler perspective -->

    <sect2>
        <title>Views composing the perspective</title>

        <figure id="jobsView">
            <title>The Jobs view</title>
            <mediaobject>
                <imageobject>
                    <imagedata
                        fileref="scheduler/pics/eclipse_plugin/jobsView.png"
                        format="PNG" />
                </imageobject>
            </mediaobject>
        </figure>
        <para>
            All buttons (on upper right) are describe in the
            <xref linkend="schedulerPerspectiveButtons" />
        </para>
        <para>
            This view is composed of 3 tables which represents pending,
            running and finished jobs. In each table you can watch many
            different informations about jobs, as their state, their
            name, their id...
        </para>

        <figure id="consoleView">
            <title>The Console view</title>
            <mediaobject>
                <imageobject>
                    <imagedata
                        fileref="scheduler/pics/eclipse_plugin/consoleView.png"
                        format="PNG" />
                </imageobject>
            </mediaobject>
        </figure>
        <para>This view displays all jobs standard and error output (only on
                    demand).</para>

        <figure id="tasksView">
            <title>The Tasks view</title>
            <mediaobject>
                <imageobject>
                    <imagedata
                        fileref="scheduler/pics/eclipse_plugin/tasksView.png"
                        format="PNG" />
                </imageobject>
            </mediaobject>
        </figure>
        <para>This view provides many informations on tasks composing a job as :
        <itemizedlist>
        	<listitem>
            	The task id
            </listitem>
        	<listitem>
            	The task state
            </listitem>
        	<listitem>
            	The task name
            </listitem>
        	<listitem>
            	The host name which execute the task
            </listitem>
        	<listitem>
            	The task started time
            </listitem>
        	<listitem>
            	The task finished time
            </listitem>
        	<listitem>
            	In the column "Re-runnable", the first number represents how many times the task was re-executed, and the second number how many times the task can be re-executed
            </listitem>
        	<listitem>
            	The description of the task
            </listitem>
        </itemizedlist></para>

        <figure id="jobInfoView">
            <title>The Job Info view</title>
            <mediaobject>
                <imageobject>
                    <imagedata
                        fileref="scheduler/pics/eclipse_plugin/jobInfoView.png"
                        format="PNG" />
                </imageobject>
            </mediaobject>
        </figure>
        <para>This view provides many informations on the selected job as :
        <itemizedlist>
        	<listitem>
            	The job id
            </listitem>
        	<listitem>
            	The job state
            </listitem>
        	<listitem>
            	The job name
            </listitem>
        	<listitem>
            	The job priority
            </listitem>
        	<listitem>
            	The number of pending task
            </listitem>
        	<listitem>
            	The number of running task
            </listitem>
        	<listitem>
            	The number of finished task
            </listitem>
        	<listitem>
            	The number of task composing the job
            </listitem>
        	<listitem>
            	The job submitted time
            </listitem>
        	<listitem>
            	The job started time
            </listitem>
        	<listitem>
            	The job finished time
            </listitem>
        	<listitem>
            	The description of the job
            </listitem>
        </itemizedlist></para>

        <figure id="resultPreviewView">
            <title>The Result Preview view</title>
            <mediaobject>
                <imageobject>
                    <imagedata
                        fileref="scheduler/pics/eclipse_plugin/resultPreviewView.png"
                        format="PNG" />
                </imageobject>
            </mediaobject>
        </figure>
        <para>This view display the result of the selected task (in task view), according to the ResultPreview field (see <xref linkend="task_creation"/> </para>
    </sect2>

    <sect2>

        <title>Connect to the started ProActive Scheduler</title>

        <para>
            In order to establish a connection to the ProActive Scheduler:
        </para>

        <orderedlist>
            <listitem>
                <para>
                    open the Scheduler Perspective:
                    <emphasis role="bold">
                        Window->Open Perspective->Other...->Scheduler
                    </emphasis>
                    (it could be already opened as it is the default
                    perspective).
                </para>
            </listitem>
            <listitem>
                <para>
                    select
                    <emphasis role="bold">
                        "Connect to the ProActive scheduler" in the Scheduler menu
                        or in the contextual menu (right click)
                    </emphasis>
                    , it opens the "Connect to the ProActive scheduler" dialog
                    displayed in the
                    <xref linkend="connectToSchedulerDialog" />
                    .
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">
                        enter informations required
                    </emphasis>
                    about the remote scheduler, and click
                    <emphasis role="bold">OK</emphasis>
                    .
                </para>
            </listitem>

            <para>
                note: If you check "log as admin" in the previous dialogue, if the ProActive scheduler accept your connection,
                you'll be able to do more actions than an "simple" user (see <xref linkend="admin_mode"/>).
            </para>

        </orderedlist>


        <figure id="connectToSchedulerDialog">
            <title>Connect to scheduler</title>
            <mediaobject>
                <imageobject>
                    <imagedata
                        fileref="scheduler/pics/eclipse_plugin/connectToSchedulerDialog.png"
                        format="PNG" />
                </imageobject>
            </mediaobject>
        </figure>

    </sect2><!-- Connect to a started scheduler -->

    <sect2>
        <title id="schedulerPerspectiveButtons">The Scheduler perspective buttons</title>
        <sect3>
            <title>The Jobs view buttons in User Mode</title>

            <figure id="connectToSchedulerButton">
                <title>Connect to scheduler</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/connectToSchedulerButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                Display the "Connect to scheduler" dialog in order to
                establish a connection to a remote ProActive scheduler.
            </para>

            <figure id="disconnectToSchedulerButton">
                <title>Disconnect from the scheduler</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/disconnectToSchedulerButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>

            <figure id="changeViewVTHModeButton">
                <title>
                    Change view from Vertical to Horizontal mode
                </title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/changeViewVTHModeButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                Allows to switch the job's display to Horizontal from
                Vertical mode.
            </para>

            <figure id="changeViewHTVModeButton">
                <title>
                    Change view from Horizontal to Vertical mode
                </title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/changeViewHTVModeButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                Allows to switch the job's display from Horizontal to
                Vertical mode.
            </para>

            <figure id="submitJobButton">
                <title>Submit a job</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/submitJobButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                Display the "Choose file" dialog in order to submit a
                XML-defined job to the scheduler.
            </para>

            <figure id="pauseResumeJobButton">
                <title>Pause/Resume a job</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/pauseResumeJobButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                Pause or resume the selected job (only if you are the
                job owner).
            </para>

            <figure id="changeJobPriorityButton">
                <title>Change job priority</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/changeJobPriorityButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                Change job priority (only if you are the job owner).
                Priority allowed are:
                <itemizedlist>
                    <listitem>
                        <para>Lowest.</para>
                    </listitem>
                    <listitem>
                        <para>Low.</para>
                    </listitem>
                    <listitem>
                        <para>Normal.</para>
                    </listitem>
                </itemizedlist>
            </para>

            <figure id="getJobOutputButton">
                <title>Display job output</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/getJobOutputButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                To display the selected job's standard and error output
                (only if you are the job owner).
            </para>

            <figure id="killJobButton">
                <title>Kill Job</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/killJobButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                To kill the selected job (only if you are the job
                owner).
            </para>
        </sect3><!-- The Jobs view buttons in User Mode -->

        <sect3 id="admin_mode">
            <title>The Jobs view buttons in Administrator Mode</title>
            <para>
                All buttons allowed in user mode are also allowed in
                Administrator mode. Moreover you can execute any action
                even you aren't the job owner.
            </para>
            <para>
                In Administrator mode, 3 other choices for job priority
                are available :
                <itemizedlist>
                    <listitem>
                        <para>
                            Idle, lower priority than the 3 User Mode
                            priorities
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            High, higher priority than the 3 User Mode
                            priorities
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Highest, higher priority than the 3 User
                            Mode priorities and than High
                        </para>
                    </listitem>
                </itemizedlist>
            </para>

            <figure id="startSchedulerButton">
                <title>Start the scheduler</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/startSchedulerButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>

            <figure id="stopSchedulerButton">
                <title>Stop the scheduler</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/stopSchedulerButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>

            <figure id="freezeSchedulerButton">
                <title>Freeze the scheduler</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/freezeSchedulerButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                This freezes the scheduler. When the scheduler receives
                this event, it pauses all running jobs, and no other
                pending jobs will be scheduled.
            </para>

            <figure id="pauseSchedulerButton">
                <title>Pause the scheduler</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/pauseSchedulerButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                This pauses the scheduler. When the scheduler receives
                this event, no pending jobs will be scheduled, but all
                running jobs complete.
            </para>

            <figure id="resumeSchedulerButton">
                <title>Resume the scheduler</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/resumeSchedulerButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>

            <figure id="shutdownSchedulerButton">
                <title>Shutdown the scheduler</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/shutdownSchedulerButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                This shutdowns the scheduler. When the scheduler
                receives this event, job submission is no more allowed,
                but all running jobs complete. When all jobs are
                finished, the scheduler is shutdown.
            </para>

            <figure id="killSchedulerButton">
                <title>Kill scheduler</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="scheduler/pics/eclipse_plugin/killSchedulerButton.png"
                            format="PNG" />
                    </imageobject>
                </mediaobject>
            </figure>
            <para>
                This shutdown immediately the scheduler, without waiting
                for any job completion.
            </para>
        </sect3><!-- The Jobs view buttons in Administrator Mode -->
    </sect2><!-- The Scheduler perspective buttons -->
</sect1>
  
  
  
  
   <sect1 id="ProActive_Scheduler_Matlab">
        <title>ProActive Scheduler's Matlab Extension</title>
        <sect2 id="Scheduler_Matlab_Overwiew">
            <title>Presentation</title>
            <para>
                MATLAB is a numerical computing environment and
                programming language. Created by The MathWorks, MATLAB
                allows easy matrix manipulation, plotting of functions
                and data, implementation of algorithms, creation of user
                interfaces, and interfacing with programs in other
                languages.
            </para>
            <para>
                The Goal of ProActive Scheduler's Matlab Extension is
                to:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        allow users to easily launch Matlab scripts over
                        an heterogeneous grid
                    </para>
                </listitem>
                <listitem>
                    <para>
                        describe complex task flows in Matlab using
                        human-readable XML descriptors
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Ability to communicate the result of one task as
                        input of another task.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        users won't have to write any other code than
                        Matlab script code
                    </para>
                </listitem>
                <listitem>
                    <para>
                        support the following Matlab types : Double,
                        Complex, Int or String Arrays. Cells. Records.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
            A good way to start manipulating and scheduling Matlab scripts is to have a look at the standalone (and simple) Matlab/Scilab GUI described at <xref linkend="ScilabDoc"/>.
            If you want to directly through more complex Matlab job scheduling, go on with the following tutorial. 
            </para>
        </sect2>
        <sect2 id="Scheduler_Matlab_Quick_Start">
            <title>Quick Start with the Matlab Extension</title>
            <para>
                To get quickly our hands in, we'll write a very simple
                Matlab job example. This simple example will compute the
                roots of several polynomials.
            </para>
            <sect3 id="Scheduler_Matlab_Installation_Prerequisite">
                <title>Installation</title>
                <para>
                    Before starting to use the Matlab interface, you
                    need to install the Matlab interface to Java. You'll
                    find all the instructions on
                    PROACTIVE/scripts/unix/matlab/README.
                    This interface will build the native libraries of the Java Interface to Matlab. 
                    As this library is native, it is important that you build it for each couple &lt;Matlab version, Architecture&gt; inside your grid infrastructure. 
                    If you are using a ProActive installation on a centralized NFS folder, this will be sufficient. 
                    Otherwise, you will have to build and install the native library inside your ProActive installation on each machine used.
                </para>
                <para>
                The good news are, if you successfully run the configuration script, you won't have to bother where Matlab is installed at runtime, the Scheduler will determine it for you.
                A little drawback to this is that the scheduler will use the first Matlab installation found on the system, so it might not do what you want when several Matlab installations are on the same machine. 
                Further releases of the extension will allow a finer control over that by specifying Matlab's minimum version requirement inside job descriptors.
                </para>
            </sect3>
            <sect3 id="Scheduler_Matlab_Simple_Script">
                <title>
                    Writing a simple example : the Matlab Script
                </title>
                <para>
                    We write a very simple script which computes the
                    roots of a single given polynomial.
                </para>
                <programlisting lang="matlab"><![CDATA[out=roots(in);]]></programlisting>
                <para>
                    The
                    <emphasis>in</emphasis>
                    and
                    <emphasis>out</emphasis>
                    variables are specific variables which describe the
                    inputs and outputs of a Matlab script for the
                    Scheduler. in and out can contain anything supported
                    by the extension (Double, Complex, or String arrays,
                    Cells, Records).
                </para>
            </sect3>
            <sect3 id="Scheduler_Matlab_Simple_Descriptor">
                <title>
                    Writing a simple example : the Scheduler job
                    descriptor
                </title>
                <para>
                    This is a step by step guide to write this job
                    descriptor.
                </para>
                <sect4 id="Scheduler_Matlab_Job_Definition">
                    <title>The job definition</title>
                    <para>
                        The
                        <emphasis>job</emphasis>
                        tag is the root tag of our descriptor, it must
                        have a
                        <emphasis>name</emphasis>
                        attribute which holds an id of the job. It is
                        generally followed by a
                        <emphasis>description</emphasis>
                        tag which gives textual description of the job.
                        Finally, the next tag will be the type of job to
                        schedule. In our case it will be a
                        <emphasis>taskFlow</emphasis>
                        job (a job containing several tasks).
                    </para>
                    <programlisting lang="xml"><![CDATA[<job xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="urn:proactive:jobdescriptor:0.9 http://proactive.inria.fr/schemas/jobdescriptor/0.9/schedulerjob.xsd"
    xmlns="urn:proactive:jobdescriptor:0.9" name="Matlab_job_simplest">
    <description>A simple Matlab job, which computes the roots of several polynomials</description>
    <taskFlow>
      ...
    </taskFlow>
</job>]]></programlisting>
                </sect4>
                <sect4 id="Scheduler_Matlab_Task_Definition">
                    <title>The task definition</title>
                    <para>
                        The
                        <emphasis>task</emphasis>
                        tag contains all the information for a single
                        task executed on a single machine. In our
                        example, this task will be the matlab script
                        calculating the root of a polynomial.
                    </para>
                    <para>
                        The task tag must contain a
                        <emphasis>name</emphasis>
                        attribute like the job tag. Here it contains as
                        well the attribute
                        <emphasis>preciousResult</emphasis>
                        which tells the scheduler that we need the
                        result of this task as final output for our job.
                        The task tag is immediately followed by a
                        <emphasis>description</emphasis>
                        tag containing a textual description of this
                        task.
                    </para>
                    <para>
                        The description tag is followed by a
                        <emphasis>selection</emphasis>
                        tag. This tag describes a script which will
                        select, among all the machine resources that the
                        Scheduler controls, the specific resources
                        (machine) that can effectively run this task.
                        This script can for example test that Matlab is
                        installed and has the right version, that
                        specific Toolboxes are installed... We provide a
                        generic script which simply tests if Matlab is
                        installed. The script is retrieved from the URL
                        <ulink
                            url="http://proactive.inria.fr/userfiles/file/scripts/checkMatlab.js" />
                    </para>
                    <programlisting lang="xml"><![CDATA[<task name="root1" preciousResult="true">
    <description>Calculates the root of a polynomial</description>
    <selection>
        <script>
            <file url="http://proactive.inria.fr/userfiles/file/scripts/checkMatlab.js"/>
        </script>
    </selection>
    ...
</task>]]></programlisting>
                </sect4>
                <sect4 id="Scheduler_Matlab_Script_Definition">
                    <title>The Matlab script definition</title>
                    <para>
                        Now we finally write the script that will be
                        executed on the remote machine. The
                        <emphasis>javaExecutable</emphasis>
                        tag is a container for our Matlab script, it's a
                        java program that will connect to the Matlab
                        engine and launch the given script inside it.
                    </para>
                    <programlisting lang="xml"><![CDATA[<javaExecutable class="org.objectweb.proactive.extra.scheduler.ext.matlab.SimpleMatlab">
    <parameters>
        <parameter name="input" value="in=[1 0 3 -2 5 1];"/>
        <parameter name="script" value="out=roots(in);"/>
    </parameters>
</javaExecutable>]]></programlisting>
                    <para>
                        The javaExecutable tag contains an attribute
                        <emphasis>class</emphasis>
                        which tells which type of Matlab task will be
                        used, here we'll describe only the task called
                        <emphasis>SimpleMatlab</emphasis>
                        . In
                        <xref linkend="Scheduler_Matlab_AdvancedTasks" />
                        , we describe more advanced tasks. The
                        javaExecutable tag contains a child tag called
                        <emphasis>parameters</emphasis>
                        . This tag contains a list of
                        <emphasis>parameter</emphasis>
                        tags which define the task parameters. Each
                        parameter tag, has
                        <emphasis>name/value</emphasis>
                        couple attributes.
                    </para>
                    <para>
                        The SimpleMatlab task accepts the following
                        parameters:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                <emphasis>script</emphasis>
                                : defines which matlab script will be
                                launched. The value attributes will
                                contain the matlab script code (useful
                                for one line scripts only).
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>scriptFile</emphasis>
                                : defines which matlab script will be
                                launched. The file at the given path
                                will be loaded.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>scriptUrl</emphasis>
                                : defines which matlab script will be
                                launched. The file at the given remote
                                url will be loaded.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>input</emphasis>
                                : defines an input script which will be
                                launched before the actual matlab
                                script. The value attribute needs to
                                contain the script code (which must be
                                single-line only).
                            </para>
                        </listitem>
                    </itemizedlist>
                </sect4>
                <sect4 id="Scheduler_Matlab_Complete_Descriptor">
                    <title>Complete Job Descriptor</title>
                    <example id="Scheduler_Matlab_Simple_Descriptor_Example">
                        <title>Simple Matlab Job descriptor Example</title>
                        <programlisting lang="xml"><textobject><textdata
                                fileref="../descriptors/scheduler/jobs/Job_matlab_simplest.xml" /></textobject></programlisting>
                    </example>
                </sect4>
            </sect3>
        </sect2>
        <sect2 id="Scheduler_Matlab_More_Complex">
            <title>A More Complex Example : a Matlab task flow</title>
            <para>
                Now we will get through a more complex example. This
                example will use an interesting feature of the Matlab
                extension : the ability to pass results of one task as
                inputs of another task. This exemple, on the contrary of
                the previous one, is not a simple parallel batch
                processing, it's a flow of tasks, which depends from
                each others.
            </para>
            <para>
                This example will compute the sum of a big,
                randomly-generated array, values taken from -50 to +50.
                The example contains 3 steps:
            </para>
            <para>
                <orderedlist>
                    <listitem>
                        <para>
                            It splits the big array into several smaller
                            arrays.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            It computes the sum of each array in
                            parallel.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            It merges the results from each parallel
                            sub-total to compute the final sum.
                        </para>
                    </listitem>
                </orderedlist>
            </para>
            <para>
                This is not, of course, a real-case example as computing
                the sum of a big array will be much faster on a single
                machine (due to the overhead of launching Java and a
                Matlab engine and the network latency), but it is meant
                to illustrate a simple task flow in Matlab.
            </para>
            <para>
                We'll go through the new concepts introduced in this
                example compared to the previous one. Have a look at the
                new job descriptor first:
            </para>
            <example id="Scheduler_Matlab_Complex_Descriptor_Example">
                        <title>Complex Matlab Job descriptor Example</title>
                        <programlisting lang="xml"><textobject><textdata
                            fileref="../descriptors/scheduler/jobs/Job_matlab.xml" /></textobject></programlisting>
            </example>
            <sect3 id="Scheduler_Matlab_Descriptor_Variables">
                <title>Descriptor variables</title>
                <para>
                    The
                    <emphasis>variables</emphasis>
                    declaration allows a user to define a variable which
                    can be used as a pattern in other parts of the
                    descriptor. This helps writing more generic
                    descriptors and replacing only the variables values
                    to adapt the descriptor to many contexts. Here is
                    the variables declaration in the preceding
                    descriptor:
                </para>
                <programlisting lang="xml"><![CDATA[<variables>
    <variable name="HOME" value="/user/fviale/home"/>
    <variable name="MATLAB_SCRIPTS" value="${HOME}/matlab"/>
</variables>]]></programlisting>
                <para>
                    the
                    <emphasis>variables</emphasis>
                    tag contains a list of
                    <emphasis>variable</emphasis>
                    tags which each defines a variable through a
                    <emphasis>name</emphasis>
                    and a
                    <emphasis>value</emphasis>
                    attribute. The variable can then be used by writing
                    the pattern
                    <emphasis>${name_of_the_variable}</emphasis>
                    . Variable can be reused inside the variable
                    declaration itself, but the variables are processed
                    sequentially from top to bottom. Therefore, in this
                    example, In this example the MATLAB_SCRIPTS variable
                    could not be used before the HOME variable.
                </para>
            </sect3>
            <sect3 id="Scheduler_Matlab_AdvancedTasks">
                <title>
                    New Tasks : MatlabSplitter and MatlabCollector
                </title>
                <programlisting lang="xml"><![CDATA[<javaExecutable class="org.objectweb.proactive.extra.scheduler.ext.matlab.MatlabSplitter">
    <parameters>
        <parameter name="scriptFile" value="${MATLAB_SCRIPTS}/splitter.m"/>
        <parameter name="input" value="in=round(rand(1,1000000)*100-50)"/>
        <parameter name="number_of_children" value="6"/>
    </parameters>
</javaExecutable>]]></programlisting>
                <programlisting lang="xml"><![CDATA[<javaExecutable class="org.objectweb.proactive.extra.scheduler.ext.matlab.MatlabCollector">
    <parameters>
        <parameter name="scriptFile" value="${MATLAB_SCRIPTS}/collector.m"/>
    </parameters>
</javaExecutable>]]></programlisting>
                <para>
                    Two new tasks appear in this descriptor : the
                    <emphasis>MatlabSplitter</emphasis>
                    and the
                    <emphasis>MatlabCollector</emphasis>
                    . The Splitter task is used to split an input into a
                    list of several chunks. The Collector task is used
                    to collect and merge the results from several
                    parallel tasks. Each of these tasks come with the
                    same parameter as the SimpleMatlab tasks with an
                    addition: The Splitter expects an additional
                    parameter called
                    <emphasis>number_of_children</emphasis>
                    . This parameter tells the Matlab script responsible
                    for splitting in how many parts the input should be
                    divided.
                </para>
            </sect3>
            <sect3 id="Scheduler_Matlab_Dependencies">
                <title>Task dependencies</title>
                <para>
                    In order to do complex task flows, it is necessary
                    to add the concept of dependencies between tasks.
                </para>
                <programlisting lang="xml"><![CDATA[<task name="sum1">
    <description>Calculates the sum of the elements in the array</description>
    <depends>
        <task ref="splitter"/>
    </depends>
    ...</task>]]></programlisting>
                <para>
                    The
                    <emphasis>depends</emphasis>
                    tag in this task definition defines a dependency of
                    the task named "sum1" to the task named "splitter".
                    This means that the task sum1 will be launched afer
                    the task splitter is complete, and that the outputs
                    of splitter will be fed as inputs to sum1.
                </para>
                <para>
                    You'll notice that in this example, all the sumX
                    SimpleMatlab tasks depend from the Splitter. This
                    means that the output from the Splitter will be fed
                    to each sum task. On the other hand, the Collector
                    depends on every sumX task. It will be launched only
                    after all these tasks have completed, and the
                    results of all these tasks will be the inputs of the
                    Collector, you'll see on
                </para>
            </sect3>
            <sect3 id="Scheduler_Matlab_SimpleTaskIndex">
                <title>
                    New parameter in SimpleMatlab tasks: index
                </title>
                <programlisting lang="xml"><![CDATA[<task name="sum1">
    <description>Calculates the sum of the elements in the array</description>
    <depends>
        <task ref="splitter"/>
    </depends>
    <selection>
        <script>
            <file url="http://proactive.inria.fr/userfiles/file/scripts/checkMatlab.js"/>
        </script>
    </selection>
    <javaExecutable class="org.objectweb.proactive.extra.scheduler.ext.matlab.SimpleMatlab">
        <parameters>
            <parameter name="index" value="0"/>
            <parameter name="scriptFile" value="${MATLAB_SCRIPTS}/summer.m"/>
        </parameters>
    </javaExecutable>
</task>]]></programlisting>
                <para>
                    A new parameter appears in this descriptor for the
                    SimpleMatlab task : the
                    <emphasis>index</emphasis>
                    . The parameter is related to the splitting
                    mechanism. It can be defined only inside a
                    SimpleMatlab task and has sense only if the Simple
                    task has a Splitter task as parent. The Splitter
                    sends an output in the form of a list of results to
                    each child task. The same list will be sent to every
                    children. Therefore, each one needs to specify at
                    which index of the list it will look at. For
                    example, a splitter task splits the array [1,2,3,4]
                    into two arrays [1,2] and [3,4], the first child
                    needs to specify index 0 and second index 1 (note
                    that the indexes range from 0 to
                    number_of_children-1). By specifying these indexes,
                    the first child will get as input the array [1,2]
                    and the second child will get [3,4].
                </para>
            </sect3>
            <sect3 id="Scheduler_Matlab_ComplexExamples_Scripts">
                <title>Matlab Scripts for this example</title>
                <sect4 id="ComplexExamples_Splitter_Script">
                    <title>Script of the Splitter Task</title>
                    <programlisting lang="matlab"><textobject><textdata
                                fileref="../scripts/unix/matlab/examples/splitter.m" /></textobject></programlisting>
                    <para>
                        The Splitter script contains two important
                        aspects:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                It contains two inputs, the variable
                                <emphasis>in</emphasis>
                                which is fed by the "input" script of
                                the splitter task, and the variable
                                <emphasis>nout</emphasis>
                                which contains the value of the
                                <emphasis>number_of_children</emphasis>
                                parameter.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The
                                <emphasis>out</emphasis>
                                variable, which is the output of the
                                script must be a cell array of size
                                nout.
                            </para>
                        </listitem>
                    </itemizedlist>
                </sect4>
                <sect4 id="ComplexExamples_Summing_Script">
                    <title>Script of the Summing Task</title>
                    <programlisting lang="matlab"><textobject><textdata
                                fileref="../scripts/unix/matlab/examples/summer.m" /></textobject></programlisting>
                </sect4>
                <sect4 id="ComplexExamples_Collector_Script">
                    <title>Script of the Collector Task</title>
                    <programlisting lang="matlab"><textobject><textdata
                                fileref="../scripts/unix/matlab/examples/collector.m" /></textobject></programlisting>
                    <para>
                        The important aspect of the The Collector script
                        is that the input parameter
                        <emphasis>in</emphasis>
                        is a cell array.
                    </para>
                </sect4>
            </sect3>
        </sect2>
    </sect1>
    
    <sect1 id="ProActive_Scheduler_Scilab">
    <title>ProActive Scheduler's Scilab Extension</title>
        <sect2 id="Scheduler_Scilab_Overwiew">
        <title>Presentation</title>
        <para>
            <emphasis>Scilab</emphasis>
            is a scientific software for numerical computations.
            Developed since 1990 by researchers from INRIA and ENPC, it
            is now maintained and developed by Scilab Consortium since
            its creation in May 2003. Scilab includes hundreds of
            mathematical functions with the possibility to add
            interactively programs from various languages (C,
            Fortran...). It has sophisticated data structures (including
            lists, polynomials, rational functions, linear systems...),
            an interpreter and a high level programming language. Scilab
            works on most Unix systems (including GNU/Linux) and Windows
            (9X/2000/XP).
        </para>
        <para>
                Similarly to ProActive Scheduler's Matlab extension, the goal of the Scilab Extension is
                to:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        allow users to easily launch Scilab scripts over
                        an heterogeneous grid
                    </para>
                </listitem>
                <listitem>
                    <para>
                        describe complex task flows in Scilab using
                        human-readable XML descriptors
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Ability to communicate the result of one task as
                        input of another task.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        users won't have to write any other code than
                        Scilab script code
                    </para>
                </listitem>
                <listitem>
                    <para>
                        support the following Scilab types : Double,
                        Complex and String Arrays (the extension currently supports fewer types than the Matlab's one).
                    </para>
                </listitem>
            </itemizedlist>
            A good way to start manipulating and scheduling Scilab scripts is to have a look at the standalone (and simple) Matlab/Scilab GUI described at <xref linkend="ScilabDoc"/>.
            If you want to directly through more complex Scilab job scheduling, go on with the following tutorial. 
        </sect2>
        <sect2 id="Scheduler_Scilab_Quick_Start">
            <title>Quick Start with the Scilab Extension</title>
            <para>
                We'll write a simple Scilab job example. This example will assume that you are familiar with the example in <xref linkend="Scheduler_Matlab_More_Complex"/>. This example will compute the numerical
        integration of sin(x) between 0 and PI.
            </para>
            <sect3 id="Scheduler_Scilab_Installation_Prerequisite">
                <title>Installation</title>
                <para>
                    Before starting to use the Scilab interface, you
                    need to install Scilab in your environment. You'll
                    find all the instructions on
                    PROACTIVE/scripts/unix/scilab/README_Scheduler (Scilab section).
                </para>
                <para>
                Once Scilab is installed, you won't need at runtime to bother where Scilab is installed, the Scheduler will determine it for you.
                </para>
            </sect3>
            <sect3 id="Scheduler_Scilab_Job_Descriptor">
                <title>
                    The Scilab Job descriptor
                </title>
                <para>This is the descriptor of the scilab job which will be executed inside the scheduler</para>
                <example id="Scheduler_Scilab_Descriptor_Example">
                    <title>Scilab Job descriptor Example</title>
                    <programlisting lang="xml"><textobject><textdata
                        fileref="../descriptors/scheduler/jobs/Job_scilab.xml" /></textobject></programlisting>
                </example>
                <para> Here is the Scilab script that calculates individual integrals</para>
               <example id="Scheduler_Scilab_Int_Script">
                    <title>Integral script</title>
                    <programlisting lang="scilab"><textobject><textdata
                                fileref="../scripts/unix/scilab/examples/intsin.sci" /></textobject></programlisting>
                </example>
                <para> Here is the Scilab script that merges the individual results and computes the final answer</para>
               <example id="Scheduler_Scilab_Merge_Script">
                    <title>Merging script</title>
                    <programlisting lang="scilab"><textobject><textdata
                                fileref="../scripts/unix/scilab/examples/merge.sci" /></textobject></programlisting>
                </example>
                <para>
                This descriptor is very similar to the descriptor <xref linkend="Scheduler_Matlab_Complex_Descriptor_Example"/>.
                We'll go through the similarities and differences of these two descriptors.
                </para>
                <sect4 id="Scheduler_Scilab_Job_Descriptor_Similarities">
                <title>Similarities with Matlab job descriptor</title>
                <itemizedlist>
                    <listitem>
                        <para>
                        Concepts of job, tasks and dependences are common to all ProActive Scheduler jobs, so we find here the same concepts than in Matlab's. 
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                        Definitions of task's main and input scripts are done through the same task parameters <emphasis>script</emphasis>,<emphasis>scriptFile</emphasis>, <emphasis>scriptUrl</emphasis> and <emphasis>input</emphasis>
                        </para>
                    </listitem>
                </itemizedlist>
                
                </sect4>
                <sect4 id="Scheduler_Scilab_Job_Descriptor_Differences">
                <title>Differences with Matlab job descriptor</title>
                <para>For example in the following task : </para>
                <programlisting lang="xml"><![CDATA[<javaExecutable
 class="org.objectweb.proactive.extensions.scheduler.ext.scilab.SimpleScilab">
    <parameters>
        <parameter name="scriptFile"
          value="${SCILAB_SCRIPTS}/intsin.sci" />
        <parameter name="input" value="i=3;n=5;" />
        <parameter name="outputs" value="out" />
    </parameters>
</javaExecutable>]]></programlisting>
                <itemizedlist>
                    <listitem>
                        <para>
                        The main Scilab task is now called <emphasis>SimpleScilab</emphasis>. There exists no splitting mechanism yet, but there is a merging mechanism explained below.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            A new important task parameter appears : <emphasis>outputs</emphasis>. This parameter is used to specify which variables will be extracted from the Scilab environment at task's end. 
                            You can specify multiple output variables by separating them with commas. If you don't specify an output parameter, the variable called <emphasis>out</emphasis> will be extracted (leading to an error if it doesn't exist). 
                        </para>

                     </listitem>
                     <listitem>
                        <para>
                        The merging mechanism is different than for Matlab's. If a task depends from a bunch of other tasks. An automatic environment merging will be done. For example if we have 3 tasks A,B,C and C depends of A and B. if task A outputs a variable "a" and task B outputs a variable "b", task C will get as input both variable "a" and "b".
                        Now a problem arise when several tasks output the same variable name. In order to avoid overlapping, and to allow merging of results, this variable will be renamed by appending index at the end of the conflicting variable name.
                        In the current example, each tasks t1 - t5 output the same variable "out". task t6 will accordingly get as input variable out1 - out5. The index starts from 1 and the order matches the depends list order.
                        </para>
                     </listitem>
                </itemizedlist>
                </sect4>
           </sect3>
       </sect2>
    </sect1>
  
  
  
  
  
<sect1 id="Resource_Manager">
    <title>Resource Manager</title>
     <para><emphasis role="bold">NOTE</emphasis> - A RCP/Eclipse graphical client is available, <emphasis>but not yet documented</emphasis> for monitoring and controlling a Resource Manager.
   You can find it in the ProActive Download page. 
    </para>
    <sect2 id="Role">
	<title>Role</title>
	<para>As Scheduler manages pool of jobs to execute, Resource manager is in charge of supplying Scheduler 
	in resources : ProActive nodes. Resource Manager (RM) takes benefits of the ProActive library, 
	so it can handle resources from LAN, on cluster, on P2P desktop Grids, or on Internet Grids. 
	ResourceManager provides scheduler in nodes, according to criteria of the task to execute on it 
	(operating system, dynamic libraries, memory...).
	Its main functions are :</para>
	<itemizedlist>
	          <listitem>Creation, acquisition and removal of ProActive nodes.</listitem>
		      <listitem>Supplying nodes to scheduler for tasks executions, Scheduler can ask nodes that verify criteria, 
		      these criteria are defined in a selection script.</listitem>
		      <listitem>Maintaining and monitoring its list of node resources, and 
		      manage states of its handled nodes (free, busy, down...).</listitem>
	</itemizedlist>
	</sect2>
    <sect2 id="architecture">
	<title>Resource Manager architecture</title>
	<para>Resource Manager is made of five components :</para>
		<itemizedlist>
	          <listitem><emphasis>User</emphasis> Resource Manager's frontend for the Scheduler, 
	          this component provides for scheduler an entry to get and give back nodes.</listitem>
	          <listitem><emphasis>Admin</emphasis> Frontend for RM's administrator, provides administrator actions; add and remove nodes,
	          add and remove different node sources, shutting down the Resource manager.</listitem>
	          <listitem><emphasis>Core</emphasis> Main component, selects and gives nodes to scheduler,
	          maintains different nodes states for each node, and receive new available nodes acquired by Node Sources.</listitem>
	          <listitem><emphasis>Monitoring component</emphasis> Resource manager can have monitors connected to it.
	          Monitors are external programs (such as monitor GUI) that want to be informed about RM current activity;  
	          numbers of nodes and their availability for example.
	          The Monitoring component is in charge of throwing RM information to its monitors.</listitem>	          
	          <listitem><emphasis>Node Sources</emphasis> Resource manager can handle nodes coming from heterogeneous environments,
	          a Node source component is in charge of nodes acquisition, deployment and monitoring for a dedicated infrastructure. 
	          It means we can have a Node source which manages nodes deployed by a ProActive descriptor, 
	          one for nodes acquired from a Peer to peer infrastructure, and another for nodes acquired from a cluster.</listitem> 
		</itemizedlist>
      <figure id="RM_architecture">
        <title>resource Manager architecture</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="scheduler/pics/core/rm_overview.jpg"
                       format="JPG" />
          </imageobject>
        </mediaobject>
      </figure>
	</sect2>
	<sect2 id="nodes_sources">
		<title>Static Node Source and Dynamic Node Source</title>
			<para>Node Sources objects are aimed to acquire nodes for the RM, there are two kinds of Node Sources :</para>
			<itemizedlist>
	          <listitem><emphasis>Static Node Source</emphasis> defined for deploying and acquiring nodes by a ProActive descriptor. 
	          All nodes handled by the source are kept permanently by the Resource Manager, 
	          i.e until the termination of the RM or if Administrator ask to remove some of them.</listitem>
			<listitem><emphasis>Dynamic Node Source</emphasis> designed to acquire nodes 
			from an infrastructure which can provide nodes just for a limited time. So this Node Source get a node from a specific infrastructure, 
			keep it during a defined time. When this keeping time is elapsed, dynamic node source remove the node from the RM and give back node to its infrastructure. 
			A dynamic node source have three main parameters :
			<para>Max number of nodes : number of nodes that dynamic Node Source has to get from its corresponding infrastructure. 
			The dynamic node source tries to acquire this number of node source, but its infrastructure may not be able to provide as many nodes.
			So this is the number of acquired nodes that Dynamic Node Source tries to reach.</para>
			<para>Time to release(TTR) : keeping duration of an acquired node. when this keeping duration is reached by a node, dynamic node source releases it.</para>
			<para>Nice time : After a node release, time to wait for the dynamic node source before trying to get a new node from its infrastructure. 
			After each node release, dynamic node source waits "nice time", and after tries to acquire a new node.</para></listitem>
			</itemizedlist>
	</sect2>
 <sect2 id="nodes_states">
	<title>Nodes states</title>
		<para>Resource Manager has to maintain states of its handled nodes, here the different nodes states : </para>
		<itemizedlist>
	          <listitem><emphasis>Free</emphasis> Node is available, and there is no task launched on it. 
	          Node can be supplied to a scheduler.</listitem>
	          <listitem><emphasis>Busy</emphasis> Node has been given to scheduler and a task is executed on it.</listitem>
			  <listitem><emphasis>To be released</emphasis> Node is busy, and administrator or its (dynamic) Node Source has asked to remove the node.
			  So the node will be removed from RM after task's end.</listitem>
			  <listitem><emphasis>Down</emphasis> Node has a problem (unreachable, fallen...) and can't execute tasks anymore.</listitem>
		</itemizedlist>			  	          
	</sect2>
 <sect2 id="RM_start">
	<title>Starting the Resource Manager</title>
	<para>To start the Resource Manager, run the RMlauncher.sh script in scripts/scheduler directory. 
	Without arguments, Resource Manager will start and create four ProActive nodes on the local host.
	RMlauncher.sh can be started with 1 optional argument:</para>
	<itemizedlist> 
		<listitem>Path of a ProActive descriptor file (for example : ProActive/descriptors/Workers.xml).
		 Descriptor is deployed and nodes added to the RM by a static Node Source at the RM's startup.
		</listitem>
    </itemizedlist>
<para>You can also start Resource Manager using the java API. Resource Manager can be started with static functions
of RMFactory class. Here a short sample of RM instantiation with deployment of a ProActive descriptor. Nodes deployment is asked
to RMAdmin object :</para>
<programlisting lang="java">
        RMFactory.startLocal(); //creates Resource Manager components 
        RMAdmin admin = RMFactory.getAdmin(); //get RMAdmin object

        //creates ProActive Descriptor object from an xml file 
        ProActiveDescriptor pad = PADeployment.getProactiveDescriptor("myDescriptor.xml");
        
        //Ask to RMAdmin component to deploy the ProActive Descriptor
        //and add deployed nodes to the RM
        admin.addNodes(pad);
</programlisting>
 	</sect2>
  
  
  
  
  </sect1>
  
 
</chapter>
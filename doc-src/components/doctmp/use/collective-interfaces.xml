<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
	xml:id="collective-interfaces">
	<info>
		<title>Collective interfaces</title>
	</info>

	<para>
		In this chapter, we consider multiway communications -
		communications to or from several interfaces - and notably
		parallel communications, which are common in Grid computing.
	</para>
	<para>
		Our objective is to simplify the design of distributed Grid
		applications with multiway interactions.
	</para>
	<para>
		The driving idea is to manage the semantics and behavior of
		collective communications at the level of the interfaces.
	</para>

	<section>
		<info>
			<title>Motivations</title>
		</info>


		<para>
			Grid computing uses the resources of many separate computers
			connected by a network (usually the Internet) to solve
			large-scale computation problems. Because of the number of
			available computers, it is fundamental to provide tools for
			facilitating communications to and from these computers.
			Moreover, Grids may contain clusters of computers, where
			local parallel computations can be very efficiently
			performed - this is part of the solution for solving
			large-scale computation problems - , which means that
			programming models for Grid computing should include
			parallel programming facilities. We address this issue, in
			the context of a component model for Grid computing, by
			introducing
			<emphasis role="bold">collective interfaces</emphasis>
			.
		</para>

		<para>
			The component model that we use, Fractal, proposes two kinds
			of cardinalities for interfaces,
			<emphasis>singleton</emphasis>
			or
			<emphasis>collection</emphasis>
			, which result in one-to-one bindings between client and
			server interfaces. It is possible though to introduce
			binding components, which act as brokers and may handle
			different communication paradigms. Using these intermediate
			binding components, it is therefore possible to achieve
			one-to-n, n-to-one or n-to-n communications between
			components. It is not possible however for an interface to
			express a collective behavior: explicit binding components
			are needed in this case.
		</para>

		<para>
			We propose the addition of new cardinalities in the
			specification of Fractal interfaces, namely
			<emphasis>multicast</emphasis>
			and
			<emphasis>gathercast</emphasis>
			. Multicast and gathercast interfaces give the possibility
			to
			<emphasis>
				manage a group of interfaces as a single entity
			</emphasis>
			(which is not the case with a collection interface, where
			the user can only manipulate individual members of the
			collection), and they
			<emphasis>expose</emphasis>
			the collective nature of a given interface. Moreover,
			specific semantics for multiway invocations can be
			configured, providing users with flexible communications to
			or from gathercast and multicast interfaces. Lastly,
			avoiding the use of explicit intermediate binding components
			simplifies the programming model and type compatibility is
			automatically verified.
		</para>

		<para>
			The role and use of multicast and gathercast interfaces are
			complementary. Multicast interfaces are used for parallel
			invocations, whereas gathercast interfaces are used for
			synchronization and gathering purposes.
		</para>

		<para>
			Note that in our implementation of collective interfaces,
			new features of the Java language introduced in Java 5 are
			extensively used, notably annotations and generics.
		</para>
	</section>

	<section>
		<info>
			<title>Multicast interfaces</title>
		</info>


		<section>
			<info>
				<title>Definition</title>
			</info>


			<para>
				<emphasis>
					A multicast interface transforms a single invocation
					into a list of invocations
				</emphasis>
			</para>

			<para>
				A multicast interface is an abstraction for 1-to-n
				communications. When a single invocation is transformed
				into a set of invocations, these invocations are
				forwarded to a set of connected server interfaces. A
				multicast interface is unique and it exists at runtime
				(it is not lazily created). The semantics of the
				propagation of the invocation and of the distribution of
				the invocation parameters are customizable (through
				annotations), and the result of an invocation on a
				multicast interface - if there is a result - is always a
				list of results.
			</para>

			<para>
				Invocations forwarded to the connected server interfaces
				occur in parallel, which is one of the main reasons for
				defining this kind of interface: it enables
				<emphasis>
					parallel invocations, with automatic distribution of
					invocation parameters
				</emphasis>
				.
			</para>

			<para>
				<figure>
					<info>
						<title>
							Multicast interfaces for primitive and
							composite component
						</title>
					</info>


					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%"
								contentdepth="100%" align="center"
								fileref="components/pics/multicast-itfs.png" format="PNG" />
						</imageobject>
					</mediaobject>
				</figure>
			</para>
		</section>

		<section>
			<info>
				<title>Data distribution</title>
			</info>


			<para>
				A multicast invocation leads to the invocation services
				offered by one or several connected server interfaces,
				with possibly distinct parameters for each server
				interface.
			</para>

			<para>
				If some of the parameters of a given method of a
				multicast interface are lists of values, these values
				can be distributed in various ways through method
				invocations to the server interfaces connected to the
				multicast interface. The default behavior - namely
				<emphasis>broadcast</emphasis>
				- is to send the same parameters to each of the
				connected server interfaces. In the case some parameters
				are lists of values, copies of the lists are sent to
				each receiver. However, similar to what SPMD programming
				offers, it may be adequate to strip some of the
				parameters so that the bound components will work on
				different data. In MPI for instance, this can be
				explicitly specified by stripping a data buffer and
				using the
				<emphasis>scatter</emphasis>
				primitive.
			</para>

			<para>
				The following figure illustrates such distribution
				mechanisms: broadcast (a.) and scatter (b.)
			</para>

			<para>
				<figure>
					<info>
						<title>
							Broadcast and scatter of invocation
							parameters
						</title>
					</info>


					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%"
								contentdepth="100%"
								fileref="components/pics/parameters-broadcast-scatter.png"
								format="PNG" />
						</imageobject>
					</mediaobject>
				</figure>
			</para>

			<para>
				Invocations occur in parallel and the distribution of
				parameters is automatic.
			</para>

			<section>
				<info>
					<title>
						Invocation parameters distribution modes
					</title>
				</info>


				<para>
					4 modes of distribution of parameters are provided
					by default, and define distribution policies for
					lists of parameters:
				</para>

				<itemizedlist>
					<listitem>
						<para>
							BROADCAST, which copies a list of parameters
							and sends a copy to each connected server
							interface.
							<programlisting xml:lang="java">
								ParamDispatchMode.BROADCAST
							</programlisting>
						</para>
					</listitem>

					<listitem>
						<para>
							ONE-TO-ONE, which sends the ith parameter to
							the connected server interface of index i.
							This implies that the number of elements in
							the annotated list is equal to the number of
							connected server interfaces.
							<programlisting xml:lang="java">
								ParamDispatchMode.ONE_TO_ONE
							</programlisting>
						</para>
					</listitem>

					<listitem>
						<para>
							ROUND-ROBIN, which distributes each element
							of the list parameter in a round-robin
							fashion to the connected server interfaces.
							<programlisting xml:lang="java">
								ParamDispatchMode.ROUND_ROBIN
							</programlisting>
						</para>
					</listitem>

					<listitem>
						<para>
							UNICAST, which sends only one of the list
							parameter to one of the connected server
							interfaces. Which argument and which server
							interface is determined by a custom
							controller that extends
							<literal>
								org.objectweb.proactive.core.component.controller.MulticastController
							</literal>
							.
							<programlisting xml:lang="java">
								ParamDispatchMode.UNICAST
							</programlisting>
						</para>
					</listitem>
				</itemizedlist>

				<para>
					It is also possible to define a custom distribution
					by specifying the distribution algorithm in a class
					which implements the
					org.objectweb.proactive.core.component.type.annotations.multicast.ParamDispatch
					interface.
					<programlisting xml:lang="java">
						@ParamDispatchMetadata(mode
						=ParamDispatchMode.CUSTOM, customMode =
						CustomParametersDispatch.class))
					</programlisting>
				</para>
			</section>

			<section>
				<info>
					<title>Configuration through annotations</title>
				</info>


				<para>
					Note that our implementation of collective
					interfaces extensively uses new features of the Java
					language introduced in Java 5, such as generics and
					annotations.
				</para>

				<para>
					The distribution of parameters in our framework is
					specified in the definition of the multicast
					interface, using annotations.
				</para>

				<para>
					Elements of a multicast interface which can be
					annotated are: interface, methods and parameters.
					The different distribution modes are explained in
					the next section. The examples in this section all
					specify broadcast as the distribution mode.
				</para>

				<section>
					<info>
						<title>Interface annotations</title>
					</info>


					<para>
						A distribution mode declared at the level of the
						interface defines the distribution mode for all
						parameters of all methods of this interface, but
						may be overridden by a distribution mode
						declared at the level of a method or of a
						parameter.
					</para>

					<para>
						The annotation for declaring distribution
						policies at level of an interface is
						<literal>
							@org.objectweb.proactive.core.component.type.annotations.multicast.ClassDispatchMetadata
						</literal>
					</para>

					<para>and is used as follows:</para>

					<para>
						<programlisting xml:lang="java">
							@ClassDispatchMetadata(mode=@ParamDispatchMetadata(mode=ParamDispatchMode.BROADCAST))
							interface MyMulticastItf {

							public void foo(List&lt;T&gt; parameters);

							}
						</programlisting>
					</para>
				</section>

				<section>
					<info>
						<title>Method annotations</title>
					</info>


					<para>
						A distribution mode declared at the level of a
						method defines the distribution mode for all
						parameters of this method, but may be overridden
						at the level of each individual parameter.
					</para>

					<para>
						The annotation for declaring distribution
						policies at level of a method is
						<literal>
							@org.objectweb.proactive.core.component.type.annotations.multicast.MethodDispatchMetadata
						</literal>
					</para>

					<para>and is used as follows:</para>

					<para>
						<programlisting xml:lang="java">
							@MethodDispatchMetadata(mode =
							@ParamDispatchMetadata(mode
							=ParamDispatchMode.BROADCAST)) public void
							foo(List&lt;T&gt; parameters);
						</programlisting>
					</para>
				</section>

				<section>
					<info>
						<title>Parameter annotations</title>
					</info>


					<para>
						The annotation for declaring distribution
						policies at level of a parameter is
						<literal>
							@org.objectweb.proactive.core.component.type.annotations.multicast.ParamDispatchMetadata
						</literal>
					</para>

					<para>and is used as follows:</para>

					<para>
						<programlisting xml:lang="java">
							public void
							foo(@ParamDispatchMetadata(mode=ParamDispatchMode.BROADCAST)
							List&lt;T&gt; parameters);
						</programlisting>
					</para>
				</section>
			</section>

			<section>
				<info>
					<title>Results</title>
				</info>

				<para>
					For each method invoked and returning a result of
					type
					<literal>T</literal>
					, a multicast invocation returns an aggregation of
					the results: a
					<literal>List&lt;T&gt;</literal>
					.
				</para>

				<para>
					There is a type conversion, from return type
					<literal>T</literal>
					in a method of the server interface, to return type
					<literal>List&lt;T&gt;</literal>
					in the corresponding method of the multicast
					interface. The framework transparently handles the
					type conversion between return types, which is just
					an aggregation of elements of type
					<literal>T</literal>
					into a structure of type
					<literal>list&lt;T&gt;</literal>
					.
				</para>

				<para>
					This implies that, for the multicast interface,
					the signature of the invoked method has to
					explicitly specify
					<literal>List&lt;T&gt;</literal>
					as a return type. This also implies that each method
					of the interface returns either nothing, or a list.
					Valid return types for methods of multicast
					interfaces are illustrated as follows:
					<programlisting xml:lang="java">
						public List&lt;Something&gt; foo();

						public void bar();
					</programlisting>
				</para>

				<para>
					Otherwise, there is also a possibility to customize
					the result values by processing a reduction on them.
					This mechanism allows to gather results and/or
					perform some operations on them.
				</para>

				<para>
					There is one reduction mechanism provides by
					default: SELECT_UNIQUE_VALUE. It allows to extract
					of the list of results the only one result that the
					list contains. In order to use it, the multicast
					interface must use the
					org.objectweb.proactive.core.component.type.annotations.multicast.Reduce
					annotation at the level of the methods which the
					results need to be reduced:

					<programlisting xml:lang="java">
						@Reduce(reductionMode =
						ReduceMode.SELECT_UNIQUE_VALUE)
					</programlisting>
				</para>

				<para>
					Or else, a custom reduce mode can also be used.
					For this case, the first step is to defined the
					reduction algorithm into a class which implements
					the
					org.objectweb.proactive.core.component.type.annotations.multicast.ReduceBehavior
					interface. Then, the multicast interface can use the
					Reduce annotation, always at the level of the
					methods, by specifying the mode (CUSTOM) and the
					implementation class of the reduction to use:

					<programlisting xml:lang="java">
						@Reduce(reductionMode = ReduceMode.CUSTOM,
						customReductionMode = MyReduction.class)
					</programlisting>
				</para>
			</section>
		</section>

		<section>
			<info>
				<title>Binding compatibility</title>
			</info>


			<para>
				Multicast interfaces manipulate lists of parameters
				(say,
				<literal>List&lt;ParamType&gt;</literal>
				), and expect lists of results (say,
				<literal>List&lt;ResultType&gt;</literal>
				). With respect to a multicast interface, connected
				server interfaces, on the contrary, may work with lists
				of parameters (
				<literal>List&lt;ParamType</literal>
				), but also with individual parameters (
				<literal>ParamType</literal>
				) and return individual results (
				<literal>ResultType</literal>
				).
			</para>

			<para>
				Therefore,
				<emphasis>
					the signatures of methods differ from a multicast
					client interface to its connected server interfaces
				</emphasis>
				. This is illustrated in the following figure: in a. the
				<literal>foo</literal>
				method of the multicast interface returns a list of
				elements of type
				<literal>T</literal>
				collected from the invocations to the server interfaces,
				and in b. the
				<literal>bar</literal>
				method distributes elements of type
				<literal>A</literal>
				to the connected server interfaces.
			</para>

			<para>
				<figure>
					<info>
						<title>
							Comparison of signatures of methods between
							client multicast interfaces and server
							interfaces.
						</title>
					</info>


					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%"
								contentdepth="100%" align="center"
								fileref="components/pics/multicast-signatures-lists.png"
								format="PNG" />
						</imageobject>
					</mediaobject>
				</figure>
			</para>

			<para>
				For a given multicast interface, the type of server
				interfaces which may be connected to it can be infered
				by applying the following rules: for a given multicast
				interface,
				<itemizedlist>
					<listitem>
						<para>
							the server interface must have the same
							number of methods
						</para>
					</listitem>

					<listitem>
						<para>
							for a given method method foo of the
							multicast interface, there must be a
							matching method in the server interface:
						</para>

						<itemizedlist>
							<listitem>
								<para>named foo</para>
							</listitem>

							<listitem>
								<para>
									which returns:
									<itemizedlist>
										<listitem>
											<para>
												void if the method in
												the multicast method
												returns void
											</para>
										</listitem>

										<listitem>
											<para>
												T if the multicast
												method returns
												list&lt;T&gt;
											</para>
										</listitem>
									</itemizedlist>
								</para>
							</listitem>

							<listitem>
								<para>
									for a given parameter List&lt;T&gt;
									in the multicast method, there must
									be a corresponding parameter, either
									List&lt;T&gt; or T, in the server
									interface, which matches the
									distribution mode for this
									parameter.
								</para>
							</listitem>
						</itemizedlist>
					</listitem>
				</itemizedlist>
			</para>

			<para>
				The compatibility of interface signatures is verified
				automatically at binding time, resulting in a documented
				IllegalBindingException if signatures are incompatible.
			</para>
		</section>
	</section>

	<section>
		<info>
			<title>Gathercast interfaces</title>
		</info>


		<section>
			<info>
				<title>Definition</title>
			</info>


			<para>
				<emphasis>
					A gathercast interface transforms a list of
					invocations into a single invocation
				</emphasis>
			</para>

			<para>
				A gathercast interface is an abstraction for n-to-1
				communications. It handles data aggregation for
				invocation parameters, as well as process coordination.
				It gathers incoming data, and can also coordinate
				incoming invocations before continuing the invocation
				flow, by defining synchronization barriers.
			</para>

			<para>
				Gathering operations require knowledge of the
				participants of the collective communication (i.e. the
				clients of the gathercast interface). Therefore, the
				binding mechanism, when performing a binding to a
				gathercast interface, provides references on client
				interfaces bound to the gathercast interface. This is
				handled transparently by the framework. As a
				consequence, bindings to gathercast interfaces are
				bidirectional links.
			</para>

			<figure>
				<info>
					<title>
						Gathercast interfaces for primitive and
						composite components
					</title>
				</info>


				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%"
							contentdepth="100%" align="center"
							fileref="components/pics/gathercast-itfs.png" format="PNG" />
					</imageobject>
				</mediaobject>
			</figure>
		</section>

		<section>
			<info>
				<title>Data distribution</title>
			</info>


			<para>
				Gathercast interfaces aggregate parameters from method
				invocations from client interfaces into lists of
				invocations parameters, and they redistribute results to
				each client interface.
			</para>

			<section>
				<info>
					<title>Gathering of invocation parameters</title>
				</info>


				<para>
					Invocation parameters are simply gathered into lists
					of parameters. The indexes of the parameters in the
					list correspond the index of the parameters in the
					list of connected client interfaces, managed
					internally by the gathercast interface.
				</para>

				<para>
					<figure>
						<info>
							<title>
								Aggregation of parameters with a
								gathercast interface
							</title>
						</info>


						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%"
									contentdepth="100%" align="center"
									fileref="components/pics/gathercast-aggregation.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
					</figure>
				</para>
			</section>

			<section>
				<info>
					<title>Redistribution of results</title>
				</info>


				<para>
					The result of the invocation transformed by the
					gathercast interface is a list of values. Each
					result value is therefore indexed and redistributed
					to the client interface with the same index in the
					list of client interfaces managed internally by the
					gathercast interface.
				</para>

				<para>
					Similarly to the distribution of invocation
					parameters in multicast interfaces, a redistribution
					function could be applied to the results of a
					gathercast invocation, however this feature is not
					implemented yet.
				</para>
			</section>
		</section>

		<section>
			<info>
				<title>Binding compatibility</title>
			</info>


			<para>
				Gathercast interfaces manipulate lists of parameters
				(say,
				<literal>List&lt;ParamType&gt;</literal>
				), and return lists of results (say,
				<literal>List&lt;ResultType&gt;</literal>
				). With respect to a gathercast interface, connected
				client interface work with parameters which can be
				contained in the lists of parameters of the methods of
				the bound gathercast interface (ParamType), and they
				return results which can be contained in the lists of
				results of the methods of the bound gathercast interface
				(ResultType).
			</para>

			<para>
				Therefore, by analogy to the case of multicast
				interfaces,
				<emphasis>
					the signatures of methods differ from a gathercast
					server interface to its connected client interfaces
				</emphasis>
				. This is illustrated in the following figure: the foo
				method of interfaces which are client of the gathercast
				interface exhibit a parameter of type
				<literal>V</literal>
				, the foo method of the gathercast interface exhibits a
				parameter of type
				<literal>List&lt;V&gt;</literal>
				. Similarly, the foo method of client interfaces return
				a parameter of type
				<literal>T</literal>
				, and the foo method of the gathercast interface returns
				a parameter of type
				<literal>List&lt;T&gt;</literal>
				.
			</para>

			<para>
				The compatibility of interface signatures is verified
				automatically at binding time, resulting in a documented
				IllegalBindingException if signatures are incompatible
			</para>

			<figure>
				<info>
					<title>
						Comparison of signature of methods for bindings
						to a gathercast interface
					</title>
				</info>


				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%"
							contentdepth="100%" align="center"
							fileref="components/pics/gathercast-signatures.png" format="PNG" />
					</imageobject>
				</mediaobject>
			</figure>
		</section>

		<section>
			<info>
				<title>Process synchronization</title>
			</info>


			<para>
				An invocation from a client interface to a gathercast
				interface is asynchronous, provided it matches the usual
				conditions for asynchronous invocations in ProActive,
				however the gathercast interface only creates and
				executes a new invocation with gathered parameters when
				all connected client interfaces have performed an
				invocation on it.
			</para>

			<para>
				It is possible to specify a timeout, which corresponds
				to the maximum amount of time between the moment the
				first invocation of a client interface is processed by
				the gathercast interface, and the moment the invocation
				of the last client interface is processed. Indeed, the
				gathercast interface will not forward a transformed
				invocation until all invocations of all client
				interfaces are processed by this gathercast interface.
			</para>

			<para>
				Timeouts for gathercast invocations are specified by an
				annotation on the method subject to the timeout, the
				value of the timeout is specified in milliseconds:
				<programlisting xml:lang="java">
					@org.objectweb.proactive.core.component.type.annotations.gathercast.MethodSynchro(timeout=20)
				</programlisting>
			</para>

			<para>
				If a timeout is reached before a gathercast interface
				could gather and process all incoming requests, a
				<literal>
					org.objectweb.proactive.core.component.exceptions.GathercastTimeoutException
				</literal>
				is returned to each client participating in the
				invocation. This exception is a
				<emphasis>runtime</emphasis>
				exception.
			</para>

			<para>
				It is also possible for gathercast interface not to wait
				for all invocations from connected client interfaces to
				perform an invocation by specifying the waitForAll
				attribute. Therefore, the gathercast interface will
				create and execute a new invocation on the first
				invocation received from any of the connected client
				interfaces.
			</para>

			<para>
				Thus, this specific feature can be used by the same
				annotation as for the timeout but with a different
				attribute:
				<programlisting xml:lang="java">
					@org.objectweb.proactive.core.component.type.annotations.gathercast.MethodSynchro(waitForAll=false)
				</programlisting>
				Therefore, the waitForAll attribute accepts boolean
				values and has for default value "true" (same behavior
				as if the annotation is not specified).
			</para>

			<para>
				Furthermore, it is forbidden to combine timeout and
				waitForAll set to false (an
				<literal>
					org.objectweb.fractal.api.factory.InstantiationException
				</literal>
				is raised) because il would be incoherent.
			</para>

		</section>
	</section>
</chapter>


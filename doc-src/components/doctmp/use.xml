<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
	xml:id="use">
	<info>
		<title>Components use</title>
	</info>

	<para>
		This chapter explains the specific features and functionalities
		of the GCM Implementation.
	</para>

	<section>
		<info>
			<title>Architecture Description Language</title>
		</info>

		<indexterm significance="preferred">
			<primary>ADL</primary>
			<secondary>definition</secondary>
		</indexterm>
		<para />
		<para>
			The Architecture Description Languages (ADL) are a way to
			describe software and/or system architectures. ADLs facilitate
			application description without concern for the underlying 
			implementation code and foster code reuse as an effect
			of decoupling the implementation 
			from the architecture.  Architectures created by using ADLs are composed of predefined
			entities with various connectors that communicate through 
			defined connections.
			To define an architecture through an ADL we can use a textual syntax
			and/or a graphical syntax, possibly associated with a
			design tool.
		</para>
		<para>
			In the case of ProActive we have developed the Grid Component Model 
			which is an extension of the Fractal ADL. For detailed information
			on Fractal 
			read <link xmlns:xlink="http://www.w3.org/1999/xlink"
				xlink:href="http://fractal.objectweb.org/tutorials/adl/index.html">
				Fractal ADL tutorial
			</link>.
			
			
			 In our GCM implementation
			this mechanism	is used to configure and deploy component systems through
			normalized XML files. Thanks to a specific XML DTD, it	specifies 
			a definition for each component of the application.
			For instance, it usually describes component
			interfaces, component bindings, component attributes, the
			subcomponents in the case of a composite component, the
			virtual node where the component will be deployed, and so on. 
			As it is an extension of the standard Fractal ADL, GCM 
			allows reusing and integrating ProActive-specific features such as
			distributed deployment using deployment descriptors, 
			active objects, virtual nodes, etc.
			For example, in the case of virtual nodes  the components ADL has
			to be associated with a deployment descriptor (this is done
			at parsing time: both files are given to the parser).
			
		</para>
		<para>
			Note that because GCM is based on the Fractal ADL, it
			requires the following libraries which are included in the <literal>/lib</literal>
			directory of the ProActive distribution : <literal>fractal-adl.jar</literal>,
			<literal>dtdparser.jar</literal>, <literal>ow_deployment_scheduling.jar</literal>. 
		</para>
		<section>
			<info>
				<title>Overview</title>
			</info>

			<para>
				Components are defined in
				<emphasis role="bold">definition</emphasis>
				files, which are .fractal files. Here is a simple
				example of an ADL file extract from the example
				Helloworld retrievable at
				Examples/org.objectweb.proactive.examples.components.helloworld.
			</para>

			<programlisting lang="xml">
				<![CDATA[1:  <?xml version="1.0" encoding="ISO-8859-1" ?>
2:  <!DOCTYPE definition PUBLIC "-//objectweb.org//DTD Fractal ADL 2.0//EN" "classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd">
3:
4:  <definition name="org.objectweb.proactive.examples.components.helloworld.HelloWorld">
5:    <interface name="m" role="server" signature="org.objectweb.proactive.examples.components.helloworld.Main"/>
6:
7:    <component name="client" definition="org.objectweb.proactive.examples.components.helloworld.ClientImpl"/>
8:    <component name="server">
9:      <interface name="s" role="server" signature="org.objectweb.proactive.examples.components.helloworld.Service"/>
10:     <content class="ServerImpl"/>
11:     <attributes signature="org.objectweb.proactive.examples.components.helloworld.ServiceAttributes">
12:       <attribute name="header" value="-> "/>
13:       <attribute name="count" value="1"/>
14:     </attributes>
15:     <controller desc="primitive"/>
16:   </component>
17:
18:   <binding client="this.m" server="client.m"/>
19:   <binding client="client.s" server="server.s"/>
20:
21:   <controller desc="composite"/>
22:
23:   <virtual-node name="helooworld-node" cardinality="single"/>
24: </definition>]]>
			</programlisting>

			<para>
				Now, here is a detailed description of each lines:
				<itemizedlist>
					<listitem>
						<para>1: Classical prologue of XML files.</para>
					</listitem>
					<listitem>
						<para>
							2: The syntax of the document is validated
							against a DTD retrieved from the classpath.
						</para>
					</listitem>
					<listitem>
						<para>
							4: The
							<emphasis role="bold">definition</emphasis>
							element has a name (which must be the same
							name that the file's) and inheritance is
							supported through the attribute 'extends'.
						</para>
					</listitem>
					<listitem>
						<para>
							5: The
							<emphasis role="bold">interface</emphasis>
							element allows to specify interfaces of the
							current enclosing component.
						</para>
					</listitem>
					<listitem>
						<para>
							7-16: Nesting is allowed for composite
							components and is done by adding other
							<emphasis role="bold">component</emphasis>
							elements. Components can be specified and
							created in this definition, and these
							components can themselves be defined here or
							in other definition files.
						</para>
					</listitem>
					<listitem>
						<para>
							10: Primitive components specify the
							<emphasis role="bold">content</emphasis>
							element, which indicates the implementation
							class containing the business logic for this
							component.
						</para>
					</listitem>
					<listitem>
						<para>
							11-14: Components can specify a
							<emphasis role="bold">attributes</emphasis>
							element, which allows to initialize
							attributes of a component.
						</para>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Binding</primary>
							<secondary>adl</secondary>
						</indexterm>
						<para>
							18-19: The
							<emphasis role="bold">binding</emphasis>
							element specifies bindings between
							interfaces of components and specifying
							'this' as the name of the component refers
							to the current enclosing component.
						</para>
					</listitem>
					<listitem>
						<para>
							21: The
							<emphasis role="bold">controller</emphasis>
							elements can have the following 'desc'
							values: 'composite' or 'primitive'.
						</para>
					</listitem>
					<listitem>
						<para>
							23: The
							<emphasis role="bold">
								virtual-node
							</emphasis>
							element offers distributed deployment
							information. It can be exported and composed
							in the exportedVirtualNodes element.
						</para>
						<para>
							The component will be instantiated on the
							virtual node it specified (or the one that
							it exported). For a composite component, it
							means it will be instantiated on the (first
							if there are several nodes mapped) node of
							the virtual node. For a primitive component,
							if the virtual node defines several nodes
							(cardinality='multiple'), there will be as
							many instances of the primitive component as
							there are underlying nodes. Each of these
							instances will have a suffixed name looking
							like:
							<screen>
								primiveComponentName-cyclicInstanceNumber-n
							</screen>
							where primitiveComponentName is the name
							defined in the ADL.
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				The syntax is similar to the standard Fractal ADL, and
				the parsing engine has been extended. Features specific
				to ProActive are:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						Virtual nodes have a cardinality property:
						either 'single' or 'multiple'. When 'single', it
						means the virtual node in the deployment
						descriptor should contain 1 node ; when
						'multiple', it means the virtual node in the
						deployment descriptor should contain more than 1
						node.
					</para>
				</listitem>
				<listitem>
					<para>
						Virtual nodes can be
						<emphasis role="bold">exported</emphasis>
						and
						<emphasis role="bold">composed</emphasis>
						.
					</para>
				</listitem>
				<listitem>
					<para>Template components are not handled.</para>
				</listitem>
				<listitem>
					<para>
						The validating DTD has to be specified as:
						classpath://org/objectweb/proactive/core/component/adl/xml/proactive.dtd
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<info>
				<title>
					Exportation and composition of virtual nodes
				</title>
			</info>

			<para>
				Components are deployed on the virtual node that is
				specified in their definition ; it has to appear in the
				deployment descriptor
				<emphasis role="underline">unless</emphasis>
				this virtual node is exported. In this case, the name of
				the exported virtual node should appear in the
				deployment descriptor, unless this exported virtual node
				is itself exported.
			</para>
			<para>
				When exported, a virtual node can take part in the
				composition of other exported virtual nodes. The idea is
				to further extend reusability of existing (and packaged,
				packaging being a forthcoming feature of Fractal)
				components.
			</para>
			<para>
				In the example, the component defined in
				helloworld-distributed-wrappers.fractal exports the
				virtual nodes VN1 and VN2:
			</para>
			<screen>
				exportedVirtualNodes exportedVirtualNode name='VN1'
				composedFrom composingVirtualNode component='client'
				name='client-node' /composedFrom /exportedVirtualNode
				exportedVirtualNode name='VN2' composedFrom
				composingVirtualNode component='server'
				name='server-node'/ /composedFrom /exportedVirtualNode
				/exportedVirtualNodes
			</screen>
			<para>
				VN1 is composed of the exported virtual node
				'client-node' from the component named client
			</para>
			<para>
				In the definition of the client component
				(ClientImpl.fractal), we can see that client-node is an
				exportation of a virtual node which is also name
				'client-node':
			</para>
			<screen>
				exportedVirtualNodes exportedVirtualNode
				name='client-node' composedFrom composingVirtualNode
				component='this' name='client-node'/ /composedFrom
				/exportedVirtualNode /exportedVirtualNodes ...
				virtual-node name='client-node' cardinality='single'/
			</screen>
			<para>
				Although this is a simplistic example, one should
				foresee a situation where ClientImpl would be a
				prepackaged component, where its ADL could not be
				modified ; the exportation and composition of virtual
				nodes allow to adapt the deployment of the system
				depending on the existing infrastructure. Colocation can
				be specified in the enclosing component definition
				(helloworld-distributed-wrappers.fractal):
			</para>
			<screen>
				exportedVirtualNodes exportedVirtualNode name='VN1'
				composedFrom composingVirtualNode component='client'
				name='client-node' composingVirtualNode
				component='server' name='server-node'/ /composedFrom
				/exportedVirtualNode /exportedVirtualNodes
			</screen>
			<para>
				As a result, the client and server component will be
				colocated / deployed on the same virtual node. This can
				be profitable if there is a lot of communications
				between these two components.
			</para>
			<para>
				When specifying 'null' as the name of an exported
				virtual node, the components will be deployed on the
				current virtual machine. This can be useful for
				debugging purposes.
			</para>
		</section>
		<section xml:id="adl_usage">
			<info>
				<title>Usage</title>
			</info>

			<para>
				ADL definitions correspond to component factories. ADL
				definition can be used directly:
				<programlisting xml:lang="java">
					Factory factory =
					org.objectweb.proactive.core.component.adl.FactoryFactory.getFactory();
					Map context = new HashMap(); Component c =
					(Component)
					factory.newComponent("myADLDefinition",context);
				</programlisting>
			</para>
			<para>
				It is also possible to use the launcher tool, which
				parses the ADL, creates a corresponding component
				factory, and instantiates and assembles the components
				as defined in the ADL, is started from the
				<literal>
					org.objectweb.proactive.core.component.adl.Launcher
				</literal>
				class:
			</para>
			<screen>
				Launcher [-java|-fractal] &lt;definition&gt; [
				&lt;itf&gt; ] [deployment-descriptor])
			</screen>
			<para>
				where [-java|-fractal] comes from the Fractal ADL
				Launcher (put -fractal for ProActive components, this
				will be made optional for ProActive components in the
				next release), &lt;definition&gt; is the name of the
				component to be instantiated and started, &lt;itf&gt; is
				the name of its Runnable interface, if it has one, and
				&lt;deployment-descriptor&gt; the location of the
				ProActive deployment descriptor to use. It is also
				possible to use this class directly from its static main
				method.
			</para>
		</section>
	</section>

	<section>
		<info>
			<title>Deployment</title>
		</info>
		<para>
		</para>
	</section>

	<section>
		<info>
			<title>Collective interfaces</title>
		</info>

		<para>
			In this chapter, we consider multiway communications -
			communications to or from several interfaces - and notably
			parallel communications, which are common in Grid computing.
		</para>
		<para>
			Our objective is to simplify the design of distributed Grid
			applications with multiway interactions.
		</para>
		<para>
			The driving idea is to manage the semantics and behavior of
			collective communications at the level of the interfaces.
		</para>

		<section>
			<info>
				<title>Motivations</title>
			</info>


			<para>
				Grid computing uses the resources of many separate
				computers connected by a network (usually the Internet)
				to solve large-scale computation problems. Because of
				the number of available computers, it is fundamental to
				provide tools for facilitating communications to and
				from these computers. Moreover, Grids may contain
				clusters of computers, where local parallel computations
				can be very efficiently performed - this is part of the
				solution for solving large-scale computation problems -
				, which means that programming models for Grid computing
				should include parallel programming facilities. We
				address this issue, in the context of a component model
				for Grid computing, by introducing
				<emphasis role="bold">collective interfaces</emphasis>
				.
			</para>

			<para>
				The component model that we use, Fractal, proposes two
				kinds of cardinalities for interfaces,
				<emphasis>singleton</emphasis>
				or
				<emphasis>collection</emphasis>
				, which result in one-to-one bindings between client and
				server interfaces. It is possible though to introduce
				binding components, which act as brokers and may handle
				different communication paradigms. Using these
				intermediate binding components, it is therefore
				possible to achieve one-to-n, n-to-one or n-to-n
				communications between components. It is not possible
				however for an interface to express a collective
				behavior: explicit binding components are needed in this
				case.
			</para>

			<para>
				We propose the addition of new cardinalities in the
				specification of Fractal interfaces, namely
				<emphasis>multicast</emphasis>
				and
				<emphasis>gathercast</emphasis>
				. Multicast and gathercast interfaces give the
				possibility to
				<emphasis>
					manage a group of interfaces as a single entity
				</emphasis>
				(which is not the case with a collection interface,
				where the user can only manipulate individual members of
				the collection), and they
				<emphasis>expose</emphasis>
				the collective nature of a given interface. Moreover,
				specific semantics for multiway invocations can be
				configured, providing users with flexible communications
				to or from gathercast and multicast interfaces. Lastly,
				avoiding the use of explicit intermediate binding
				components simplifies the programming model and type
				compatibility is automatically verified.
			</para>

			<para>
				The role and use of multicast and gathercast interfaces
				are complementary. Multicast interfaces are used for
				parallel invocations, whereas gathercast interfaces are
				used for synchronization and gathering purposes.
			</para>

			<para>
				Note that in our implementation of collective
				interfaces, new features of the Java language introduced
				in Java 5 are extensively used, notably annotations and
				generics.
			</para>
		</section>

		<section>
			<info>
				<title>Multicast interfaces</title>
			</info>


			<section>
				<info>
					<title>Definition</title>
				</info>


				<para>
					<emphasis>
						A multicast interface transforms a single
						invocation into a list of invocations
					</emphasis>
				</para>

				<para>
					A multicast interface is an abstraction for 1-to-n
					communications. When a single invocation is
					transformed into a set of invocations, these
					invocations are forwarded to a set of connected
					server interfaces. A multicast interface is unique
					and it exists at runtime (it is not lazily created).
					The semantics of the propagation of the invocation
					and of the distribution of the invocation parameters
					are customizable (through annotations), and the
					result of an invocation on a multicast interface -
					if there is a result - is always a list of results.
				</para>

				<para>
					Invocations forwarded to the connected server
					interfaces occur in parallel, which is one of the
					main reasons for defining this kind of interface: it
					enables
					<emphasis>
						parallel invocations, with automatic
						distribution of invocation parameters
					</emphasis>
					.
				</para>

				<para>
					<figure>
						<info>
							<title>
								Multicast interfaces for primitive and
								composite component
							</title>
						</info>


						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%"
									contentdepth="100%" align="center"
									fileref="components/pics/multicast-itfs.png" format="PNG" />
							</imageobject>
						</mediaobject>
					</figure>
				</para>
			</section>

			<section>
				<info>
					<title>Data distribution</title>
				</info>


				<para>
					A multicast invocation leads to the invocation
					services offered by one or several connected server
					interfaces, with possibly distinct parameters for
					each server interface.
				</para>

				<para>
					If some of the parameters of a given method of a
					multicast interface are lists of values, these
					values can be distributed in various ways through
					method invocations to the server interfaces
					connected to the multicast interface. The default
					behavior - namely
					<emphasis>broadcast</emphasis>
					- is to send the same parameters to each of the
					connected server interfaces. In the case some
					parameters are lists of values, copies of the lists
					are sent to each receiver. However, similar to what
					SPMD programming offers, it may be adequate to strip
					some of the parameters so that the bound components
					will work on different data. In MPI for instance,
					this can be explicitly specified by stripping a data
					buffer and using the
					<emphasis>scatter</emphasis>
					primitive.
				</para>

				<para>
					The following figure illustrates such distribution
					mechanisms: broadcast (a.) and scatter (b.)
				</para>

				<para>
					<figure>
						<info>
							<title>
								Broadcast and scatter of invocation
								parameters
							</title>
						</info>


						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%"
									contentdepth="100%"
									fileref="components/pics/parameters-broadcast-scatter.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
					</figure>
				</para>

				<para>
					Invocations occur in parallel and the distribution
					of parameters is automatic.
				</para>

				<section>
					<info>
						<title>
							Invocation parameters distribution modes
						</title>
					</info>


					<para>
						4 modes of distribution of parameters are
						provided by default, and define distribution
						policies for lists of parameters:
					</para>

					<itemizedlist>
						<listitem>
							<para>
								BROADCAST, which copies a list of
								parameters and sends a copy to each
								connected server interface.
								<programlisting xml:lang="java">
									ParamDispatchMode.BROADCAST
								</programlisting>
							</para>
						</listitem>

						<listitem>
							<para>
								ONE-TO-ONE, which sends the ith
								parameter to the connected server
								interface of index i. This implies that
								the number of elements in the annotated
								list is equal to the number of connected
								server interfaces.
								<programlisting xml:lang="java">
									ParamDispatchMode.ONE_TO_ONE
								</programlisting>
							</para>
						</listitem>

						<listitem>
							<para>
								ROUND-ROBIN, which distributes each
								element of the list parameter in a
								round-robin fashion to the connected
								server interfaces.
								<programlisting xml:lang="java">
									ParamDispatchMode.ROUND_ROBIN
								</programlisting>
							</para>
						</listitem>

						<listitem>
							<para>
								UNICAST, which sends only one of the
								list parameter to one of the connected
								server interfaces. Which argument and
								which server interface is determined by
								a custom controller that extends
								<literal>
									org.objectweb.proactive.core.component.controller.MulticastController
								</literal>
								.
								<programlisting xml:lang="java">
									ParamDispatchMode.UNICAST
								</programlisting>
							</para>
						</listitem>
					</itemizedlist>

					<para>
						It is also possible to define a custom
						distribution by specifying the distribution
						algorithm in a class which implements the
						org.objectweb.proactive.core.component.type.annotations.multicast.ParamDispatch
						interface.
						<programlisting xml:lang="java">
							@ParamDispatchMetadata(mode
							=ParamDispatchMode.CUSTOM, customMode =
							CustomParametersDispatch.class))
						</programlisting>
					</para>
				</section>

				<section>
					<info>
						<title>Configuration through annotations</title>
					</info>


					<para>
						Note that our implementation of collective
						interfaces extensively uses new features of the
						Java language introduced in Java 5, such as
						generics and annotations.
					</para>

					<para>
						The distribution of parameters in our framework
						is specified in the definition of the multicast
						interface, using annotations.
					</para>

					<para>
						Elements of a multicast interface which can be
						annotated are: interface, methods and
						parameters. The different distribution modes are
						explained in the next section. The examples in
						this section all specify broadcast as the
						distribution mode.
					</para>

					<section>
						<info>
							<title>Interface annotations</title>
						</info>


						<para>
							A distribution mode declared at the level of
							the interface defines the distribution mode
							for all parameters of all methods of this
							interface, but may be overridden by a
							distribution mode declared at the level of a
							method or of a parameter.
						</para>

						<para>
							The annotation for declaring distribution
							policies at level of an interface is
							<literal>
								@org.objectweb.proactive.core.component.type.annotations.multicast.ClassDispatchMetadata
							</literal>
						</para>

						<para>and is used as follows:</para>

						<para>
							<programlisting xml:lang="java">
								@ClassDispatchMetadata(mode=@ParamDispatchMetadata(mode=ParamDispatchMode.BROADCAST))
								interface MyMulticastItf {

								public void foo(List&lt;T&gt;
								parameters);

								}
							</programlisting>
						</para>
					</section>

					<section>
						<info>
							<title>Method annotations</title>
						</info>


						<para>
							A distribution mode declared at the level of
							a method defines the distribution mode for
							all parameters of this method, but may be
							overridden at the level of each individual
							parameter.
						</para>

						<para>
							The annotation for declaring distribution
							policies at level of a method is
							<literal>
								@org.objectweb.proactive.core.component.type.annotations.multicast.MethodDispatchMetadata
							</literal>
						</para>

						<para>and is used as follows:</para>

						<para>
							<programlisting xml:lang="java">
								@MethodDispatchMetadata(mode =
								@ParamDispatchMetadata(mode
								=ParamDispatchMode.BROADCAST)) public
								void foo(List&lt;T&gt; parameters);
							</programlisting>
						</para>
					</section>

					<section>
						<info>
							<title>Parameter annotations</title>
						</info>


						<para>
							The annotation for declaring distribution
							policies at level of a parameter is
							<literal>
								@org.objectweb.proactive.core.component.type.annotations.multicast.ParamDispatchMetadata
							</literal>
						</para>

						<para>and is used as follows:</para>

						<para>
							<programlisting xml:lang="java">
								public void
								foo(@ParamDispatchMetadata(mode=ParamDispatchMode.BROADCAST)
								List&lt;T&gt; parameters);
							</programlisting>
						</para>
					</section>
				</section>

				<section>
					<info>
						<title>Results</title>
					</info>

					<para>
						For each method invoked and returning a result
						of type
						<literal>T</literal>
						, a multicast invocation returns an aggregation
						of the results: a
						<literal>List&lt;T&gt;</literal>
						.
					</para>

					<para>
						There is a type conversion, from return type
						<literal>T</literal>
						in a method of the server interface, to return
						type
						<literal>List&lt;T&gt;</literal>
						in the corresponding method of the multicast
						interface. The framework transparently handles
						the type conversion between return types, which
						is just an aggregation of elements of type
						<literal>T</literal>
						into a structure of type
						<literal>list&lt;T&gt;</literal>
						.
					</para>

					<para>
						This implies that, for the multicast interface,
						the signature of the invoked method has to
						explicitly specify
						<literal>List&lt;T&gt;</literal>
						as a return type. This also implies that each
						method of the interface returns either nothing,
						or a list. Valid return types for methods of
						multicast interfaces are illustrated as follows:
						<programlisting xml:lang="java">
							public List&lt;Something&gt; foo();

							public void bar();
						</programlisting>
					</para>

					<para>
						Otherwise, there is also a possibility to
						customize the result values by processing a
						reduction on them. This mechanism allows to
						gather results and/or perform some operations on
						them.
					</para>

					<para>
						There is one reduction mechanism provides by
						default: SELECT_UNIQUE_VALUE. It allows to
						extract of the list of results the only one
						result that the list contains. In order to use
						it, the multicast interface must use the
						org.objectweb.proactive.core.component.type.annotations.multicast.Reduce
						annotation at the level of the methods which the
						results need to be reduced:

						<programlisting xml:lang="java">
							@Reduce(reductionMode =
							ReduceMode.SELECT_UNIQUE_VALUE)
						</programlisting>
					</para>

					<para>
						Or else, a custom reduce mode can also be used.
						For this case, the first step is to defined the
						reduction algorithm into a class which
						implements the
						org.objectweb.proactive.core.component.type.annotations.multicast.ReduceBehavior
						interface. Then, the multicast interface can use
						the Reduce annotation, always at the level of
						the methods, by specifying the mode (CUSTOM) and
						the implementation class of the reduction to
						use:

						<programlisting xml:lang="java">
							@Reduce(reductionMode = ReduceMode.CUSTOM,
							customReductionMode = MyReduction.class)
						</programlisting>
					</para>
				</section>
			</section>

			<section>
				<info>
					<title>Binding compatibility</title>
				</info>


				<para>
					Multicast interfaces manipulate lists of parameters
					(say,
					<literal>List&lt;ParamType&gt;</literal>
					), and expect lists of results (say,
					<literal>List&lt;ResultType&gt;</literal>
					). With respect to a multicast interface, connected
					server interfaces, on the contrary, may work with
					lists of parameters (
					<literal>List&lt;ParamType</literal>
					), but also with individual parameters (
					<literal>ParamType</literal>
					) and return individual results (
					<literal>ResultType</literal>
					).
				</para>

				<para>
					Therefore,
					<emphasis>
						the signatures of methods differ from a
						multicast client interface to its connected
						server interfaces
					</emphasis>
					. This is illustrated in the following figure: in a.
					the
					<literal>foo</literal>
					method of the multicast interface returns a list of
					elements of type
					<literal>T</literal>
					collected from the invocations to the server
					interfaces, and in b. the
					<literal>bar</literal>
					method distributes elements of type
					<literal>A</literal>
					to the connected server interfaces.
				</para>

				<para>
					<figure>
						<info>
							<title>
								Comparison of signatures of methods
								between client multicast interfaces and
								server interfaces.
							</title>
						</info>


						<mediaobject>
							<imageobject>
								<imagedata scalefit="1" width="100%"
									contentdepth="100%" align="center"
									fileref="components/pics/multicast-signatures-lists.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
					</figure>
				</para>

				<para>
					For a given multicast interface, the type of server
					interfaces which may be connected to it can be
					infered by applying the following rules: for a given
					multicast interface,
					<itemizedlist>
						<listitem>
							<para>
								the server interface must have the same
								number of methods
							</para>
						</listitem>

						<listitem>
							<para>
								for a given method method foo of the
								multicast interface, there must be a
								matching method in the server interface:
							</para>

							<itemizedlist>
								<listitem>
									<para>named foo</para>
								</listitem>

								<listitem>
									<para>
										which returns:
										<itemizedlist>
											<listitem>
												<para>
													void if the method
													in the multicast
													method returns void
												</para>
											</listitem>

											<listitem>
												<para>
													T if the multicast
													method returns
													list&lt;T&gt;
												</para>
											</listitem>
										</itemizedlist>
									</para>
								</listitem>

								<listitem>
									<para>
										for a given parameter
										List&lt;T&gt; in the multicast
										method, there must be a
										corresponding parameter, either
										List&lt;T&gt; or T, in the
										server interface, which matches
										the distribution mode for this
										parameter.
									</para>
								</listitem>
							</itemizedlist>
						</listitem>
					</itemizedlist>
				</para>

				<para>
					The compatibility of interface signatures is
					verified automatically at binding time, resulting in
					a documented IllegalBindingException if signatures
					are incompatible.
				</para>
			</section>
		</section>

		<section>
			<info>
				<title>Gathercast interfaces</title>
			</info>


			<section>
				<info>
					<title>Definition</title>
				</info>


				<para>
					<emphasis>
						A gathercast interface transforms a list of
						invocations into a single invocation
					</emphasis>
				</para>

				<para>
					A gathercast interface is an abstraction for n-to-1
					communications. It handles data aggregation for
					invocation parameters, as well as process
					coordination. It gathers incoming data, and can also
					coordinate incoming invocations before continuing
					the invocation flow, by defining synchronization
					barriers.
				</para>

				<para>
					Gathering operations require knowledge of the
					participants of the collective communication (i.e.
					the clients of the gathercast interface). Therefore,
					the binding mechanism, when performing a binding to
					a gathercast interface, provides references on
					client interfaces bound to the gathercast interface.
					This is handled transparently by the framework. As a
					consequence, bindings to gathercast interfaces are
					bidirectional links.
				</para>

				<figure>
					<info>
						<title>
							Gathercast interfaces for primitive and
							composite components
						</title>
					</info>


					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%"
								contentdepth="100%" align="center"
								fileref="components/pics/gathercast-itfs.png" format="PNG" />
						</imageobject>
					</mediaobject>
				</figure>
			</section>

			<section>
				<info>
					<title>Data distribution</title>
				</info>


				<para>
					Gathercast interfaces aggregate parameters from
					method invocations from client interfaces into lists
					of invocations parameters, and they redistribute
					results to each client interface.
				</para>

				<section>
					<info>
						<title>
							Gathering of invocation parameters
						</title>
					</info>


					<para>
						Invocation parameters are simply gathered into
						lists of parameters. The indexes of the
						parameters in the list correspond the index of
						the parameters in the list of connected client
						interfaces, managed internally by the gathercast
						interface.
					</para>

					<para>
						<figure>
							<info>
								<title>
									Aggregation of parameters with a
									gathercast interface
								</title>
							</info>


							<mediaobject>
								<imageobject>
									<imagedata scalefit="1" width="100%"
										contentdepth="100%" align="center"
										fileref="components/pics/gathercast-aggregation.png"
										format="PNG" />
								</imageobject>
							</mediaobject>
						</figure>
					</para>
				</section>

				<section>
					<info>
						<title>Redistribution of results</title>
					</info>


					<para>
						The result of the invocation transformed by the
						gathercast interface is a list of values. Each
						result value is therefore indexed and
						redistributed to the client interface with the
						same index in the list of client interfaces
						managed internally by the gathercast interface.
					</para>

					<para>
						Similarly to the distribution of invocation
						parameters in multicast interfaces, a
						redistribution function could be applied to the
						results of a gathercast invocation, however this
						feature is not implemented yet.
					</para>
				</section>
			</section>

			<section>
				<info>
					<title>Binding compatibility</title>
				</info>


				<para>
					Gathercast interfaces manipulate lists of parameters
					(say,
					<literal>List&lt;ParamType&gt;</literal>
					), and return lists of results (say,
					<literal>List&lt;ResultType&gt;</literal>
					). With respect to a gathercast interface, connected
					client interface work with parameters which can be
					contained in the lists of parameters of the methods
					of the bound gathercast interface (ParamType), and
					they return results which can be contained in the
					lists of results of the methods of the bound
					gathercast interface (ResultType).
				</para>

				<para>
					Therefore, by analogy to the case of multicast
					interfaces,
					<emphasis>
						the signatures of methods differ from a
						gathercast server interface to its connected
						client interfaces
					</emphasis>
					. This is illustrated in the following figure: the
					foo method of interfaces which are client of the
					gathercast interface exhibit a parameter of type
					<literal>V</literal>
					, the foo method of the gathercast interface
					exhibits a parameter of type
					<literal>List&lt;V&gt;</literal>
					. Similarly, the foo method of client interfaces
					return a parameter of type
					<literal>T</literal>
					, and the foo method of the gathercast interface
					returns a parameter of type
					<literal>List&lt;T&gt;</literal>
					.
				</para>

				<para>
					The compatibility of interface signatures is
					verified automatically at binding time, resulting in
					a documented IllegalBindingException if signatures
					are incompatible
				</para>

				<figure>
					<info>
						<title>
							Comparison of signature of methods for
							bindings to a gathercast interface
						</title>
					</info>


					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%"
								contentdepth="100%" align="center"
								fileref="components/pics/gathercast-signatures.png"
								format="PNG" />
						</imageobject>
					</mediaobject>
				</figure>
			</section>

			<section>
				<info>
					<title>Process synchronization</title>
				</info>


				<para>
					An invocation from a client interface to a
					gathercast interface is asynchronous, provided it
					matches the usual conditions for asynchronous
					invocations in ProActive, however the gathercast
					interface only creates and executes a new invocation
					with gathered parameters when all connected client
					interfaces have performed an invocation on it.
				</para>

				<para>
					It is possible to specify a timeout, which
					corresponds to the maximum amount of time between
					the moment the first invocation of a client
					interface is processed by the gathercast interface,
					and the moment the invocation of the last client
					interface is processed. Indeed, the gathercast
					interface will not forward a transformed invocation
					until all invocations of all client interfaces are
					processed by this gathercast interface.
				</para>

				<para>
					Timeouts for gathercast invocations are specified by
					an annotation on the method subject to the timeout,
					the value of the timeout is specified in
					milliseconds:
					<programlisting xml:lang="java">
						@org.objectweb.proactive.core.component.type.annotations.gathercast.MethodSynchro(timeout=20)
					</programlisting>
				</para>

				<para>
					If a timeout is reached before a gathercast
					interface could gather and process all incoming
					requests, a
					<literal>
						org.objectweb.proactive.core.component.exceptions.GathercastTimeoutException
					</literal>
					is returned to each client participating in the
					invocation. This exception is a
					<emphasis>runtime</emphasis>
					exception.
				</para>

				<para>
					It is also possible for gathercast interface not to
					wait for all invocations from connected client
					interfaces to perform an invocation by specifying
					the waitForAll attribute. Therefore, the gathercast
					interface will create and execute a new invocation
					on the first invocation received from any of the
					connected client interfaces.
				</para>

				<para>
					Thus, this specific feature can be used by the same
					annotation as for the timeout but with a different
					attribute:
					<programlisting xml:lang="java">
						@org.objectweb.proactive.core.component.type.annotations.gathercast.MethodSynchro(waitForAll=false)
					</programlisting>
					Therefore, the waitForAll attribute accepts boolean
					values and has for default value "true" (same
					behavior as if the annotation is not specified).
				</para>

				<para>
					Furthermore, it is forbidden to combine timeout and
					waitForAll set to false (an
					<literal>
						org.objectweb.fractal.api.factory.InstantiationException
					</literal>
					is raised) because il would be incoherent.
				</para>

			</section>
		</section>
	</section>

	<section>
		<info>
			<title>Implementation specific API</title>
		</info>
		<section>
			<info>
				<title>fractal.provider</title>
			</info>

			<para>
				The API is the same for any Fractal implementation,
				though some classes are implementation-specific:
			</para>

			<para>
				The fractal provider class, that corresponds to the
				<literal>fractal.provider</literal>
				parameters of the JVM, is
				<literal>
					org.objectweb.proactive.core.component.Fractive
				</literal>
				. The
				<literal>Fractive</literal>
				class acts as:
			</para>

			<itemizedlist>
				<listitem>
					<para>a bootstrap component</para>
				</listitem>

				<listitem>
					<para>
						a GenericFactory for instantiating new
						components
					</para>
				</listitem>

				<listitem>
					<para>
						a utility class providing static methods to
						create collective interfaces and retrieve
						references to ComponentParametersController
					</para>
				</listitem>
			</itemizedlist>
		</section>

		<section>
			<info>
				<title>Requirements</title>
			</info>

			<para>
				As this implementation is based on ProActive, several
				conditions are required (more in
				<xref linkend="ActiveObjectCreation" />
				):
			</para>

			<itemizedlist>
				<listitem>
					<para>
						the base class for the implementation of a
						primitive component has to provide a no-argument
						and preferably an empty constructor.
					</para>
				</listitem>

				<listitem>
					<para>
						asynchronous method calls with transparent
						futures is a core feature of ProActive (
						<xref linkend="FutureObjectCreation" />
						), and it allows concurrent processing. Indeed,
						suppose a caller invokes a method on a callee.
						This method returns a result on a component.
						With synchronous method calls, the flow of
						execution of the caller is blocked until the
						result of the method called is received. In the
						case of intensive computations, this can be
						relatively long. With asynchronous method calls,
						the caller gets a future object and will
						continue its tasks until it really uses the
						result of the method call. The process is then
						blocked (it is called wait-by-necessity) until
						the result has effectively been calculated.
					</para>
					<para>
						Thus, for asynchronous invocations, return types
						of the methods provided by the interfaces of the
						components have to be reifiable (Non-final and
						serializable class) and methods must not throw
						exceptions.
					</para>
				</listitem>
			</itemizedlist>
		</section>

		<section>
			<info>
				<title>Content and controller descriptions</title>
			</info>

			<para>
				The controller description and the content description
				of the components, as specified in the method
				<literal>
					public Component newFcInstance(Type type, Object
					controllerDesc, Object contentDesc) throws
					InstantiationException
				</literal>
				of the
				<literal>
					org.objectweb.fractal.api.factory.Factory
				</literal>
				class, correspond in this implementation to the classes
				<literal>
					org.objectweb.proactive.core.component.ControllerDescription
				</literal>
				and
				<literal>
					org.objectweb.proactive.core.component.ContentDescription
				</literal>
				.
			</para>
		</section>
	</section>

	<section>
		<info>
			<title>Advanced</title>
		</info>


		<section
			xml:id="configuration_html_Controllers_and_interceptors_new">
			<info>
				<title>Controllers and interceptors</title>
			</info>


			<para>
				This section explains how to customize the membranes of
				component through the configuration, composition and
				creation of controllers and interceptors.
			</para>

			<section>
				<info>
					<title>Configuration of controllers</title>
				</info>


				<para>
					It is possible to customize controllers, by
					specifying a control interface and an
					implementation.
				</para>

				<para>
					Controllers are configured in a simple XML
					configuration file, which has the following
					structure:
				</para>

				<programlisting xml:lang="xml">
					&lt;componentConfiguration&gt; &lt;controllers&gt;
					&lt;controller&gt;
					&lt;interface&gt;ControllerInterface&lt;/interface&gt;
					&lt;implementation&gt;ControllerImplementation&lt;/implementation&gt;
					&lt;/controller&gt; ...
				</programlisting>

				<para>
					Unless they some controllers are also interceptors
					(see later on), the controllers do not have to be
					ordered.
				</para>

				<para>
					A default configuration file is provided, it defines
					the default controllers available for every
					ProActive component (super, binding, content,
					naming, lifecycle and component parameters
					controllers).
				</para>

				<para>
					A custom configuration file can be specified (in
					this example with "thePathToMyConfigFile") for any
					component in the controller description parameter of
					the newFcInstance method from the Fractal API:
				</para>

				<programlisting xml:lang="java">
					componentInstance = componentFactory.newFcInstance(
					myComponentType, new ControllerDescription( "name",
					myHierarchicalType,
					thePathToMyControllerConfigFile),
					myContentDescription);
				</programlisting>
			</section>

			<section>
				<info>
					<title>Writing a custom controller</title>
				</info>


				<para>
					The controller interface is a standard interface
					which defines which methods are available.
				</para>

				<para>
					When a new implementation is defined for a given
					controller interface, it has to conform to the
					following rules:
				</para>

				<orderedlist>
					<listitem>
						<para>
							The controller implementation must extend
							the AbstractProActiveController class, which
							is the base class for component controllers
							in ProActive, and which defines the
							constructor
							AbstractProActiveController(Component
							owner).
						</para>
					</listitem>

					<listitem>
						<para>
							The controller implementation must override
							this constructor:
						</para>
					</listitem>
				</orderedlist>

				<programlisting xml:lang="java">
					public ControllerImplementation(Component owner) {
					super(owner); }
				</programlisting>

				<orderedlist>
					<listitem>
						<para>
							The controller implementation must also
							override the abstract method
							setControllerItfType(), which sets the type
							of the controller interface:
						</para>
					</listitem>
				</orderedlist>

				<programlisting xml:lang="java">
					protected void setControllerItfType() { try {
					setItfType(ProActiveTypeFactory.instance().createFcItfType(
					"Name of the controller", TypeFactory.SINGLE)); }
					catch (InstantiationException e) { throw new
					ProActiveRuntimeException("cannot create controller
					type: " + this.getClass().getName()); } }
				</programlisting>

				<orderedlist>
					<listitem>
						<para>
							The controller interface and its
							implementation have to be declared in the
							component configuration file.
						</para>
					</listitem>
				</orderedlist>
			</section>

			<section>
				<info>
					<title>Configuration of interceptors</title>
				</info>


				<para>
					Controllers can also act as interceptors: they can
					intercept incoming invocations and outgoing
					invocations. For each invocation, pre and post
					processings are defined in the methods
					beforeInputMethodInvocation,
					afterInputMethodInvocation,
					beforeOutputMethodInvocation, and
					afterOutputMethodInvocation. These methods are
					defined in the interfaces InputInterceptor and
					OutputInterceptor, and take a MethodCall object as
					an argument. MethodCall objects are reified
					representations of method invocations, and they
					contain Method objects, along with the parameters of
					the invocation.
				</para>

				<para>
					Interceptors are configured in the controllers XML
					configuration file, by simply adding
					input-interceptor="true" or/and
					output-interceptor="true" as attributes of the
					controller element in the definition of a controller
					(provided of course the specified interceptor is an
					input or/and output interceptor). For example a
					controller that would be an input interceptor and an
					output interceptor would be defined as follows:
				</para>

				<programlisting xml:lang="xml">
					&lt;componentConfiguration&gt; &lt;controllers&gt;
					.... &lt;controller input-interceptor="true"
					output-interceptor="true" &gt;
					&lt;interface&gt;InterceptorControllerInterface&lt;/interface&gt;
					&lt;implementation&gt;ControllerImplementation&lt;/implementation&gt;
					&lt;/controller&gt; ...
				</programlisting>

				<para>
					Interceptors can be composed in a basic manner:
					sequentially.
				</para>

				<para>
					For input interceptors, the
					beforeInputMethodInvocation method is called
					sequentially for each controller in the order they
					are defined in the controllers configuration file.
					The afterInputMethodInvocation method is called
					sequentially for each controller in the reverse
					order they are defined in the controllers
					configuration file.
				</para>

				<para>
					If in the controller configuration file, the list of
					input interceptors is in this order (the order in
					the controller configuration file is from top to
					bottom):
				</para>

				<screen>InputInterceptor1 InputInterceptor2</screen>

				<para>
					This means that an invocation on a server interface
					will follow this path:
				</para>

				<screen>
					--&gt; caller --&gt;
					InputInterceptor1.beforeInputMethodInvocation --&gt;
					InputInterceptor2.beforeInputMethodInvocation --&gt;
					callee.invocation --&gt;
					InputInterceptor2.afterInputMethodInvocation --&gt;
					InputInterceptor1.afterInputMethodInvocation
				</screen>

				<para>
					For output interceptors, the
					beforeOutputMethodInvocation method is called
					sequentially for each controller in the order they
					are defined in the controllers configuration file.
					The afterOutputMethodInvocationmethod is called
					sequentially for each controller in the reverse
					order they are defined in the
				</para>

				<para>controllers configuration file.</para>

				<para>
					If in the controller configuration file, the list of
					input interceptors is in this order (the order in
					the controller configuration file is from top to
					bottom):
				</para>

				<screen>OutputInterceptor1 OutputInterceptor2</screen>

				<para>
					This means that an invocation on a server interface
					will follow this path
				</para>

				<screen>
					--&gt; currentComponent --&gt;
					OutputInterceptor1.beforeOutputMethodInvocation
					--&gt;
					OutputInterceptor2.beforeOutputMethodInvocation
					--&gt; callee.invocation --&gt;
					OutputInterceptor2.afterOutputMethodInvocation
					--&gt;
					OutputInterceptor1.afterOutputMethodInvocation
				</screen>
			</section>

			<section>
				<info>
					<title>Writing a custom interceptor</title>
				</info>


				<para>
					An interceptor being a controller, it must follow
					the rules explained above for the creation of a
					custom controller.
				</para>

				<para>
					Input interceptors and output interceptors must
					implement respectively the interfaces
					InputInterceptor and OutputInterceptor, which
					declare interception methods (pre/post interception)
					that have to be implemented.
				</para>

				<para>
					Here is a simple example of an input interceptor:
				</para>

				<programlisting xml:lang="java">
					public class MyInputInterceptor extends
					AbstractProActiveController implements
					InputInterceptor, MyController { public
					MyInputInterceptor(Component owner) { super(owner);
					}

					protected void setControllerItfType() { try {
					setItfType(ProActiveTypeFactory.instance().createFcItfType("my
					control\ ler", MyController.class.getName(),
					TypeFactory.SERVER, TypeFactory.MANDATORY,
					TypeFactory.SINGLE)); } catch
					(InstantiationException e) { throw new
					ProActiveRuntimeException("cannot create controller
					" + this.getClass().getName()); } } // foo is
					defined in the MyController interface public void
					foo() { // foo implementation } public void
					afterInputMethodInvocation(MethodCall methodCall) {
					System.out.println("post processing an intercepted
					an incoming functiona\ l invocation"); //
					interception code } public void
					beforeInputMethodInvocation(MethodCall methodCall) {
					System.out.println("pre processing an intercepted an
					incoming functional\ invocation"); // interception
					code } }
				</programlisting>

				<para>The configuration file would state:</para>

				<programlisting xml:lang="xml">
					&lt;componentConfiguration&gt; &lt;controllers&gt;
					.... &lt;controller input-interceptor="true"&gt;
					&lt;interface&gt; MyController &lt;/interface&gt;
					&lt;implementation&gt; MyInputInterceptor
					&lt;/implementation&gt; &lt;/controller&gt; ...
				</programlisting>
			</section>
		</section>

		<section
			xml:id="Lifecycle_encapsulation_of_functional_activity_in_component_lifecycle">
			<info>
				<title>
					Lifecycle: encapsulation of functional activity in
					component lifecycle
				</title>
			</info>


			<indexterm>
				<primary>Lifecycle</primary>

				<secondary>Components</secondary>
			</indexterm>

			<para>
				In this implementation of the Fractal component model,
				Fractal components are active objects. Therefore it is
				possible to redefine their activity. In this context of
				component based programming, we call an activity
				redefined by a user a functional activity.
			</para>

			<para>
				When a component is instantiated, its lifecycle is in
				the STOPPED state, and the functional activity that a
				user may have redefined is not started yet. Internally,
				there is a default activity which handles controller
				requests in a FIFO order.
			</para>

			<para>
				When the component is started, its lifecycle goes to the
				STARTED state, and then the functional activity is
				started: this activity is initialized (as defined in
				InitActive), and run (as defined in RunActive).
			</para>

			<para>
				2 conditions are required for a smooth integration
				between custom management of functional activities and
				lifecycle of the component:
			</para>

			<indexterm>
				<primary>Request Queue</primary>
			</indexterm>

			<orderedlist>
				<listitem>
					<para>
						the control of the request queue must use the
						org.objectweb.proactive.Service class
					</para>
				</listitem>

				<listitem>
					<para>
						the functional activity must loop on the
						body.isActive() condition (this is not
						compulsory, but it allows to automatically end
						the functional activity when the lifecycle of
						the component is stopped. It may also be managed
						with a custom filter).
					</para>
				</listitem>
			</orderedlist>

			<para>
				Control invocations to stop the component will
				automatically set the isActive() return value to false,
				which implies that when the functional activity loops on
				the body.isActive() condition, it will end when the
				lifecycle of the component is set to STOPPED.
			</para>
		</section>

		<section>
			<info>
				<title>Short cuts</title>
			</info>


			<section>
				<info>
					<title>Principles</title>
				</info>


				<para>
					Communications between components in a hierarchical
					model may involve the crossing of several membranes,
					and therefore paying the cost of several
					indirections. If the invocations are not intercepted
					in the membranes, then it is possible to optimize
					the communication path by shortcutting:
					communicating directly from a caller component to a
					callee component by avoiding indirections in the
					membranes.
				</para>

				<para>
					In the Julia implementation, a shortcut mechanism is
					provided for components in the same JVM, and the
					implementation of this mechanism relies on code
					generation techniques.
				</para>

				<para>
					We provide a shortcut mechanism for distributed
					components, and the implementation of this mechanism
					relies on a "tensioning" technique: the first
					invocation determines the shortcut path, then the
					following invocations will use this shortcut path.
				</para>

				<para>
					For example, in the following figure, a simple
					component system, which consists of a composite
					containing two wrapped primitive components, is
					represented with different distributions of the
					components. In a, all components are located in the
					same JVM, therefore all communications are local
					communications. If the wrapping composites are
					distributed on different remote JVMs, all
					communications are remote because they have to cross
					composite enclosing components. The short cut
					optimization is a simple bypassing of the wrapper
					components, which results in 2 local communications
					for the sole functional interface.
				</para>

				<figure>
					<info>
						<title>
							Using shortcuts for minimizing remote
							communications.
						</title>
					</info>


					<mediaobject>
						<imageobject>
							<imagedata scalefit="1" width="100%"
								contentdepth="100%" fileref="components/pics/shortcuts.png"
								format="PNG" />
						</imageobject>
					</mediaobject>
				</figure>
			</section>

			<section>
				<info>
					<title>Configuration</title>
				</info>


				<para>
					Shortcuts are available when composite components
					are synchronous components (this does not break the
					ProActive model, as composite components are
					structural components). Components can be specified
					as synchronous in the ControllerDescription object
					that is passed to the component factory:
				</para>

				<programlisting xml:lang="java">
					ControllerDescription controllerDescription = new
					ControllerDescription("name", Constants.COMPOSITE,
					Constants.SYNCHRONOUS);
				</programlisting>

				<para>
					When the system property
					proactive.components.use_shortcuts is set to true,
					the component system will automatically establish
					short cuts between components whenever possible.
				</para>
			</section>
		</section>
	</section>
</chapter>

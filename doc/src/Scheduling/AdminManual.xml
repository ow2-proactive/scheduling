<?xml version="1.0" encoding="utf-8"?>
<!--  <!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN" "../docbook.dtd" />  -->
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="admin_manual"><info><title>Administration guide</title></info>
	<section xml:id="scheduler_architecture"><info><title>Scheduler Architecture</title></info>
			<section xml:id="Scheduler_Global_Architecture"><info><title>Scheduler Global Architecture</title></info>
				<para>
					The ProActive Scheduler Service is the result of a collaboration between 2 entities (the ProActive Scheduler and the Resource
					Manager). Each one of them has its own functionality.
				</para>
				<para>
					The ProActive Scheduler is the main entity and is a non GUI daemon which is connected to the Resources Manager. It is in
					charge of scheduling submitted jobs in accordance with the scheduling policy.
				</para>
				<para>
					In order to launch jobs, the ProActive Scheduler has to obtain nodes (resources) from the Resources Manager.
					As described hereafter, the user interacts only with the ProActive Scheduler entity and
					the managed resources can be simple hosts or peer to peer resources. For full documentation about the Resource Manager,
					please refer to its own documentation.
				</para>
				<figure xml:id="Scheduler_2_entities"><info><title>The ProActive Scheduler Entities</title></info>
					<mediaobject>
						<imageobject>
							<imagedata width="55%" align="center" fileref="images/png/admin_manual/scheduler2entities.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					<emphasis role="bold">In this section</emphasis>,
					we will explain how the <emphasis role="bold"> scheduler entity works and how it can be used.</emphasis>
				</para>
			</section>

			<section xml:id="Scheduler_entity_Architecture"><info><title>Scheduler Entity Architecture</title></info>
				<para>
					The architecture of the ProActive Scheduler (<xref linkend="Scheduler_entity"/>) is built around 3 Active Objects:
					To know more about Active Object, please refer to the ProActive Documentation.
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">The Authentication interface</emphasis>
							which is the first object that the user may have to contact. It is in charge of authenticating
							the user and allowing him to access (or not) to the Scheduler. The authentication security system
							can interact with files or LDAP.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">The Front-end</emphasis>
							which is the interface returned by the Authentication Interface and allows interaction
							with the ProActive Scheduler. This interface allows users to submit jobs, get scheduling state, retrieves
							job result...
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">The Core</emphasis>
							which is the main entity of the ProActive Scheduler. It is in charge of scheduling Jobs according with the
							policy (FIFO by default), retrieving scheduling events to the user and making storages.
						</para>
					</listitem>
				</itemizedlist>
				<para>
					Users cannot interact directly with the ProActive Scheduler Core. They have to use the Front-end gateway.
				</para>
				<figure xml:id="Scheduler_entity"><info><title>The ProActive Scheduler Entity</title></info>
					<mediaobject>
						<imageobject>
							<imagedata width="90%" align="center" fileref="images/png/admin_manual/schedulerEntity.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
			</section>
		</section>

	<section xml:id="Start_scheduler"><info><title>Start the ProActive Scheduler</title></info>
			<para>
				The ProActive Scheduler has to be started with
				a database that will be used to save scheduling process in case of crash.
				It allows the ProActive Scheduler to restart with a consistent state.
				The ProActive Scheduler will either use an existing database or create a new one if it cannot find one.
				(Supported databases are Java DERBY and MySQL)
				<itemizedlist>
					<listitem>
						<para>
							The database get its properties in the <emphasis>config/scheduler/database/hibernate/hibernate.cfg.xml</emphasis> configuration file.
							Here is an example of configuration:
						</para>
						<programlisting language="xml">
&lt;property name="connection.driver_class"&gt;org.apache.derby.jdbc.EmbeddedDriver&lt;/property&gt;
&lt;property name="connection.url"&gt;jdbc:derby:../../SCHEDULER_DB;create=true&lt;/property&gt;
&lt;property name="connection.username"&gt;scheduler&lt;/property&gt;
&lt;property name="connection.password"&gt;&lt;/property&gt;
&lt;!-- Derby dialect  --&gt;
&lt;property name="dialect"&gt;org.hibernate.dialect.DerbyDialect&lt;/property&gt;
						</programlisting>
						<itemizedlist>
							<listitem><para>
								<emphasis>driver_class</emphasis> defines which driver to use for the current dataBase implementation.
								</para>
							</listitem>
							<listitem><para>
								<emphasis>url</emphasis> defines the protocol, the url and the name used for this dataBase. The goal of this two first properties is
								to provide a way to change the implementation of the database and its directory. To start the Scheduler
								with the provided implementation, just don't modify them.</para>
							</listitem>
							<listitem><para>
								<emphasis>username</emphasis> is the user name authorized to create and manage the database ('scheduler' by default)</para>
							</listitem>
							<listitem><para>
								<emphasis>password</emphasis> is the password of the authorized user (empty by default)</para>
							</listitem>
							<listitem><para>
								<emphasis>dialect</emphasis> If you intend to change the database implementation, don't forget to change the dialect
								to match the given implementation.</para>
							</listitem>
						</itemizedlist>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				It is also possible to configure some properties that rely on the Scheduler. The file
				<emphasis>settings.ini</emphasis> in the <emphasis>config/scheduler</emphasis> directory contains
				every property that can be modified by administrator. The <emphasis>PASchedulerProperties</emphasis> class
				provide a way to override this file with your own one. If you do so, every overridden properties will be used.
				It is not necessary to specify every properties inside your own file.
				Here's a way to override default PAScheduler properties file by the code:
			</para>
			<programlisting language="java">
PASchedulerProperties.updateProperties("your_property_file");
			</programlisting>
			<para>
				The last method to override a property is to specify it into the the java command line using the -d option.
				You just have to name the property as it is done in the properties file, and give it a value.
				(ex: java -dpa.scheduler.core.nodepingfrequency=30000...). Such a property can be added in the provided scripts
				(scheduler-start[.bat] for example).
			</para>
			<para>
				The priority order between two definition of a same property is as follows:
				the definition with the highest priority is those defined using the Java command line, then it is the one defined in your own properties file and
				finally, the lowest priority is given to the default definition.
			</para>
			<para>
				Let's go on to the startup of the ProActiveScheduler. To start it with a shell command, go on to the next section.
				To start it using the Java API, please refer to <xref linkend="Start_scheduler_java"/>.
			</para>
			<section xml:id="PASchedulerProperties"><info><title>ProActive Scheduler properties</title></info>
				<para>
					<emphasis>Note1: </emphasis> some properties require a file path. File path can be given relative, and if so,
					if will be relative to the Scheduler home directory (i.e. to the application root directory) OR with an absolute path.
					Also note that each property can be overridden by using the JVM properties when starting the Scheduler.
					(i.e. scheduler-start[.bat] -Dpa.scheduler.core.timeout=1000)
				</para>
				<para>
					<emphasis>Note2: </emphasis> the main properties file could be found at
					'config/scheduler/settings.ini'
				</para>
				<para>
					<emphasis>Scheduler properties</emphasis>
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.home</emphasis>:
							defines Scheduler home directory. The home directory is the one containing the dist, doc, lib, classes, config
							directory (default is ., the current directory).
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.core.timeout</emphasis>: timeout used in the main scheduling loop. If no new request is received by the SchedulerCore entity,
							no new resources are available, and tasks are running, it is the time to wait before the next scheduling loop specified in milliseconds
							(default is 2000ms).
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.core.nodepingfrequency</emphasis>: time interval between each failed node checking specified in second (default is 20s).
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.classserver.usecache</emphasis>: boolean that specifies if the class definitions used in task class servers must be cached or not.
							Set to false to preserve memory usage in SchedulerCore (default is true).
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.classserver.tmpdir</emphasis>: directory used to store a job classpath. If this value is not set,
							it uses the default TMP directory (default is not set).
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.policy</emphasis>: Scheduler default policy full name (default is org.ow2.proactive.scheduler.policy.DefaultPolicy).
							The policy specifies here has to be in the Scheduler classpath.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.forkedtask.security.policy</emphasis>: Forked java task default security policy path.
							Uses to define the policy of the forked task (default is config/scheduler/forkedJavaTask/forkedTask.java.policy).
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.core.jmx.connectorname</emphasis>: Name of the JMX Connector for the Scheduler (default is 'JMXSchedulerAgent')
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.core.jmx.port</emphasis>: Port number used by JMX.
							This port is used only for JMX service and the RMI protocol. It will create a RMI registry if needed.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.account.refreshrate</emphasis>: Accounting refresh rate from the database.
							Amount of time between request to the DB for accounting purpose. (Value specified in seconds, default is 10)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.core.usersessiontime</emphasis>:
							user is automatically disconnect after this time if no request is made to the scheduler, it can be used to restrict
							the duration of a session.
							Negative number indicates that session is infinite (value specified in second)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.core.starttask.timeout</emphasis>: Timeout for the start task action.
							Time during which the scheduling process could be waiting. This value relies on the system and network capacity
							(Value specified in milliseconds, default is 2000)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.core.starttask.threadnumber</emphasis>: Maximum number of threads used
							for the start task action. This property define the number of blocking resources until the scheduling loop will block as well.
							(default is 5)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.core.listener.threadnumber</emphasis>: Maximum number of threads used
							to send events to clients. This property defines the number of clients than can block at the same time.
							If this number is reached, every clients won't receive events until a thread unlock.
							(default is 5)
						</para>
					</listitem>
				</itemizedlist>
				<para>
					<emphasis>Jobs properties</emphasis>
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.job.factor</emphasis>: Number used to create task IDs.
							If the job number is 123 and it contains 456 tasks and this property is set to 1000, then the task ID
							will be 123456. If this property is set to 10000, the task ID will be 1230456.
							Task ID is (jobId*this_factor+taskId). (default is 10000)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.core.removejobdelay</emphasis>: time interval between the retrieval of a job result and its suppression from the Scheduler
							specified in second. Set this time to 0 if you don't want the job to be remove anyway. (default is 3600)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.core.automaticremovejobdelay</emphasis>: Automatic remove job delay.
							(The time between the termination of the job and removing it from the scheduler).
							Set this time to 0 if you don't want the job to be remove automatically.
							(Value specified in seconds, default is 0)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.job.removeFromDataBase</emphasis>: According to the previous property,
							removes the job also in dataBase when removing it from scheduler. (default is false)
						</para>
					</listitem>
				</itemizedlist>
				<para>
					<emphasis>Tasks properties</emphasis>
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.task.initialwaitingtime</emphasis>: time to wait for when a task has had a faulty state,
							specified in millisecond.
							For performance reason, if the task is faulty, it is not restarted immediately. This property defines the initial
							time to wait. Next waiting time is computed following this function: newTimeToWait=previousTimeToWait+n*1000 where n is
							the number of re-execution of the task. The new time to wait is capped to 60000ms. (default is 1000ms)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.task.numberofexecutiononfailure</emphasis>: number of execution
							allowed if a task failed. The difference between faulty and failed is the state of the resource on which
							the task is executed. Most of the time, a failure is detected if a task kill a resource. In this case,
							this property defines the number of execution allowed for this kind of potentially harmful task.
							(default is 2, so one retry)
						</para>
					</listitem>
				</itemizedlist>
				<para>
					<emphasis>DataSpaces properties</emphasis>
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.dataspace.defaultinputurl</emphasis>:
							Default INPUT space URL. Used to define INPUT space of each job that does
							not define an INPUT space.
							This URL can be HTTP, FTP, file system provided by ProActive: PAPRMI...
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.dataspace.defaultinputurl.localpath</emphasis>:
							Default INPUT space path. Used to define the same INPUT space but with
							a local (faster) access (if possible).
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.dataspace.defaultinputurl.hostname</emphasis>:
							Host name from which the input localpath is accessible.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.dataspace.defaultoutputurl</emphasis>:
							Default OUTPUT space URL. Used to define OUTPUT space of each job that does
							not define an OUTPUT space.
							This URL can be, FTP, file system provided by ProActive: PAPRMI... and cannot be HTTP
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.dataspace.defaultoutputurl.localpath</emphasis>:
							Default OUTPUT space path. Used to define the same OUTPUT space but with
							a local (faster) access (if possible).
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.dataspace.defaultoutputurl.hostname</emphasis>:
							Host name from which the output localpath is accessible.
						</para>
					</listitem>

				</itemizedlist>
				<para>
					<emphasis>Logs properties</emphasis>
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.logs.provider</emphasis>: full class name of logs forwarding method.
							Logs forwarding is the system used to forward logs from task execution to user. Possible values are:
							<itemizedlist>
								<listitem>
									<para>
										org.ow2.proactive.scheduler.common.util.logforwarder.providers.SocketBasedForwardingProvider for simple socket.
										This one uses simple Java socket.
									</para>
								</listitem>
								<listitem>
									<para>
									org.ow2.proactive.scheduler.common.util.logforwarder.providers.SocketWithSSHTunnelBasedForwardingProvider for SSH tunneled socket.
									This one uses Java socket with SSH tunneling for secure communication.
									</para>
								</listitem>
								<listitem>
									<para>
									org.ow2.proactive.scheduler.common.util.logforwarder.providers.ProActiveBasedForwardingProvider for ProActive based communication.
									This one uses ProActive communication, safer but slower.
									</para>
								</listitem>
							</itemizedlist>
							(Default is org.ow2.proactive.scheduler.common.util.logforwarder.providers.ProActiveBasedForwardingProvider)
						</para>
					</listitem>
				</itemizedlist>
				<para>
					<emphasis>Authentication properties</emphasis>
				</para>
				<itemizedlist>

					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.auth.jaas.path</emphasis>:
							Jaas module configuration, describing which authentication method are available.
							(default is config/authentication/jaas.config)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.auth.privkey.path</emphasis>:
							Scheduler private key, to decrypt credentials encrypted on client side
							with the related public key. Once decrypted, credentials are passed to the appropriate Jaas module.
							(default is config/authentication/keys/priv.key)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.auth.pubkey.path</emphasis>:
							Scheduler public key, used to encrypt clear credentials on user side before making
							them transit on the network. Needs to be known on server side so that the Scheduler can offer
							the key to clients asking for it.
							(default is config/authentication/keys/pub.key);
						</para>
					</listitem>

					<listitem>
						<para>
							<emphasis role="italics">pa.ldap.config.path</emphasis>:
							LDAP Authentication configuration file path, used to set LDAP configuration properties.
							(default is config/authentication/ldap.cfg)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.core.defaultloginfilename</emphasis>:
							Login file name for file authentication method.
							(default is config/authentication/login.cfg)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.core.defaultgroupfilename</emphasis>:
							Group file name for file authentication method.
							(default is config/authentication/group.cfg)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.core.authentication.loginMethod</emphasis>:
							Property that defines the method that has to be used for logging users to the Scheduler.
							It can be one of the following values:
							<itemizedlist>
								<listitem>
									<para>
										SchedulerFileLoginMethod to use file login and group management
									</para>
								</listitem>
								<listitem>
									<para>
										SchedulerLDAPLoginMethod to use LDAP login management
									</para>
								</listitem>
							</itemizedlist>
							(default is SchedulerFileLoginMethod)
						</para>
					</listitem>
				</itemizedlist>
				<para>
					<emphasis>Resources manager related properties</emphasis>
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.resourcemanager.authentication.credentials</emphasis>:
							Path to the Scheduler credentials file for RM authentication. (default is config/authentication/scheduler.cred)
						</para>
					</listitem>
				</itemizedlist>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.resourcemanager.authentication.single</emphasis>:
							Use single or multiple connection to RM : If true the scheduler user will do the requests to RM,
							if false each Scheduler users have their own connection to RM using their scheduling credentials
							(default is true)
						</para>
					</listitem>
				</itemizedlist>
				<para>
					<emphasis>Hibernate properties</emphasis>
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.db.hibernate.configuration</emphasis>:
							Hibernate main configuration file (default is config/scheduler/database/hibernate/hibernate.cfg.xml)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="italics">pa.scheduler.db.hibernate.dropdb</emphasis>:
							Drop database before creating a new one : default false
							If this value is true, the database will be dropped and then re-created
							If this value is false, database will be updated from the existing one.
						</para>
					</listitem>
				</itemizedlist>
			</section>
			<section xml:id="Start_scheduler_sh"><info><title>Start the Scheduler using shell command</title></info>
				<para>
					To start a local scheduler, run the <emphasis>scheduler-start[.bat]</emphasis>
					script in 'bin/[os]/' directory. Without arguments, the ProActive Scheduler will start on the local
					host and will try to connect to a started local Resources Manager with the default database configuration file.
					If no Resources Manager exists, it will create its own Resources Manager.
					Note that the database will be created if it does not exist.
				</para>
				<para>
					<emphasis>scheduler-start[.bat]</emphasis> can be started with 2 optional arguments (use -h option to see
					a description of the available options):
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>The URL of a Resources Manager</emphasis> already started (using the "-u URL" option).
								If you don't use this, it will try to connect to a started Resource Manager on the local host.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>The scheduling policy</emphasis> that will be started with the Scheduler
								(using "-p org.ow2.proactive.scheduler.policy.DefaultPolicy" option).
								By default, it will use the <emphasis>DefaultPolicy</emphasis> provided with the package.
							</para>
						</listitem>
					</itemizedlist>
				</para>
				<para>
					For example, the following line will launch a scheduler on a Resource Manager started on "localhost" (which is in fact, the same as 'no argument'). It will also use
					the 'DefaultPolicy' scheduling policy:
				</para>
				<para>
					<code>scheduler-start[.bat] -u rmi://localhost/ -p org.ow2.proactive.scheduler.policy.DefaultPolicy</code>
				</para>
				<para>
					By default, the "config/authentication/" directory has to contain the two authentication files (group and login).
					The "config/scheduler/database/hibernate" directory has to contain the "hibernate.cfg.xml" configuration file.
				</para>
				<para>
					It is also possible to launch the ProActive Scheduler with only one of these options or without option at all. For more
					informations, use -h (or --help) option (i.e. "scheduler-start[.bat] -h").
				</para>
			</section>
			<section xml:id="Start_scheduler_java"><info><title>Start the Scheduler using the Java API</title></info>
				<para>
					You can start the ProActive Scheduler using the Java API. Supposing that a Resource Manager is already started on toto
					(see Resource Manager documentation to create a resource Manager),
					here's a complete example showing how to start both Scheduler and Resource Manager (assuming the JVM is totally clean ):
				</para>
				<programlisting language="java">

RMInitializer init = new RMInitializer();
init.setRMHomePath("/path/to/RM/home");
init.setLog4jConfiguration("/path/to/log4j");
init.setJavaSecurityPolicy("/path/to/securityPolicy");
init.setProActiveConfiguration("/path/to/PAconfigurationFile");
init.setResourceManagerPropertiesConfiguration("/path/to/RMPropertiesFile");
System.out.println("Starting RM, please wait...");
RMAuthentication rmAuth = RMFactory.startLocal(init);
System.out.println("RM successfully started at : " + rmAuth.getHostURL());

//starting scheduler...
//initializer is optionnal if the JVM already specified the following variables
SchedulerInitializer init = new SchedulerInitializer();
init.setSchedulerHomePath("/path/to/Scheduler/home");
init.setProActiveConfiguration("/path/to/PAconfigurationFile");
init.setSchedulerPropertiesConfiguration("/path/to/SchedulerPropertiesFile");
init.setPolicyFullClassName(DefaultPolicy.class.getName());

System.out.println("Starting Scheduler, please wait...");
SchedulerAuthenticationInterface sAuth = SchedulerFactory.startLocal(rmAuth.getHostURL(),init);
System.out.println("Scheduler successfully started at : " + sAuth.getHostURL());

				</programlisting>
				<para>
					Every thing could be started in different JVM and also without using the initializer.
					The example below shows how to start both RM and Scheduler assuming that the following variables
					are defined at JVM start up :
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>-Djava.security.manager :</emphasis> to activate the security manager
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>-Dproactive.configuration=/path/to/pa_conf.xml :</emphasis>
								to set the location of the PA Configuration file
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>-Djava.security.policy=/path/to/security_file :</emphasis>
								to set the path of the java security policy file
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>-Dlog4j.configuration=file:/path/to/log4j_file :</emphasis>
								to set the file of the log4j configuration file (ex: scheduler-log4j-server).
								The <emphasis>file:</emphasis> protocol is mandatory for this property.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>-Dpa.rm.home=/path/to/rm_home :</emphasis>
								the root path of the RM install.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>-Dpa.scheduler.home=/path/to/scheduler_home :</emphasis>
								the root path of the Scheduler install.
							</para>
						</listitem>
					</itemizedlist>
				</para>
				<programlisting language="java">

System.out.println("Starting RM, please wait...");
RMAuthentication rmAuth = RMFactory.startLocal();
System.out.println("RM successfully started at : " + rmAuth.getHostURL());

//starting scheduler...
System.out.println("Starting Scheduler, please wait...");
SchedulerAuthenticationInterface sAuth = SchedulerFactory.startLocal(rmAuth.getHostURL(),DefaultPolicy.class.getName());
System.out.println("Scheduler successfully started at : " + sAuth.getHostURL());

				</programlisting>
				<para>
					<emphasis role="bold">NOTE: </emphasis>
					By default, authentication are provided by the 2 files into the <emphasis>config/authentication</emphasis> directory.
					This files contains username, password and their groups.
					A LDAP authentication module is also available to replace authentication files (login.cfg and group.cfg) security
					module by a LDAP security module.
					To do so, just go into the <emphasis>config/scheduler/settings.ini</emphasis> configuration file and change the value
					of the property <emphasis>pa.scheduler.core.authentication.loginMethod</emphasis> to "SchedulerLDAPLoginMethod".
					Information about your own LDAP configuration can be set in the <emphasis>ldap.cfg</emphasis> into the "config/authentication" directory.
				</para>
				<para>
					Another way is to start the ProActive Scheduler AND connect an administrator at the same time:
				</para>
				<programlisting language="java">
SchedulerFactory.createScheduler(
	credentials,
	new URI("rmi://host:port/"),
	"org.ow2.proactive.scheduler.policy.DefaultPolicy");
				</programlisting>
				<para>
					where arguments are the sames plus a <emphasis>credentials</emphasis>
					that authenticate the administrator who wants to connect. The user has to be in the login file and
					his group has to be 'admin' in the group file.
				</para>
			</section>
		</section>
		<section xml:id="About_job_submission"><info><title>About job submission</title></info>
			<para>
				According to the user manual, once connected, a user is ready to submit jobs. Here is a short explanation
				that describes the mechanism of submission.
				The <emphasis role="bold"> Authentication interface entity is no longer used</emphasis> for this connected user.
				<xref linkend="Job_submission"/> shows what happens when the Scheduler received a new job to schedule.
				<figure xml:id="Job_submission"><info><title>A job submission</title></info>
					<mediaobject>
						<imageobject>
							<imagedata width="90%" align="center" fileref="images/png/admin_manual/jobSubmission.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				<orderedlist>
					<listitem>
						<para>
							First, the user submits a Job using his <emphasis role="bold">UserSchedulerInterface</emphasis>
							retrieved by the <emphasis role="bold">logAsUser</emphasis> method. Let's remind it (see
							<xref linkend="Submit_a_job_java"/> for how to use Credentials):
							<programlisting language="java">
// connecting to the scheduler
SchedulerAuthenticationInterface auth = SchedulerConnection.join("rmi://localhost");
// checking username and password
Scheduler scheduler = auth.login(Credentials.getCredentials());
// submitting a new job and get the associated id
JobId myJobId = scheduler.submit(job);
							</programlisting>
						</para>
					</listitem>
					<listitem>
						<para>
							The Scheduler Front-end checks the integrity of the job, and builds it
							in order to be ready to be managed by the Scheduler Core. If there is a
							problem, an exception is thrown explaining the cause of this problem.
						</para>
					</listitem>
					<listitem>
						<para>
							Finally, the job is transmitted to the Core for scheduling.
						</para>
					</listitem>
				</orderedlist>
			</para>
		</section>
		<section xml:id="Administer_scheduler"><info><title>Administer the ProActive Scheduler</title></info>
			<para>
				As an administrator, it is possible to ask the Scheduler to start and stop, to kill jobs, set jobs priority, and so on...
				To start a command line administrator, go on to the next section. To use the Java API to manage it, please refer to
				<xref linkend="Administer_scheduler_java"/>.
			</para>
			<section xml:id="Administer_scheduler_sh"><info><title>Administer the Scheduler using shell command</title></info>
				<para>
					The admin Scheduler controller is an interface which allows to administer the ProActive Scheduler without the
					java API. It is also possible to see exceptions coming from the scheduler to know what happened.
					To start a admin controller, run the <emphasis>scheduler-client[.bat]</emphasis>
					script in 'bin/[os]/' directory. It works in the same manner as the user controller (<xref linkend="scheduler_controller"/>)
					but some administration functions have been added. Note that the admin controller uses administrator rights to allow
					the connection to the scheduler.
				</para>
				<para>
				This controller provides additional controls compared to the user one. Here is the help of the admin one.
				To understand how to use it, please refers to the <xref linkend="scheduler_controller"/> section.
			</para>
			<para>
				Here is the displayed help when using <emphasis>scheduler-client[.bat] -h</emphasis> command:
				<figure xml:id="scheduler_controller_admin_help"><info><title>Scheduler admin controller help</title></info>
					<mediaobject>
						<imageobject>
							<imagedata width="100%" align="center" fileref="images/png/admin_manual/scheduler-admin-h.png" format="PNG"/>
						</imageobject>
					</mediaobject>
				</figure>
				As shown, their are additional controls as start(), stop(), kill(), shutdown(), etc... An administrator can also interact on
				every job while the user can only manage jobs that belong to him.
			</para>
			</section>
			<section xml:id="Administer_scheduler_java"><info><title>Administer the Scheduler using the Java API</title></info>
				<para>
					Let's first explain the connection mechanism.
					A user can connect to the ProActive Scheduler only if he/she is known. That is the goal of the
					authentication interface which is able to authenticate users.
					Following figure shows how the ProActive Scheduler connects a user.
					<figure xml:id="userConnection"><info><title>A user connection</title></info>
						<mediaobject>
							<imageobject>
								<imagedata width="90%" align="center" fileref="images/png/admin_manual/userConnection.png" format="PNG"/>
							</imageobject>
						</mediaobject>
					</figure>
					<orderedlist>
						<listitem>
							<para>
								First of all, a user tries to join the authentication interface using the
								<emphasis role="bold">SchedulerConnection.join(...)</emphasis> static method.
								It is also possible to use the SchedulerConnection.waitAndJoin(...) that will join the scheduler and wait
								for the connection to be established or an error to be raised.
							</para>
							<programlisting language="java">
SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/");
							</programlisting>
							<para>
								Then, with the <emphasis role="bold">SchedulerAuthenticationInterface</emphasis>,
								users can be connected as client using the
								<emphasis role="bold">login</emphasis> method
								(see <xref linkend="Submit_a_job_java"/> for how to use Credentials).
							</para>
							<programlisting language="java">
Scheduler scheduler = auth.login(Credentials.getCredentials());
							</programlisting>
						</listitem>
						<listitem>
							<para>
								Next, the authentication object checks the users rights and whether
								the user is authorized to connect the scheduler. If not, an exception will be thrown.
							</para>
						</listitem>
						<listitem>
							<para>
								Once connected, the authentication object sends the right and
								username/password to the scheduler front-end which will be able to
								authenticate user on its own.
							</para>
						</listitem>
						<listitem>
							<para>
								If nothing goes wrong, the authentication interface will return a
								<emphasis role="bold">Scheduler</emphasis>
								which is in fact a direct link to the <emphasis role="bold">Front-end</emphasis>.
							</para>
						</listitem>
						<listitem>
							<para>
								The client is now able to interact with the Scheduler using the returned interface.
							</para>
						</listitem>
					</orderedlist>
				</para>
				<para>
					And now, to administer the ProActive Scheduler, just connect to it if it is not already done and use the
					<emphasis role="bold">Scheduler</emphasis> to manage it. Take a look at the JavaDocumentation
					to get more details and features. Let's remind how to connect the Scheduler as an administrator (see
					<xref linkend="Submit_a_job_java"/> for how to use Credentials):
				</para>
				<programlisting language="java">
SchedulerAuthenticationInterface auth = SchedulerConnection.join("//host/");
Scheduler scheduler = auth.login(Credentials.getCredentials());
				</programlisting>
				<para>
					Then, use the returned 'scheduler' object to communicate with the ProActive Scheduler as an administrator. One interesting thing
					is to change the policy during the scheduling, that will consequently change the remaining
					scheduling order. Refer to the <xref linkend="Extend_scheduler_policy"/> to make your own policy and change it as
					shown below:
				</para>
				<programlisting language="java">
//scheduler is the AdminSchedulerInterface returned in the previous sections
scheduler.changePolicy(org.ow2.proactive.scheduler.policy.DefaultPolicy.class);
				</programlisting>
			</section>
		</section>
		<section xml:id="scheduler_nodeconf_admin"><info><title>Special Scheduling configuration for node</title></info>
			<para>
				Nodes can also be configured. Here after are described the properties used by the JVM on node side :
			</para>
			<para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis>pas.launcher.extraclasspath.directory</emphasis> (previously pa.scheduler.extraclasspath.dir) specifies
							the path of an extra classpath directory. This can be usefull to add personal
							classes to the default node classpath.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>pas.launcher.logs.maxsize</emphasis> (previously proactive.scheduler.logs.maxsize) specifies
							the cached max size of the logs. It is also the max size of the returned logs at the
							end of the task. 
							If a client listen to the logs after the start of the task, it is the
							max size of already generated logs returned in the listened logs events stream.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>pas.launcher.getprogress.directory</emphasis> (used by native tasks only)
							specifies the directory where to find task progress file content. If a native task
							wants its progress be available by client, the task must write an integer between 0 and 100
							(both included) defining the current progress of the task in a file named [taskId].progress in this
							property directory.
						</para>
						<para>
							<emphasis role="italics">For example :</emphasis> if the node has been started with -Dpas.launcher.getprogress.directory=/tmp/progress,
							and a native task of job 13 wants its progress to be available, the task must write a file named "/tmp/progress/130004.progress"
							where 130004 is the taskId of the running task (taskId can be get using PAS_TASK_ID system environment variable)
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>pas.launcher.forkas.method</emphasis> (used with runAsMe=true option)
							specifies the method to be used when JVM is forked :
							<itemizedlist>
								<listitem>
									<para>
										"none" : no method is used, user cannot execute task under his account
									</para>
								</listitem>
								<listitem>
									<para>
										"pwd" : password method is used, user will start the task using his scheduling login and password.
										On Unix, if sudoer list is used, user will be authenticated using his username only.
									</para>
								</listitem>
								<listitem>
									<para>
										"key" : ssh private key is used, user must provide a credentials containing login//password
										and a private ssh key provided by administrator to allow user to execute process with ssh on localhost.
									</para>
								</listitem>
							</itemizedlist>
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>node.dataspace.scratchdir</emphasis> specifies the root path of the SCRATCH directory
							used by dataspace. By default, it is the JVM default system temp dir.
							This property is automatically propagated in the forked JVM if forked task is used.
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</section>
		<section xml:id="scheduler_dataspaces_admin"><info><title>Configuring DataSpaces</title></info>
			<para>
				The only things to configure in the DataSpace are the default INPUT and OUTPUT spaces.
				If not configured, it will use the default temporary directory of the system.
				To the default tmp dir, "scheduling/" will first be appended and then the 'defaultinput' and 'defaultoutput' directories.
				Finally, the username of the job owner will be also added to the previous path.
				For instance, if "defaultinput" is set to "myInput" and my username is "myUserName", then my INPUT data space will be
				<emphasis>/tmp/scheduling/myInput/myUserName</emphasis> (if the temporary directory is /tmp).
			</para>
			<para>
				For example, to set the default INPUT space of the scheduler, just set the 3 following properties:
				<itemizedlist>
					<listitem>
						<para>
							<emphasis>pa.scheduler.dataspace.defaultinputurl=http://myFileServer.myCompagny.com/files</emphasis>
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>#pa.scheduler.dataspace.defaultinputurl.localpath</emphasis>
							leave it commented for this example.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>#pa.scheduler.dataspace.defaultinputurl.hostname</emphasis>
							leave it commented for this example.
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				It is also possible to set a remote files system as a server of files thanks to the ProActive
				data server. In this new example, just locate the path to be served and start the ProActive
				data server: <emphasis>pa-dataserver[.bat] D:\scheduling\outputSpace myOutput</emphasis>.
				The first argument is the absolute path to the root space directory, the second one is
				the name of the server (could be useful to start more than one server on the same host).
			</para>
			<para>
				Once launched, the server will retrieve an URL of the form:
				<emphasis>paprmi://toto.company.com:1099/myOutput?proactive_vfs_provider_path=/</emphasis>. Just put this
				URL in the scheduler settings:
				<itemizedlist>
					<listitem>
						<para>
							<emphasis>pa.scheduler.dataspace.defaultoutputurl=paprmi://toto.company.com:1099/myOutput?proactive_vfs_provider_path=/</emphasis>
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>pa.scheduler.dataspace.defaultoutputurl.localpath=D:\scheduling\outputSpace</emphasis>
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>pa.scheduler.dataspace.defaultoutputurl.hostname=toto</emphasis>
							this value allows a task executed on 'toto' to handle files using the direct access (localpath above).
							This could be great for performance issues.
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</section>
		<section xml:id="configuring_task_runasme"><info><title>Configuring task for execution under user account</title></info>
				<para>
					To allow scheduler users to run task under their account login and password, administrator must configure workers
					machines (user name//password must be the same as system user name//password) :
					<orderedlist>
						<listitem>
							<para>
								<emphasis>At system level :</emphasis> Every host machine where tasks will be executed under user account
								must accept such an execution, the following describe the different system requirement :
							</para>
							<itemizedlist>
								<listitem>
									<para>
										<emphasis>On unix system :</emphasis> There are 3 possible ways to allow a user to do so.
										For each method, user account must be accessible (created or mount) from host (node) :
										<orderedlist>
											<listitem>
												<para>
													<emphasis role="italics">Use login authentication only :</emphasis>
													User login (that is scheduler login also) must be put in sudoer list. In this case, scheduler
													user could start process using his login only.
												</para>
											</listitem>
											<listitem>
												<para>
													<emphasis role="italics">Use login//password authentication :</emphasis>
													User login and password (that is scheduler login//password also) will be used to authenticate user on the node.
													Requirement is just a valid unix account.
												</para>
											</listitem>
											<listitem>
												<para>
													<emphasis role="italics">Use SSH key authentication :</emphasis>
													User login and password are not used here, administrator must generate ssh key pair,
													add public key in authorized key and give private key to users. SSH localhost will be used for this method.
													User must provide (to the scheduler) a credentials containing the corresponding private ssh key. Here's an example of a command to create such a credential :
												</para>
												<para>
													<emphasis>bin/unix/create-cred -F config/authentication/keys/pub.key -l username -p userpwd -k path/to/private/sshkey -o myCredentials.cred</emphasis> :
													This command will create a new credentials with "username" as login, "userpwd" as password, using scheduler public key at "config/authentication/keys/pub.key"
													for credentials encryption and using the private ssh key at "path/to/private/sshkey" provided by administrator. The new credential will be stored in "myCredentials.cred"
												</para>
											</listitem>
										</orderedlist>
									</para>
								</listitem>
								<listitem>
									<para>
										<emphasis>On Windows system :</emphasis> User account must be created on the windows host with
										same username//password as the corresponding scheduler user account. The process running the node must be started under
										administrator user with 2 needed privileges (default windows configuration) : SE_ASSIGNPRIMARYTOKEN_NAME and SE_INCREASE_QUOTA_NAME.
									</para>
								</listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para>
								<emphasis>At node level :</emphasis> The node must be configured by setting the method of system authentication
								the administrator wants to use. It is done by setting a Java property at node startup,
								<emphasis role="italics">pa.laucher.forkas.method</emphasis> which value can be :
								<itemizedlist>
									<listitem>
										<para>
											"none" : no method is used, user cannot execute task under his account
										</para>
									</listitem>
									<listitem>
										<para>
											"pwd" : password method is used, user will start the task using his scheduling login and password.
											On Unix, if sudoer list is used, user will be authenticated using his username only.
										</para>
									</listitem>
									<listitem>
										<para>
											"key" : ssh private key is used, user must provide a credentials containing login//password
											and a private ssh key provided by administrator to allow user to execute process with ssh on localhost.
										</para>
									</listitem>
								</itemizedlist>
							</para>
						</listitem>
					</orderedlist>
				</para>
			</section>
		<section xml:id="accounting"><info><title>Accounting</title></info>
			<para>
				The Scheduler keeps track on how much jobs and tasks were done by a user. All the values are computed since the creation of the
				database.
			</para>
				<itemizedlist>
					<listitem>
						<para>The total job count: the count of all jobs initiated by a user.</para>
					</listitem>
					<listitem>
						<para>The total job duration: the overall amount of time spent in job execution initiated by a user.</para>
					</listitem>					
					<listitem>
						<para>The total task count: the count of all tasks initiated by a user.</para>
					</listitem>
					<listitem>
						<para>The total task duration: the overall amount of time spent in task execution.</para>
					</listitem>
				</itemizedlist>
			<para>
				The accounting information can be accessed through a JMX client or through the Scheduler GUI.
			</para>				
		</section>
		<section xml:id="jmx"><info><title>Connecting to JMX as administrator</title></info>
		
		<para>
			The JMX interface for remote management and monitoring provides information about the running ProActive Scheduler and allows the user to modify its configuration.			 
			For more details about JMX concepts please refer to official documentation about the <link xlink:href="http://java.sun.com/j2se/1.5.0/docs/guide/jmx/overview/architecture.html">JMX architecture</link>.  
		</para>
		<para>
			<figure xml:id="jmx_archi">
				<info>
					<title>Structure of the Scheduler JMX interface</title>
				</info>
				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%"
							fileref="images/png/jmx/jmx_archi.png" format="PNG" />
					</imageobject>
				</mediaobject>
			</figure>
		</para>		
		<para>
			The following aspects (or services) of the ProActive Scheduler are instrumented using MBeans that are managed through a JMX agent.
			<itemizedlist>
			<listitem>
				<para>
					The Scheduler <emphasis>Core</emphasis> exposes various runtime information using the <emphasis>RuntimeDataMBean</emphasis> such as:
					<itemizedlist>
						<listitem>
							<para>The Scheduler status</para>
						</listitem>						
						<listitem>
							<para>Pending/Running/Finished/Total job and task count</para>
						</listitem>
						<listitem>
							<para>Some average values</para>
						</listitem>
					</itemizedlist>
				</para>
			</listitem>
			<listitem>
				<para>
					The <emphasis>Accounts Manager</emphasis> exposes accounting information for a specific user with the <emphasis>MyAccountMBean</emphasis> and <emphasis>AllAccountsMBean</emphasis> such as:
					<itemizedlist>
						<listitem>
							<para>The total job and task count</para>
						</listitem>						
						<listitem>
							<para>The total job and task duration</para>
						</listitem>
					</itemizedlist>
				</para>
			</listitem>
			<listitem>
				<para>
					Various management operations are exposed using the <emphasis>ManagementMBean</emphasis> such as:
					<itemizedlist>
						<listitem>
							<para>Setting the accounts refresh rate</para>
						</listitem>						
						<listitem>
							<para>Refresh all accounts</para>
						</listitem>
						<listitem>
							<para>Reload the permission policy file</para>
						</listitem>
					</itemizedlist>					
				</para>
			</listitem>
		</itemizedlist>			
		</para>
		<para>
			As shown on <xref linkend="jmx_archi"/> the MBean server can be accessed by remote applications using one of the two available connectors:
			<itemizedlist>
				<listitem>
					<para>The standard solution based on Remote Method Invocation (RMI) protocol is the RMI Connector accessible at the following url:</para>
					<para>
						<literal>service:jmx:rmi:///jndi/rmi://</literal><emphasis>HOSTNAME</emphasis><literal>:</literal><emphasis>PORT</emphasis><literal>/JMXSchedulerAgent</literal>
					</para>
					<para>where</para>
					<itemizedlist>
						<listitem>
							<para><emphasis>HOSTNAME</emphasis> is the hostname on which the Scheduler is started</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>PORT</emphasis> (5822 by default) is the port number on which the JMX RMI connector server
								has been started, it is defined by the property <emphasis>pa.scheduler.jmx.port</emphasis>
							</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>The ProActive Remote Objects Connector provides ProActive protocol aware connector accessible at the following url:</para>									
					<para>
						<literal>service:jmx:ro:///jndi/</literal><emphasis>PA_PROTOCOL</emphasis><literal>://</literal><emphasis>HOSTNAME</emphasis><literal>:</literal><emphasis>PORT</emphasis><literal>/JMXSchedulerAgent</literal>
					</para>
					<para>where</para>
					<itemizedlist>
						<listitem>
							<para><emphasis>PA_PROTOCOL</emphasis> is the protocol defined by the <emphasis>proactive.communication.protocol</emphasis> property</para>
						</listitem>
						<listitem>
							<para><emphasis>HOSTNAME</emphasis> is the hostname on which the Scheduler is started</para>
						</listitem>
						<listitem>
							<para><emphasis>PORT</emphasis> is the protocol dependent port number usually defined by the property <emphasis>proactive.PA_PROTOCOL.port</emphasis>  
							</para>
						</listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>		
		</para>
		<para>
			The name of the connector (JMXSchedulerAgent by default) is defined by the property <emphasis>pa.scheduler.jmx.connectorname</emphasis>.
		</para>
		<para>
			The JMX url on which to connect can obtained from the Authentication API of the Scheduler or by reading the log file
			located in <literal>$SCHEDULER_HOME/.logs/SchedulerDev.log</literal>. In the log file, the address you have to retrieve is the one where 
			the JMX RMI connector server has been started.
			Once connected, you'll get an access to Scheduler statistics and accounting.
		</para>
		<para>
			For example, to connect to the Scheduler JMX Agent with the popular JConsole tool, just enter the url of the standard
			RMI Connector as shown on the <xref linkend="jmx_jconsole_connect"/>, as well as the username and the password.
		</para> 			  
			<figure xml:id="jmx_jconsole_connect">
				<info>
					<title>Connection using JConsole</title>
				</info>
				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%"
							fileref="images/png/jmx/jmx_jconsole_connect.png" format="PNG" />
					</imageobject>
				</mediaobject>
			</figure>
		
		<para>
			Then depending on the allowed permissions browse the attributes of the MBeans.
		</para>			  
			<figure xml:id="jmx_jconsole">
				<info>
					<title>Browse MBean attributes</title>
				</info>
				<mediaobject>
					<imageobject>
						<imagedata scalefit="1" width="100%" contentdepth="100%"
							fileref="images/png/jmx/jmx_jconsole.png" format="PNG" />
					</imageobject>
				</mediaobject>
			</figure>									
		</section>
		<section xml:id="Extend_scheduler"><info><title>Extend the ProActive Scheduler</title></info>
			<section xml:id="Extend_scheduler_policy"><info><title>Add a new scheduling policy</title></info>
				<para>
					Create and add a new scheduling policy remains a very simple work. You just have to implements the
					<emphasis>
						org.ow2.proactive.scheduler.policy.Policy
					</emphasis>
					interface and start a new Scheduler with this new policy as argument, or dynamically change it
					if the scheduler is already running.
				</para>
				<para>
					Here is the interface which has to be implemented. The default implementation is <emphasis>DefaultPolicy</emphasis>
					in the same package:
				</para>
				<programlisting language="java">
public abstract class Policy implements Serializable {
	//Resource Manager state field.
	public RMState RMState = null;
	//method to implement
	public abstract Vector&lt;EligibleTaskDescriptor&gt; getOrderedTasks(List&lt;JobDescriptor&gt; jobs);
}
				</programlisting>
				<para>
					This method returns all the tasks that have to be scheduled. Tasks must be in the desired scheduling
					order. The first task to be scheduled will be the first in the returned Vector.
				</para>
				<para>
					The parameters is a list of running and pending jobs,
					which contain tasks to be scheduled. Some properties in each job and task
					can be accessed in order to make your own scheduling order. It is also possible
					to access to the "RMState" field that allows you to have information about resources like
					used nodes, total nodes number, etc. The only thing to do is to
					<emphasis>extract the task</emphasis>, <emphasis>re-order them</emphasis>
					and <emphasis>put them in a vector</emphasis>. Let's see the default implementation of the ProActive
					Scheduler policy to illustrate it:
				</para>
				<programlisting language="java">
public class DefaultPolicy implements PolicyInterface {

	/**
	 * This method returns the tasks using FIFO policy according to the jobs priorities.
	 *
	 * @see org.objectweb.proactive.extensions.scheduler.policy.PolicyInterface#getReadyTasks(java.util.List)
	 */
	@Override
	public Vector&lt;EligibleTaskDescriptor&gt; getOrderedTasks( List&lt;JobDescriptor&gt; jobs) {

		Vector&lt;EligibleTaskDescriptor&gt; toReturn = new Vector&lt;EligibleTaskDescriptor&gt;();

		//sort jobs by priority
		Collections.sort(jobs);

		//add tasks to the list to return
		for (JobDescriptor lj : jobs) {
			toReturn.addAll(lj.getEligibleTasks());
		}

		//return
		return toReturn;

	}
}
				</programlisting>
				<para>
					By default, jobs know how to be sorted regarding to their priorities. But it is simpler to create a Comparator
					and sort jobs with it. It is also possible to have some information about resources using the protected
					<emphasis>RMState</emphasis> field inside the getOrderedTasks method.
				</para>
			</section>
		</section>

	<section xml:id="Scheduler_authentication"><info><title>Configure users authentication</title></info>
		<para>As presented before, scheduler users are authenticated at scheduler connection. Users have to enter a login and a password checked by Scheduler. There are
		two authorization levels:
		</para>
		<itemizedlist>
			 <listitem><para><emphasis>user level:</emphasis> enables to submit jobs (see waiting queue, jobs running and jobs finished). They can change priority of their jobs, with 3 priority levels:
			 lowest, low and normal. They are able to see their jobs output, cancel and retrieve results only from their own jobs.
			 They cannot perform actions on jobs submitted by other users.</para>
			 </listitem>
			 <listitem><para><emphasis>admin level:</emphasis> enables to pause, stop and restart scheduler, cancel or retrieve results of any job,
			 change priority of any job, with 5 priority levels: lowest, low, normal, high and highest.</para>
			 </listitem>
		</itemizedlist>

		<section xml:id="Sched_authent_crypto"><info><title>KeyPair authentication</title></info>

		  <para>
		    Regardless of which method is actually used to perform the authentication,
		    credentials need to be passed from the client to the Scheduler, through the network.
		    The data will be encrypted with an AES symmetric secret key to allow unlimited credentials size,
		    and the AES key itself will be encrypted with an RSA key pair.

		    <figure xml:id="scheduler_crypto_pic"><info><title>Credentials encryption</title></info>
		      <mediaobject>
			<imageobject>
			  <imagedata width="60%" align="center" fileref="images/png/admin_manual/schedulerCrypto.png" format="PNG"/>
			</imageobject>
		      </mediaobject>
		    </figure>
		  </para>


		  <para>
		    The Key pair can be generated with the <emphasis>key-gen[.bat]</emphasis> script:
		    <screen><![CDATA[
bin/unix$ ./key-gen -p $HOME/.proactive/priv.key -P $HOME/.proactive/pub.key
]]></screen>
		    Accordingly, the Scheduler configuration has to be set so that, when started:
		    <itemizedlist>
		      <listitem><para>
			  <emphasis>pa.scheduler.auth.privkey.path=</emphasis>$HOME/.proactive/priv.key
		      </para></listitem>
		      <listitem><para>
			  <emphasis>pa.scheduler.auth.pubkey.path=</emphasis>$HOME/.proactive/pub.key
		      </para></listitem>
		    </itemizedlist>
		    Although no encryption should be performed on server side, the public key should be known from the Scheduler:
		    indeed, a client can request the public key to the Scheduler so that it may encrypt its credentials to perform
		    authentication. This method does not require the administrator of the Scheduler to manually propagate public keys
		    to all its users.
		    Users can encrypt theirs credentials with the <emphasis>create-cred[.bat]</emphasis> script.
		    See <xref linkend="Submit_a_job_java"/> for client-side configuration.
		  </para>
		</section>


		<section xml:id="Sched_authent_select"><info><title>Select authentication method</title></info>
			<para>
			So that the Scheduler can manage users authentication and authorization, it has to store users account/password, and check login and password at users' connection.
			This storage of user accounts can be managed in two ways: by files, or by LDAP. A Scheduler property (in <literal>config/scheculer/settings.ini</literal>)
			specifies which kind of authentication will be used:
			</para>
				<programlisting language="sh">
#Property that defines the method that has to be used for logging users to the Scheduler
#It can be one of the following values:
#	- "SchedulerFileLoginMethod" to use file login and group management
#	- "SchedulerLDAPLoginMethod" to use LDAP login management
pa.scheduler.core.authentication.loginMethod=SchedulerFileLoginMethod</programlisting>
			<para>
			By default, authentication method is by file (SchedulerFileLoginMethod). If you want to use the LDAP-based authentication,
			replace the "SchedulerFileLoginMethod" value by "SchedulerLDAPLoginMethod".
			</para>
		</section>
		<section xml:id="file_Sched_authent"><info><title>Configure file-based authentication</title></info>
			<para>By default, the Scheduler stores user accounts, passwords, and group memberships (user or admin), in two files:
			</para>
			<itemizedlist>
				<listitem><para><emphasis>config/authentication/login.cfg</emphasis> stores the user names and passwords of accounts.
				Each line has to look like <emphasis>user:passwd</emphasis>.
				The default <literal>login.cfg</literal> file is given hereafter:</para>
				<programlisting language="java">
admin:admin
demo:demo
user:pwd
test:pwd
radmin:pwd
nsadmin:pwd
provider:pwd
scheduler:scheduler_pwd</programlisting>
				</listitem>
				<listitem><para><emphasis>config/authentication/group.cfg</emphasis> stores the user names of memberships. For each
				user registered in <literal>login.cfg</literal>, a group membership has to be defined in this file.
				Each line has to look like <emphasis>user:group</emphasis>. Group has to be <emphasis>user</emphasis> to have user
				rights, or <emphasis>admin</emphasis> to have administrator rights.
				Default <literal>group.cfg</literal> file is like this:</para>
				<programlisting language="java">
admin:admin
demo:admin

provider:providers

user:user
scheduler:user

radmin:rmcoreadmins
nsadmin:nsadmins
admin:nsadmins</programlisting>
				</listitem>
			</itemizedlist>
			<para>You can change the default paths of these two files. Edit the <emphasis>config/scheduler/settings.ini</emphasis> file and change
			the two following properties:
			</para>
			<itemizedlist>
				<listitem><para><emphasis>pa.scheduler.core.defaultloginfilename</emphasis> - To define a user/password file, change this line as follows:
				pa.scheduler.core.defaultloginfilename=/path/to/the/file/mylogins.cfg</para>
				</listitem>
				<listitem><para><emphasis>pa.scheduler.core.defaultgroupfilename</emphasis> - To define a group membership file, change the line as follows:
				pa.scheduler.core.defaultgroupfilename=/path/to/the/file/mygroups.cfg</para>
				</listitem>
			</itemizedlist>
		</section>
		<section xml:id="LDAP_Sched_authent"><info><title>Configure LDAP-based authentication</title></info>
			<para>
				Scheduler is able to connect to an existing LDAP to check users' login/password, and verify users' group membership. This authentication method can be useful
				if you have in your organization an LDAP that already stores user/password entries. There are several points to configure: path in LDAP where scheduler users and admins
				entries are stored, LDAP groups that define user and admin group membership, URL of the LDAP, LDAP binding method used by connection
				and configuration of SSL/TLS if you want a secured connection between Scheduler and LDAP. All LDAP connection parameters are set in <emphasis>config/authentication/ldap.cfg</emphasis>.
			</para>
			<para>
			<emphasis>config/scheduler/settings.ini</emphasis> defines a path to a configuration file that contains all LDAP connection and authentication properties.
			Default value for this property defines a default configuration file: <emphasis>config/authentication/ldap.cfg</emphasis>. Specify your LDAP properties (explained below) in this file.
			</para>
			<section xml:id="LDAP_users_URL"><info><title>Set LDAP url</title></info>
				<para>First, you have to define the URL of your organisation's LDAP. This address corresponds to the property: <emphasis>pa.ldap.url</emphasis>.
				 You have to put a standard LDAP-like URL, for example <emphasis>ldap://myLdap</emphasis>. You can also set an URL with secure access: <emphasis>ldaps://myLdap:636</emphasis>.
				 See <xref linkend="LDAP_SSL"/> for SSL/TLS configuration.
				 </para>
			</section>
			<section xml:id="LDAP_users_subtree"><info><title>Set users subtree and login attribute</title></info>
				<para>You have to define where users' entries are stored in LDAP tree, i.e. the path where Scheduler will try to find users' and admins' entries.
				The users subtree corresponds to the property: <emphasis>pa.ldap.userssubtree</emphasis>. Put a DN of your LDAP like this:
				<literal>pa.ldap.userssubtree=ou=myUsers,o=myOrganisation,dc=myFirm,dc=com</literal>.
				</para>
				<para>Then, you have to specify in users' entries, the attribute that corresponds to the user login. This is done by the property: <emphasis>pa.ldap.user.login.attr</emphasis>.
				Put an attribute name like this: <literal>pa.ldap.user.login.attr=loginName</literal>.
				</para>
			</section>
			<section xml:id="LDAP_groups"><info><title>Set users and admin groups</title></info>
				<para>
				After having found a user entry in LDAP, and checked the user's password, LDAP checks the user's group membership. Your
				organization's LDAP has to provide two entries of type <emphasis>groupOfUniqueNames</emphasis>, that present attributes
				of type <emphasis>uniqueMember</emphasis>. This type corresponds to users' DN that has access to the Scheduler (typical group definition in a LDAP). You have to set
				the two entries of this type wherein users' and admins' DN are put in 'uniqueMemeber' attribute. Admins group DN is set in scheduler by the property
				<emphasis>pa.ldap.admins.group.dn</emphasis>. User group DN is set by the property <emphasis>pa.ldap.users.group.dn</emphasis>.
				</para>
			</section>
			<section xml:id="LDAP_binding_method"><info><title>Configure LDAP authentication parameters</title></info>
				<para>
					By default, the Scheduler binds to LDAP in anonymous mode. You can change this authentication method by modifying the property <emphasis>pa.ldap.authentication.method</emphasis>.
					This property can have several values:
					<itemizedlist>
						<listitem><para><emphasis>none</emphasis> (default value) - the Scheduler performs connection to LDAP in anonymous mode.</para>
						</listitem>
						<listitem><para><emphasis>simple</emphasis> - the Scheduler performs connection to LDAP with a specified login/password (see below for user password setting).</para>
						</listitem>
						<listitem><para>You can also specify a SASL mechanism for LDAPv3. There are many SASL mechanisms available:
						<emphasis>cram-md5</emphasis>, <emphasis>digest-md5</emphasis>, <emphasis>kerberos4</emphasis>... Just put <emphasis>sasl</emphasis> to this property
						to let scheduler JVM choose SASL authentication mechanism.</para>
						</listitem>
					</itemizedlist>
				</para>
				<para>
					If you specify an authentication method different from 'none' (anonymous connection to LDAP),
					you have to specify a login/password for authentication. There are two properties in <literal>config/scheduler/settings.ini</literal> to set:
					<itemizedlist>
						<listitem><para><emphasis>pa.ldap.bind.login</emphasis> - set user name for authentication.</para>
						</listitem>
						<listitem><para><emphasis>pa.ldap.bind.pwd</emphasis> - set password for authentication.</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>
			<section xml:id="LDAP_SSL"><info><title>Set SSL/TLS parameters</title></info>
				<para>Scheduler is able to communicate with LDAP with a secured SSL/TLS layer. It can be useful if your network is not trusted, and critical information are transmitted
					between scheduler and LDAP, such as users' passwords.
					First, set the LDAP URL property <emphasis>pa.ldap.url</emphasis> to a URL of type ldaps://myLdap.
					Then, set <emphasis>pa.ldap.authentication.method</emphasis> to none so as to delegate authentication to SSL.
				</para>
				<para>For using SSL properly, you have to specify your certificate and public keys for SSL handshake. Java stores
					certificates in a keyStore and public keys in a trustStore. In most of cases, you just have to define a trustStore with public
					key part of LDAP's certificate. Put certificate in a keyStore, and public keys in a trustStore
					with the keytool command (keytool command is distributed with standard java platforms):
				</para>
				<para>
					keytool -import -alias myAlias -file myCertificate -keystore myKeyStore
				</para>
				<para>
					<emphasis>myAlias</emphasis> is the alias name of your certificate, <emphasis>myCertificate</emphasis> is your private certificate file and
					<emphasis>myKeyStore</emphasis> is the new keyStore file produced in output. This command asks you to enter a password for your keyStore.
				</para>
				<para>
					Put LDAP certificate's public key in a trustStore, with the keytool command:
				</para>
				<screen>keytool -import -alias myAlias -file myPublicKey -keystore myTrustStore</screen>
				<para>
					<emphasis>myAlias</emphasis> is the alias name of your certificate's public key, <emphasis>myPublicKey</emphasis> is your certificate's public
					key file and <emphasis>myTrustore</emphasis> is the new trustStore file produced in output. This command asks you to enter a password for your trustStore.
				</para>
				<para>
					Finally, in <emphasis>config/authentication/ldap.cfg</emphasis>, set keyStore and trustStore created before to theirs respective passwords:
				</para>
				<itemizedlist>
					<listitem><para>
					Set <emphasis>pa.ldap.keystore.path</emphasis> to the path of your keyStore.</para>
					</listitem>
					<listitem><para>
					Set <emphasis>pa.ldap.keystore.passwd</emphasis> to the password defined previously for keyStore.</para>
					</listitem>
					<listitem><para>
					Set <emphasis>pa.ldap.truststore.path</emphasis> to the path of your trustStore.</para>
					</listitem>
					<listitem><para>
					Set <emphasis>pa.ldap.truststore.passwd</emphasis> to the password defined previously for trustStore.</para>
					</listitem>
				</itemizedlist>
			</section>
			<section xml:id="LDAP_fall-back"><info><title>Use fall back to file authentication</title></info>
				<para>You can use simultaneously file-based authentication and LDAP-based authentication.
				Indeed, If the LDAP-based authentication fails, Scheduler can check users' password and group membership in login and group files, as performed in the FileLogin method.
				It uses the <emphasis role="bold">pa.scheduler.core.defaultloginfilename</emphasis>  and
				<emphasis role="bold">pa.scheduler.core.defaultgroupfilename</emphasis> files to authenticate user and check group membership.
				There are two rules:
				</para>
				<itemizedlist>
					<listitem><para>
					If LDAP group membership checking fails, fall back to group membership checking with group file.
					To activate this behavior set <emphasis>pa.ldap.group.membership.fallback</emphasis>
					to <emphasis>true</emphasis> in the LDAP configuration file.</para>
					</listitem>
					<listitem><para>
					If a user is not found in LDAP, fall back to authentication and group membership checking with login and group files.
					To activate this behavior, set <emphasis>pa.ldap.authentication.fallback</emphasis> to <emphasis>true</emphasis>, in
					LDAP configuration file.</para>
					</listitem>
				</itemizedlist>
			</section>
		</section>
		<section xml:id="Configure_node_auth"><info><title>Configure node to allow task execution under user system account</title></info>
			<para>
				The ProActive Scheduling is also able to start task under system user account ID if configured. The mechanism requires some system administration
				but remains quite simple. The goal is to configure system to be able to accept user account connection (password or ssh) and then configured the node
				to specify what kind of authentication method it will accept :
			</para>
			<para>
				<orderedlist>
					<listitem>
						<para>
						<emphasis>System configuration : </emphasis>The system must be configured to accept user system connection.
						So you must add account to user which must have the same username as the name in Scheduler account.
						You can authorized user accessing host throught password and/or using ssh connection.
						For exemple, if you don't want to use password authentication, you can generate public and private couple of key,
						add the public key to 'authorized_keys' file in every host that will authorized this key and give the private key to every user that should be able
						to access those hosts.
						</para>
						<para>
							Note : if you use only password authentication, username/password of Scheduler users must be the same as system username/password.
						</para>
					</listitem>
					<listitem>
						<para>
						<emphasis>User configuration : </emphasis>The only thing user must do is to create credentials including the private
						ssh key you've generated for him. The section <xref linkend="Submit_a_job_java"/> describe how a user can create his credentials using
						private ssh key.
						</para>
						<para>
							If not using ssh authentication, user has nothing special to do except setting the runAsMe property
							to 'true' in his tasks.
						</para>
					</listitem>
					<listitem>
						<para>
						<emphasis>Node configuration : </emphasis>The node must also be configured to accept this king of execution.
						Configure the <emphasis>node</emphasis> is just setting a java property at node deployment. See Resource Manager documentation to know how to specify java properties at node deployment.
						If not configured (default) every "runAsUser" executions will be rejected. If configured, the behavior will depend on the following java property :
						</para>
						<itemizedlist>
							<listitem>
								<para>
								<emphasis>pas.launcher.forkas.method=none :</emphasis> the node won't accept execution under user account.
								</para>
								<para>
								<emphasis>pas.launcher.forkas.method=pwd :</emphasis> the node will only accept execution under user account using password authentication.
								In such a case, the username/password of the Scheduler user must be the same as the system one.
								</para>
								<para>
								<emphasis>pas.launcher.forkas.method=key :</emphasis> the node will only accept execution under user account using ssh authentication method.
								Scheduler username must be the same as the system account one, password can be different as the system authentication will be done with
								ssh key. This method only work on unix system and is safer for system account. (system password is never sent to user, security is just based on a line
								in 'authorized_keys' file.)
								</para>
							</listitem>
						</itemizedlist>
					</listitem>
				</orderedlist>
			</para>
		</section>
	</section>
</chapter>
